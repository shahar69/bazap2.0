# Bazap 2.0 – תיעוד ותכנון פיתוח מקיף
1. רקע מלא
תהליך קבלת הציוד כיום: יחידת התקשוב של גדוד 388 מפעילה מחסן ציוד טכני, שבו נרשם ציוד הניתן לחיילים בצורה ידנית או בקבצי אקסל. חייל המגיע לקבל ציוד ממלא טופס נייר או שהמחסנאי מקליד את פרטיו ואת פרטי הפריטים בתוכנה בסיסית. הנתונים נרשמים בספרים או בגליונות אלקטרוניים, ולאחר מכן ייתכן שמעתיקים אותם למחשב המרכזי. תהליך זה כרוך ברישום ידני של שם המקבל, תאריך, סוג הפריט וכמות, ולעיתים גם חתימת החייל על טופס קבלה פיזי. הרישום הידני נעשה תוך כדי חלוקת הציוד, מה שמאט את חלוקת הציוד בפועל.
הבעיות בתהליך הנוכחי: התהליך הידני גורם לאיטיות משמעותית – על המחסנאי לעצור ולכתוב/להקליד כל פרט במקום לבצע חלוקה מהירה. בנוסף, ריבוי רישומים מקבילים (לדוגמה גם בטופס וגם באקסל) מוביל לכפילויות וסיבוך בריכוז הנתונים. טעויות הקלדה הן שכיחות: שמות פריטים מוקלדים בשגיאות, מספרים נרשמים לא נכון, או פריטים עלולים להירשם פעמיים. חוסר אחידות ברישום (למשל כל מחסנאי כותב תיאור מעט שונה לפריט דומה) יוצר חוסר עקביות. כתוצאה, המלאי עלול להיות לא מדויק, וקשה לחפש היסטוריה – מציאת מי קיבל פריט מסוים דורשת חיפוש ידני בניירת או בקובץ. גם הפקת דו"חות או תמונת מצב של כמות הציוד הקיימת במלאי מורכבת וגוזלת זמן.
הקשר המבצעי של גדוד 388 והצורך: גדוד 388 פועל בגזרת צפון, ויחידת התקשוב שלו אמונה על זמינות ציוד קשר ומחשוב לכל פעילות מבצעית ואימונים. דיוק ומהירות בחלוקת ציוד הן קריטיות: בעת פעילות דחופה, כל עיכוב במחסן פוגע במוכנות הכוח. כמו כן, אם ציוד לא נרשם כהלכה, עלול להיווצר חוסר ציוד פתאומי בשטח (כי חשבו שיש במלאי אך בפועל חולק ולא תועד) – דבר המהווה סיכון מבצעי. יש צורך בפיקוח ובקרה על מי קיבל איזה ציוד ומתי, כדי שבסיום פעילות ניתן יהיה לוודא החזרת ציוד ולאתר ציוד חסר. בנוסף, לאור הדרישות במערך התקשוב, יש לציית לנהלי צה"ל לניהול ציוד טכני, דבר הכולל תיעוד מלא של כל העברות הציוד. המערכת המוצעת אמורה לתת מענה לצרכים אלו על ידי ייעול תהליך הקבלה וצמצום טעויות – מחקרים מראים שהטמעת מערכת ממוחשבת מובנית לתהליך קבלת סחורה מפחיתה טעויות בכ־80%[1], מה שיתרום משמעותית לדיוק המלאי ולמוכנות הגדוד.
2. מטרות המערכת
שיפור מהירות התהליך: המערכת הדיגיטלית תקצר את הזמן הנדרש לרישום קבלת ציוד. כל קבלה תוזן ישירות למערכת דרך ממשק מהיר, ללא צורך ברישום כפול. באופן זה החייל מקבל את הציוד מהר יותר, והמחסנאי לא מתעכב על ניירת תוך כדי החלוקה.
הפחתת כפילויות וטעויות: רישום במערכת מרכזית מונע כפילויות – כל אירוע קבלה מקבל מזהה יחיד, והנתונים מוזנים פעם אחת. המערכת תכלול ולידציות (בדיקות תקינות) למניעת טעויות הקלדה: בחירת פריטים מרשימה מוגדרת במקום הקלדה חופשית, בדיקת תקינות כמו כמות חיובית בלבד וכו'. כך יימנעו שגיאות אנוש ברישום שם פריט או כמות.
שיפור דיוק המלאי ואמינות המידע: כל תנועת ציוד (קבלה על ידי חייל) תתעדכן מיד במלאי. המערכת תעדכן אוטומטית את כמות הפריטים הזמינה לאחר כל קבלה, ובכך תספק תמונת מצב עדכנית של המלאי בכל רגע. עם מערכת כזו, סביר שהמלאי יהיה מדויק יותר ומסונכרן בין כל המשתמשים, כי אין פער בין מה שחולק בפועל למה שמתועד.
מעקב היסטורי ובקרה: המערכת תשמור היסטוריה מלאה של כל הקבלות. ניתן יהיה לחפש במהירות מי קיבל מה ומתי, ללא נבירה בניירת. הדבר מאפשר בקרה טובה יותר – המפקדים יכולים לצפות בדו"חות ולהבין את צריכת הציוד לאורך זמן, לזהות דפוסים (למשל פריט שמתבזבז מהר) ולהיערך בהתאם. במקרי ציוד חסר, היסטוריית החלוקה מסייעת להתחקות מי היה האחרון שקיבל אותו.
שליטה והרשאות: באמצעות דרישת התחברות (Login), רק אנשי המחסן/היחידה המורשים יוכלו לבצע פעולות במערכת. בכך נשמרת אבטחת המידע והציוד – חייל רגיל לא יוכל "לעצמו" להוציא פריט במערכת. בנוסף, מערכת ההרשאות תאפשר זיהוי מי ביצע כל פעולה (audit trail), מה שמגביר אחריותיות ומונע ניצול לרעה.
ייעול וקבלת החלטות: המערכת ה"חכמה" תוכל לספק נתונים לתחקור—לדוגמה, להתריע על פריט שתדירות הוצאתו גבוהה במיוחד (אולי סימן שרצוי להחזיק ממנו יותר במלאי) או להתריע על פריט שכמותו יורדת מתחת לרף שהוגדר. בכך, מעבר לפתרון הבעיות המיידיות, המערכת משיגה שיפור בניהול: זמני תגובה מהירים יותר, פחות תקלות אדמיניסטרטיביות, ויכולת תכנון טוב יותר של המלאי (מה שצריך לחדש, מה שפחות בשימוש). בסופו של דבר, המערכת תשפר את המוכנות המבצעית של הגדוד על ידי הבטחת זמינות ציוד מדויקת ומהירה.
3. תיאור הפתרון הכללי: WebApp מהירה וחכמה
 
המערכת המוצעת, "Bazap 2.0", היא יישום ווב (WebApp) מודרני לניהול קבלת ציוד באופן מהיר וחכם. מדובר במערכת מבוססת דפדפן שתפותח בכלים עדכניים – צד לקוח עשיר לתפעול נוח ומהיר, ושרת צד-שרת אמין לטיפול בלוגיקה ובנתונים. השימוש במערכת יהיה דרך מחשב או טאבלט במחסן (באמצעות רשת פנימית), כך שהמחסנאי יוכל לתפעל אותה בזמן חלוקת הציוד בשטח המחסן.
ארכיטקטורה כללית: הפתרון יופרד לשני חלקים עיקריים – לקוח (Frontend) ושרת (Backend). צד הלקוח יהיה אפליקציית React מהירה (עם מנוע פיתוח Vite) הכתובה ב-TypeScript, שתספק ממשק משתמש (UI) אינטראקטיבי בשפה העברית. צד השרת יהיה שירות ASP.NET Core Web API שירוץ על שרת מקומי (או מחשב המחסן) וישמש כ"שכבת העסק" והגישה למסד הנתונים. מסד הנתונים יהיה קובץ SQLite מקומי, שיאפשר שמירת נתוני המלאי והקבלות בצורה רלציונית ובטוחה. הלקוח יתקשר עם השרת באמצעות קריאות HTTP (פורמט JSON), כך שבכל פעם שמחסנאי מזין קבלה חדשה או מבקש מידע – תישלח בקשה ל-API, והשרת יעבד את הלוגיקה (למשל עדכון מלאי) ויחזיר תשובה מתאימה.
מאפייני "מהירות" ו"חוכמה": המערכת תוכננה להיות מהירה – הן בביצועים והן בשימושיות. מבחינת ביצועים: הטכנולוגיות הנבחרות (React+Vite, ASP.NET Core, SQLite) ידועות ביעילותן; טעינת הדפים תהיה מיידית כמעט, ופעולות כמו שמירת קבלה יעשו בשבריר שנייה. בנוסף, UI אינטראקטיבי ימנע רענון דף מלא – רק הנתונים משתנים דינמית, מה שחוסך זמן. מבחינת שימושיות: הממשק ייבנה כך שידרוש מינימום הקלדה חופשית – בחירת פריטים מתוך רשימה מוגדרת, אפשרות לסרוק ברקוד של פריט (בעתיד) וכד'. המערכת תכלול השלמה אוטומטית בעת חיפוש פריט, ותיתן משוב מיידי על שדות לא תקינים. "חכמה" מתבטאת גם ביכולתה למנוע טעויות (למשל אזהרה אם מנסים להוציא פריט שכבר אין ממנו במלאי) ואולי אפילו להציע כמויות תקניות (לדוגמה, אם פריט מסוים בדרך כלל מחולק בזוגות – המערכת תוכל להתריע אם מוזן מספר אי-זוגי). המערכת תומכת בריבוי משתמשים מורשים, ואם בעתיד ירצו לעבוד ביותר מעמדת מחשב אחת – ניתן להרחיב את הפתרון להתחברות ממספר עמדות (SQLite יכול לתמוך במספר חיבורים לקריאה/כתיבה, או שניתן יהיה לשדרג למסד נתונים שרתיב לפי הצורך).
תמצית זרימת העבודה במערכת: מחסנאי יתחבר למערכת עם שם משתמש וסיסמה. הוא ייגש למסך "קבלת ציוד", יבחר חייל מקבל (לדוגמה הזנת שמו/מספר אישי) ויציין אילו פריטים וכמה מכל סוג ניתנים. המערכת תרכז את הפריטים לקבלה הנוכחית, ותאפשר בלחיצת כפתור לסיים ולשמור את הקבלה. בשמירה, השרת ירשום את כל פרטי הקבלה, יעדכן את כמויות המלאי של אותם פריטים, ויחזיר אישור. הנתונים יישמרו במסד הנתונים מיד, ויהיו זמינים לצפייה במסך היסטוריה. המערכת בנויה כך שברגע נתון רק פעולה אחת נחוצה מהמשתמש (לדוגמה: לבחור פריט מרשימה במקום להקליד קוד ידנית, מה שחוסך זמן).
דגש על אמינות ופשטות: בהינתן שמדובר בצוות שאינו צוות תוכנה, המערכת תוכננה פשוטה לתפעול ולתחזוקה. התקנת המערכת קלה (הפעלה של קובץ התקנה או פריסה דרך Visual Studio), ללא תלות בתשתיות מורכבות. מסד SQLite מאפשר עבודה גם ללא חיבור רשת מלא – כל עוד המחשב המקומי פועל, המערכת זמינה. בנוסף, כל הנתונים מגובים בקובץ יחיד שניתן לגבותו מעת לעת. במידת הצורך, ניתן יהיה להתקין את המערכת גם על מחשב נוסף לצורכי גיבוי או עבודה במקביל (אך אז רצוי מסד מרכזי – שדרוג אפשרי עתידי).
לסיכום, הפתרון הכללי הוא מערכת ניהול קבלה ממוחשבת המאפשרת למחסנאי לבצע את עבודתו במהירות ובדייקנות, תוך ביטול מרבית הבעיות של התהליך הנוכחי. שילוב הטכנולוגיות העדכניות והאינטראקציה ביניהן ב-Bazap 2.0 יאפשר ליחידה לקפוץ דור טכנולוגי קדימה בניהול הציוד.
4. אפיון פונקציונלי מלא
המערכת תסופק כיישום Web עם מספר מסכים עיקריים התואמים לתהליכים ולאובייקטים המרכזיים: מסך קבלת ציוד, מסך ניהול פריטים, מסך היסטוריה, ומסך התחברות. בהמשך מתואר כל מסך, רכיבי ה-UI שבו, וזרימת העבודה המצופה (Happy Path) בכל אחד. כמו כן מפורטים כללי המערכת והנחות היסוד החשובות.
מסך קבלת ציוד (הוצאת ציוד למחזיק)
תיאור כללי: זהו המסך המרכזי שבו המחסנאי מתעד אירוע של מסירת ציוד לחייל (קבלת הציוד מבחינת החייל). המסך מאפשר יצירת "קבלה" חדשה של מספר פריטים בכמות מסוימת, המשויכת למקבל אחד ובתאריך נוכחי.
רכיבי UI במסך קבלת ציוד:
•	כותרת ודף חדש: כותרת בראש העמוד: "קבלת ציוד". מתחתיה יוצג טופס להזנת פרטי הקבלה החדשה.
•	שדה מקבל הציוד: שדה להזנת פרטי החייל שמקבל את הציוד. זה יכול להיות שדה טקסט לכתיבת שם החייל או מספרו האישי. אפשרות לשדה אוטומטי עם השלמה (אם קיימת אינטגרציה לרשימת חיילים, אך במימוש הראשוני נסתפק בהקלדה חופשית כדי לא לסבך). השדה יהיה חובה למילוי.
•	הוספת פריטים לקבלה: חלק מרכזי בטופס המאפשר לציין אילו פריטים נמסרים וכמה. רכיבים:
•	שדה בחירת פריט: רשימה נפתחת (ComboBox) של כל הפריטים הקיימים במלאי/במערכת. המשתמש יבחר את שם הפריט מהרשימה (ניתן גם להתחיל להקליד לחיפוש מהיר ברשימה).
•	שדה כמות: שדה מסוג Number להזנת כמות הפריט שנמסרת. כברירת מחדל 1, וניתן להגדיל. תתבצע ולידציה שהמספר חיובי ושלם.
•	כפתור "הוסף פריט": לחצן שלחיצה עליו תוסיף את הפריט והכמות שצוינו לרשימת הפריטים של הקבלה הנוכחית. אם אחד השדות ריקים או לא תקינים, תופיע הודעת שגיאה ולא תתבצע הוספה.
•	טבלת פריטים שנוספו: מתחת לשדות ההוספה, תוצג טבלה המציגה את כל הפריטים שנוספו לקבלה הנוכחית עד כה. עבור כל פריט יוצגו עמודות: קוד/מזהה פריט, שם הפריט, כמות. בנוסף, לכל שורה כפתור מחיקה (אייקון "אשפה") המאפשר להסיר פריט מרשימת הקבלה אם נעשתה טעות. הטבלה מתעדכנת דינמית בכל הוספה או מחיקה.
•	פעולות סיום: בחלק התחתון של הטופס:
•	כפתור "שמירת קבלה": בלחיצה עליו תתבצע סיום התהליך – המערכת תשמור את הקבלה במסד הנתונים, כולל כל פריטי הטבלה, תעדכן את המלאי, ותציג למשתמש אישור. כפתור זה יהיה פעיל רק אם יש לפחות פריט אחד בטבלה (כדי למנוע שמירת קבלה ריקה) ואם הוזן מקבל.
•	כפתור "נקה/בטל": אפשרות לאתחל את הטופס במידה והתחרטו או רוצים להתחיל מחדש (מאפס את שדה המקבל ואת טבלת הפריטים).
•	הודעות שגיאה והנחיות:
•	אם המשתמש לחץ "הוסף" ללא בחירת פריט או ללא כמות, יוצג ליד השדה החסר הודעת שגיאה ("יש לבחור פריט", "יש להזין כמות").
•	אם הכמות שהוזנה היא 0 או שלילית, תופיע שגיאה "כמות לא תקינה".
•	אם הכמות המבוקשת גבוהה מהכמות הזמינה במלאי לאותו פריט, המערכת יכולה (כתוספת חכמה) לתת אזהרה או למנוע, בהתאם למדיניות (בגרסה ראשונה, אפשר רק להתריע "אזהרה: כמות במלאי נמוכה", אך לא בהכרח לחסום – בהמשך אולי חסימה).
•	אם מנסים להוסיף את אותו פריט פעמיים, המערכת תמנע כפילות: ייתכן שתופיע הודעה "פריט זה כבר נוסף, ניתן לשנות את הכמות בשורה הקיימת" או שהמערכת בעצמה תאחד את השורות (למשל, אם הפריט X כבר בטבלה עם כמות 2, והמשתמש מוסיף שוב כמות 1, המערכת תגדיל את השורה לכמות 3 במקום ליצור שורה חדשה).
•	משוב לאחר שמירה: לאחר לחיצה על "שמירת קבלה" וביצוע תקין, יוצג מסר הצלחה – למשל הודעה "הקבלה נשמרה בהצלחה" בירוק. הטבלה והשדות יתאפסו כדי להיות מוכנים לקליטת קבלה חדשה מיד (שימושי כאשר כמה חיילים מגיעים ברצף). ייתכן שהמערכת גם תציע להדפיס אישור למסירה (לחתימת החייל), אך אפשרות זו בתעדוף משני וניתן להשאיר אותה כידנית אם נדרש.
זרימת עבודה (Happy Path) במסך קבלת ציוד:
1.	המחסנאי בוחר בתפריט את מסך "קבלת ציוד" (לאחר שכבר התחבר למערכת).
2.	הוא רואה טופס ריק. בשדה "מקבל" הוא מזין למשל: "טוראי יוסי כהן".
3.	בשדה בחירת פריט הוא בוחר "מכשיר קשר RF-7800" מתוך הרשימה, ובשדה כמות מזין "1". לוחץ "הוסף פריט" – השורה נוספת לטבלה.
4.	הוא ממשיך לבחור פריט נוסף: "בטרייה 12V", כמות "2". לוחץ הוסף – גם שורה זו מופיעה בטבלה.
5.	כעת הטבלה מציגה 2 שורות. המחסנאי בודק שהכל תקין, ולוחץ "שמירת קבלה".
6.	המערכת מציגה הודעת "נשמר בהצלחה". מאחורי הקלעים: רשומה חדשה של קבלה נוצרה במסד הנתונים, עם שני פריטי קבלה (שורות) המשויכים אליה; יתרת המלאי של מכשיר הקשר ירדה ב-1 ושל הבטריות ירדה ב-2.
7.	הטופס מתנקה לשימוש הבא. המחסנאי יכול כעת לתת לחייל את הפריטים ולסיים את הטיפול בו. אם מיד מגיע החייל הבא, ניתן להתחיל למלא קבלה חדשה ללא רענון דף.
כללים והנחות מיוחדות במסך זה:
•	פעולת השמירה לא תתאפשר אם אין פריטים בטבלה, או אם שדה המקבל ריק. זאת כדי להבטיח שכל קבלה מכילה את הנתונים החיוניים.
•	זמן ותאריך הקבלה ייקבעו אוטומטית בעת השמירה (timestamp של המערכת) – אין צורך ולא ניתן לערוך את התאריך ידנית (כדי למנוע טעויות תאריך).
•	קבלה שנסטרה (נשמרה) לא תהיה ניתנת לעריכה בדיעבד דרך מסך זה – תיקון טעויות ייעשה דרך מנגנון אחר (אולי מחיקת הקבלה ויצירה מחדש על ידי אדמין, ראו דיון בהמשך).
•	המסך מיועד בעיקר לתפקיד "מחסנאי" או כל משתמש שמורשה להוציא ציוד. משתמש שאינו מורשה לא יגיע למסך זה (הממשק ידאג לכך דרך הרשאות).
•	לגבי החזרת ציוד: בגירסה 2.0 זו, אין מסך נפרד ל"החזרת ציוד". הנחת עבודה היא שהחזרת ציוד, במידה ויש לתעדה, תעשה ע"י הוספת מלאי ידנית במסך ניהול פריטים או על ידי יצירת "קבלה שלילית" (לא ממומש כעת). בשלב ראשון, ניהול ההחזרות יתבצע מחוץ למערכת או ברישום ידני, והמיקוד כאן הוא הוצאה (קבלה ע"י החייל).
מסך ניהול פריטים
תיאור כללי: מסך זה מאפשר צפייה ועריכה של רשימת כל הפריטים המנוהלים במערכת. כאן מוגדרים הפריטים שאפשר להוציא. זה כולל הוספת פריט חדש (למשל אם מגיע ציוד חדש למחסן שטרם היה ברשימה), עדכון פריט (למשל שינוי שם או תיקון כמות במלאי), ואפשרות להסרת פריט (במידה והוא יצא משימוש). מסך זה חשוב כדי להבטיח שרשימת הפריטים במערכת משקפת את המציאות במחסן.
רכיבי UI במסך ניהול פריטים:
•	כותרת: "ניהול פריטים".
•	טבלת פריטים: טבלה המציגה את כל הפריטים הקיימים במערכת (מתוך טבלת ה-Item במסד הנתונים). עבור כל פריט עמודות כגון:
•	מק"ט/קוד פריט: מזהה ייחודי או קוד שהוגדר (יכול להיות מספר סידורי פנימי או קוד שהמחסנאי הגדיר).
•	שם הפריט: תיאור קצר, למשל "מכשיר קשר מוטורולה".
•	כמות במלאי: הכמות הנוכחית הזמינה (מחושבת על פי מה שהוזן כהתחלתי פחות כל מה שהוצא דרך קבלות). זהו שדה מידע – ייתכן שיהיה "קריאה בלבד" בטבלה (לא עריך ישירות כאן, אלא דרך פעולות).
•	סטטוס/הערה: אם פריט אינו פעיל יותר (למשל "חסר זמנית" או "יצא משימוש") זה יכול להיות מסומן. בעיצוב ראשוני ניתן להציג רק פריטים פעילים, או עם סימון עבור לא פעילים.
•	פעולות: בעמודה אחרונה לכל שורה – כפתורי פעולה: "עריכה" (אייקון עט) ו"מחיקה" (אייקון פח).
•	כפתור הוספת פריט חדש: מעל או מתחת לטבלה, כפתור בולט "הוספת פריט חדש". לחיצה עליו תאפשר הזנת פריט חדש.
•	טופס הוספה/עריכה: פעולה של הוספה או עריכה תפתח טופס (ייתכן כחלון קופץ modal או באזור ייעודי במסך) בו ניתן להזין/לעדכן את פרטי הפריט:
•	שדה "שם פריט" – טקסט, חובה.
•	שדה "קוד פריט" – טקסט, אופציונלי אך מומלץ (אם לא יוזן, אולי המערכת תיצור אוטומטית קוד מזהה מספרי).
•	שדה "כמות התחלתית" – מספר שלם, ניתן להזין את המלאי ההתחלתי כאשר מוסיפים פריט חדש (למשל אם קלטנו 5 יחידות מפריט חדש למחסן). בעריכה, ניתן להשתמש בשדה זה לעדכון כמות במקרים מיוחדים (למשל תוספת מלאי ממקור חיצוני או תיקון ספירת מלאי).
•	שדה "פעיל/לא פעיל" – צ'קבוקס לסימון האם הפריט זמין להוצאה. פריט לא פעיל לא יופיע במסך קבלת ציוד.
•	לחצני "שמירה" ו"בטל": לשמירת הפריט החדש/העדכון, או ביטול הפעולה.
•	אינטראקציות:
•	לחיצה על "הוספת פריט חדש": מציגה טופס ריק למילוי, המחסנאי ממלא פרטים ושומר.
•	לחיצה על "עריכה" ליד פריט בטבלה: מציגה את טופס הפריט עם ערכים נוכחיים הניתנים לעריכה (למשל לשנות את השם, או לתקן מלאי אם צריך).
•	לחיצה על "מחיקה" ליד פריט: המערכת תבקש אישור "האם אתה בטוח שברצונך למחוק?". אם יאושר, תנסה למחוק את הפריט.
•	כללים עסקיים בניהול פריטים:
•	בעת הוספת פריט, יש לוודא שלא קיים כבר פריט עם אותו שם או אותו קוד. אם מזוהה כפילות, תופיע שגיאה ("פריט בשם/קוד זה כבר קיים").
•	בעת עריכת פריט, בפרט אם משנים את הכמות במלאי ידנית: המערכת צריכה לוודא שהמשתמש מבין שזה עלול להשפיע על הנתונים (אולי התרעה "שינוי כמות עלול ליצור אי-התאמה עם היסטוריית קבלות"). למעשה, שינוי הכמות באופן ידני הוא תחליף לתיעוד החזרה או תוספת ציוד מחוץ למערכת.
•	מחיקת פריט תותר רק אם הפריט לא שויך לאף קבלה קיימת (כלומר לא נעשה בו שימוש עדיין). אם מנסים למחוק פריט שיש לו היסטוריה, המערכת תספק הודעה ולא תמחק בפועל ("לא ניתן למחוק פריט שכבר חולק, ניתן לסמן כלא פעיל במקום").
•	שינוי שם או סימון כלא פעיל לפריט עם היסטוריה יתאפשר (כדי לתקן או להפסיק שימוש), אבל לא ימחק את ההיסטוריה.
•	כמות המלאי של פריט מחושבת כך: כמות נוכחית = כמות אחרונה ידועה + כמות נוספה ידנית (בעריכה) - סך כל הכמויות שחולקו בקבלות. בפועל, ניתן לאחסן במסד גם שדה "QuantityInStock" שמתעדכן אוטומטית בכל יצירת קבלה, וכמו כן מתעדכן אם המשתמש שינה ידנית.
זרימת עבודה לדוגמה במסך ניהול פריטים:
•	הוספת פריט חדש: נניח הגיע סוג חדש של אוזניות קשר למחסן ויש להזינו. המחסנאי לוחץ "הוספת פריט חדש". הוא ממלא: שם = "אוזניות קשר XYZ", קוד = "HDR-02", כמות התחלתית = 10. לוחץ "שמירה". המערכת יוצרת רשומה חדשה של פריט עם מזהה חדש, ומעדכנת את הטבלה. כעת "אוזניות קשר XYZ" מופיע ברשימת הפריטים, וכמו כן יהיה זמין לבחירה במסך קבלת ציוד.
•	עריכת פריט (עדכון מלאי): למשל, בוצעה ספירת מלאי והתברר שבפועל יש 30 כבלים במקום 25. המחסנאי מוצא בטבלה את "כבל רשת 5m", לוחץ עריכה. בשדה כמות הוא מעדכן מ-25 ל-30. לוחץ "שמירה". המערכת מחשבת את ההפרש (5 נוספו) ויכולה ברקע לעדכן רישום שהיו 5 כבלים שנוספו בלי קבלה (אולי כ"ייבוא למלאי"). לאחר השמירה, הטבלה מראה כמות 30. כעת אם ייגשו למסך קבלת ציוד, אותה כבל רשת תוצג עם מלאי 30 זמין.
•	מחיקת פריט: נניח פריט נסוג משימוש (למשל דגם מחשב ישן שלא מחלקים יותר). אם לא חולק מעולם (אין היסטוריה), ניתן למחוק. אבל אם חולק בעבר, המחסנאי יסמן אותו "לא פעיל" (דרך עריכה) ולא ישתמש בו יותר. ברשימת הפריטים אולי ניתן להסתיר פריטים לא פעילים כברירת מחדל, כדי לא להעמיס.
מסך היסטוריה (היסטוריית קבלות ציוד)
תיאור כללי: מסך ההיסטוריה מאפשר לצפות ברשימת כל הקבלות (אירועי קבלת ציוד) שתועדו במערכת. זהו מעין יומן פעילות של המחסן, המשמש לבקרה, מעקב ופיקוח. משתמשים (מחסנאי, קצין טכני, מפקד) יכולים להשתמש במסך זה כדי לענות על שאלות כמו "מי קיבל מחשב נייד בשבוע האחרון?" או "איזה ציוד חולק לתרגיל X?".
רכיבי UI במסך היסטוריה:
•	כותרת: "היסטוריית קבלות" או פשוט "היסטוריה".
•	סרגל חיפוש וסינון: בראש המסך יהיו אפשרויות סינון כדי לצמצם את הרשומות:
•	שדות לבחירת טווח תאריכים (מתאריך X עד Y) כדי להציג רק קבלות בתקופה רצויה.
•	שדה חיפוש טקסט חופשי – יכול לחפש לפי שם מקבל, שם פריט, או מזהה קבלה.
•	ייתכן פילטר לפי סוג פריט (Dropdown של רשימת פריטים כדי לראות כל הקבלות שכללו פריט מסוים).
•	כפתור "סנן" להחלת הסינון, וכפתור "איפוס" לניקוי.
•	טבלת היסטוריה: מציגה את רשימת הקבלות כפלט. כל שורת טבלה מייצגת קבלה אחת:
•	מס' קבלה: מזהה ייחודי (אוטומטי) של הקבלה.
•	תאריך ושעה: מתי נרשמה הקבלה.
•	שם המקבל: כפי שהוזן (חייל/גורם שקיבל את הציוד).
•	פריטים וכמויות: עמודה זו יכולה להציג תקציר, למשל "3 פריטים" או רשימה מקוצרת של שמות הפריטים (למשל "מחשב נייד x1, סוללה x2...").
•	נוצר ע"י משתמש: (אופציונלי) שם המשתמש המחסנאי שביצע את הרישום – חשוב כשיש כמה משתמשים, כדי לדעת מי הוציא.
•	פעולה/פרטים: כפתור "צפה" או "פרטים" בשורה כדי לראות את מלוא פרטי הקבלה.
•	תצוגת פרטי קבלה: בעת לחיצה על "צפה" בשורה, אחת משתי אפשרויות:
•	או שיפתח חלון קופץ/מודאלי עם פירוט: יציג את כל הפריטים שהיו בקבלה הזו, עם הכמויות המדויקות, ואולי הערות אם היו.
•	או שנעבור לעמוד נפרד "פרטי קבלה" (אך עדיף מודאלי כדי לא לעזוב את רשימת ההיסטוריה). במודאל יופיע: רשימת פריטים (שם+כמות) כמפורט, שם המקבל, תאריך, המשתמש שרשם.
•	במודאל יכול להיות גם כפתור "סגור" וכפתור "בטל קבלה" (אם מתירים ביטול/מחיקה, ראה להלן).
•	דפדוף/עמודי עמודים: אם יש הרבה רשומות, הטבלה תהיה עם דפדוף (pagination) למשל 50 קבלות לעמוד. אפשר לעבור בין עמודים.
•	ייצוא: לא חובה, אבל ניתן לשקול כפתור "ייצא לאקסל" או "הדפס דוח" עבור טווח הסינון הנוכחי. בכך אם רוצים להגיש דוח תקופתי, זה מקל.
כללים עסקיים במסך היסטוריה:
•	כברירת מחדל יוצגו הקבלות מהחדשות לישנות (מיון יורד לפי תאריך).
•	סינון לפי פריט: אם המשתמש בוחר פריט מסוים, יוצגו רק קבלות שבהן הייתה שורת קבלה עם אותו פריט. זה מצריך שאילתות מתקדמות (כולל JOIN או חיפוש ברשימת השורות).
•	זמני שמירת הנתונים: בהנחה שאין עניין פרטיות רגיש – נשמור היסטוריה ללא הגבלת זמן (כדי לראות גם שנים אחורה). אם יש דרישה לנקות, ניתן להוסיף בהמשך אפשרות ארכיון.
•	ביטול/מחיקת קבלה: בגירסת בסיס, לא ניתן למחוק קבלה דרך הממשק (כדי לא לפגוע בשרשרת האספקה ולמנוע "העלמת" רישומים). אולם, ייתכן מצב שקבלה נרשמה בטעות ויש לתקן. אפשרות אחת היא ליצור מנגנון "ביטול קבלה" – כפתור במודאל הפרטים שאומר "בטל את הקבלה הזו". אם לוחצים, תידרש סיסמת מנהל לאישור. הביטול יכול להתבטא כך: יצירת רשומת קבלה הפוכה (נגדית) שמחזירה את הפריטים למלאי, או פשוט סימון הקבלה כמבוטלת + החזרת המלאי. כדי לפשט, אפשר לומר: כרגע אין מחיקה, ואם יש טעות, על מנהל המערכת לתקן ידנית דרך מסד הנתונים או דרך הוספת מלאי בפריט (פתרון עקיף).
•	הרשאת צפייה: גם משתמש רגיל (מחסנאי) וגם מנהל יכולים לצפות בהיסטוריה. ייתכן שאפילו יתנו גישת "צפייה בלבד" למפקדים – למשל מפקד שיוכל להתחבר ולראות היסטוריה אך לא לשנות/להוסיף. דבר זה דורש תפקידים שונים.
זרימת עבודה לדוגמה במסך היסטוריה:
•	קצין התקשוב נכנס למערכת, ובמקום להיכנס למסך קבלת ציוד, הוא פותח את "היסטוריה". הוא רואה רשימה של כל הקבלות שבוצעו. הוא מסנן בתיבת החיפוש את המילה "מחשב", ורואה את כל הפעמים שמחשב נייד חולק. מהטבלה הוא מוצא שב-5.1.2026 חולק מחשב נייד ללוי רן. הוא לוחץ "צפה" ליד אותו רישום, ומקבל חלון שמראה: "קבלה מס' 17, תאריך 5.1.2026 14:35, מקבל: סרן רן לוי, פריטים: מחשב נייד Toughbook x1, מטען למחשב x1. נרשם ע"י: admin". הקצין מוודא שהמחשב הזה חזר, ואם לא – יש לו את שם המקבל לפנות אליו.
•	דוגמה נוספת: מחסנאי רוצה לסכם כמה מכשירי קשר יצאו ברבעון האחרון. הוא מסנן תאריך מ-1.1.2026 עד 31.3.2026, ובוחר בפריט "מכשיר קשר RF-7800" בפילטר. הטבלה מציגה אולי 3 רשומות של קבלות שכללו פריט זה. הוא יכול ידנית לראות שסך הכמויות ברשומות הוא 3 יח'. (בעתיד אולי נוסיף סיכום אוטומטי).
•	אם היה אפשר ביטול: נניח קבלה נרשמה פעמיים בטעות לאותו חייל. המחסנאי מזהה זאת בהיסטוריה, פונה למנהל – המנהל ימצא את הקבלה הנוספת, יפתח, ילחץ "בטל קבלה". המערכת תשאל "לבטל את קבלה 18? הפריטים יחזרו למלאי.", מאשר, והקבלה מסומנת כמבוטלת (אולי נשארת ברשימה עם ציון מיוחד). המלאי מתעדכן חזרה.
מסך התחברות (Login)
תיאור כללי: זהו המסך הראשון שהמשתמשים יראו, המשמש לאימות זהותם לפני שימוש במערכת. רק לאחר התחברות מוצלחת יתאפשר גישה למסכים האחרים. מטרת ההתחברות היא אבטחה (שרק מורשים יפעלו) וגם רישום מי המשתמש הפעיל לצורך Audit Trail.
רכיבי UI במסך התחברות:
•	שדות התחברות:
•	"שם משתמש" – Textbox להזנת username.
•	"סיסמה" – Textbox מסוג password (התוויה מוסתרת) להזנת סיסמה.
•	כפתור "התחבר": שליחה של הטופס. יהיה פעיל רק אם מולאו שני השדות.
•	זכירת משתמש: (אופציונלי) צ'קבוקס "זכור אותי" כדי להישאר מחובר. אפשרות זו נשקלת אם יש צורך (בסביבה צבאית ייתכן שלא כדי למנוע גישה לא מורשית אם שכחו להתנתק).
•	הודעות שגיאה: אם ההתחברות נכשלה (שם משתמש או סיסמה שגויים), יוצג הודעה "שם המשתמש או הסיסמה שגויים, נסה שוב." גם במקרה שהשרת לא זמין או שגיאה אחרת – יציג מסר מתאים ("לא ניתן להתחבר לשרת, בדוק חיבור.").
•	עיצוב: מסך זה יהיה פשוט ונגיש. אולי יכלול לוגו היחידה או תמונת אילוסטרציה קטנה (כגון סמל תקשוב או גדוד 388) לטאצ' אישי. מעבר לכך, רק השדות והכפתור. רצוי למקם אותו מרכז במסך.
•	איפוס סיסמה: לא יהיה מנגנון שחזור סיסמה אוטומטי (אין דוא"ל וכו'), אלא אם צריך לשנות – מנהל מערכת יעשה זאת ידנית (מחוץ למערכת, או אולי נוסיף מסך ניהול משתמשים בעתיד).
•	לאחר התחברות: אם הנתונים תקינים, המערכת תעביר אוטומטית לדף הראשי (נניח דף קבלת ציוד). במקביל תישמר אסימון (Token) או Session שמאפשר להישאר מחובר.
כללים והערות:
•	ניהול משתמשים: במסמך זה לא התבקש מסך ניהול משתמשים, לכן נניח שהמערכת תבוא עם משתמשים מוגדרים מראש (דרך Seed, ראה סעיף 11) ומנהל המערכת יוכל לערוך/להוסיף משתמשים דרך מסד הנתונים או כלי פשוט אם יפותח בהמשך.
•	אבטחת סיסמה: הסיסמה תישמר במסד באופן מוצפן (Hash+Salt) ולא בטקסט גלוי, כדי למנוע ניצול אם בסיס הנתונים נחשף. האימות יעשה על ידי השוואת hash.
•	הרשאות: ייתכן שני תפקידי משתמשים: מנהל ומחסנאי רגיל. מנהל יוכל הכל (כולל ניהול פריטים ומשתמשים), ומחסנאי רגיל אולי לא יוכל למחוק פריט או להוסיף משתמש. אבל ברמת מסכים כרגע, שניהם רואים את אותם מסכים (פרט לאפשרויות מחיקה/ביטול שמנהל יכול).
•	Timeout: אם משתמש נשאר לא פעיל, אפשר לקבוע Timeout (למשל 30 דקות) שמחייב login מחדש, לטובת אבטחה. זו החלטת קונפיגורציה שתומכת במערכת (JWT token exp למשל).
•	התנתקות (Logout): באפליקציית הלקוח יהיה כפתור "התנתק" (כנראה בתפריט עליון או תחתון) שמאפשר למשתמש לצאת מחשבון המשתמש, מה שיחזיר אותו למסך ההתחברות. בכך ניתן להעביר את העמדה למשתמש אחר או לנעול בסוף שימוש.
זרימת עבודה במסך התחברות:
1.	המחסנאי פותח את האפליקציה (כתובת URL מקומית). מוצג מסך התחברות. הוא מקליד שם משתמש (למשל: bazapAdmin) וסיסמה (נגיד: P@ssw0rd).
2.	לוחץ "התחבר". המערכת שולחת את הנתונים לשרת (API של התחברות). השרת בודק במסד את המשתמש והסיסמה (לאחר hashing) ומתאים.
3.	במקרה הצלחה, השרת מחזיר אסימון JWT חתום, או אישור Session. הלקוח שומר זאת (בזיכרון/LocalStorage) ומשנה מצב ל"מחובר".
4.	הלקוח מנווט אוטומטית למסך קבלת ציוד (או לדאשבורד ראשי במערכת). מעתה כל בקשת API מהלקוח תכלול את האסימון במידת הצורך (Authentication Header) כדי שהשרת ידע שהמשתמש מאומת.
5.	אם ההתחברות נכשלה, המשתמש יקבל הודעת שגיאה ויישאר בדף ההתחברות לנסות שוב. לאחר 3 ניסיונות כושלים, אפשר לשקול נעילה לזמן קצר (אך אפשר גם לוותר בהתחשב שזה סביבה פנימית).
6.	כשמסיים עבודה, המשתמש ילחץ "התנתק" – מה שימחק את האסימון מהדפדפן ויחזיר אותו למסך התחברות.
רכיבי UI משותפים ועיצוב כללי
•	תפריט ניווט: המערכת תכלול תפריט (ניווט עליון או צדדי) לניווט בין המסכים: "קבלת ציוד", "ניהול פריטים", "היסטוריה", ו"כפתור התנתקות". התפריט יוצג בכל המסכים (פרט למסך התחברות) כדי לאפשר מעבר מהיר. ייתכן וכיתוב עם שם המשתמש הנוכחי יוצג ליד כפתור ההתנתקות ("מחובר בתור: bazapAdmin").
•	עיצוב וטכנולוגיה צד לקוח: נשתמש ב-React עם ספריית רכיבים (ייתכן שימוש ב-Bootstrap או Material-UI עבור כפתורים, טבלאות וטפסים סטנדרטיים). העיצוב יהיה מינימליסטי אך ברור: רקעים בהירים, טקסט כהה, שדות בולטים. תמיכה מלאה בעברית (יישור לימין, פונטים קריאים). לדוגמה, תוויות (Labels) מעל שדות או בצידן, בהתאם לתבניות UI מקובלות ביישור לימין.
•	נגישות ושימושיות: יש לשים דגש שגודל הפונט והכפתורים יהיו מספקים לעבודה נוחה (לפעמים מחסנאי עובד בתנאי תאורה קשים או מהר – הכל צריך להיות ברור). כמו כן, המערכת תהיה ריספונסיבית במידת האפשר: אם ירצו להריץ על טאבלט בשטח – המסכים יסתדרו (React ו-Bootstrap בד"כ תומכים בכך). אבל בהתחשב שהשימוש העיקרי הוא בעמדת PC במחסן, זה לא דגש עליון.
•	הודעות אישור/שגיאה אחידות: בכל המערכת, נשתמש בקוד צבעים אחיד: הודעות הצלחה בירוק, שגיאה באדום, אזהרה בצהוב. הודעות יוצגו במקומות בולטים (למשל בחלק העליון של הטופס או כ-Popup קטן). לדוגמה, "פריט נוסף בהצלחה" יוצג לכמה שניות ונעלם.
•	שמירת מצב (State): אם משתמש מילא חלק מהטופס בקבלת ציוד וניווט בטעות לעמוד אחר, נשקול לשמור את המצב (כדי שהנתונים לא יאבדו). זה שיפור אפשרי אך לא חובה בגירסה ראשונה.
כללי מערכת והנחות יסוד
•	סביבה ופריסה: המערכת מתוכננת לפעול ברשת הפנימית של הגדוד/היחידה. ניתן להריץ את השרת על מחשב המחסן (Windows) ולהגדירו לשירות עצמי. אין צורך בחיבור אינטרנט חיצוני כדי לעבוד. ה-Frontend יכול לרוץ כדף דפדפן על אותה מכונה או מכונות ברשת המחסן.
•	מספר משתמשים ופעולות סימולטניות: הנחנו לרוב מחסנאי אחד עובד בזמן נתון. אם בכל זאת שניים ירצו לעבוד יחד, המערכת תומכת בכך (כל עוד מוגדרים שני משתמשים). SQLite מאפשר מספר קריאות/כתיבות בו-זמנית במידה נמוכה; עקב אופי העבודה (כמה שניות כל פעולה) לא צפוי קונפליקט גדול. אם יום אחד תהיה דרישה ליותר משתמשים פעילים במקביל, אפשר לשקול העברת המסד ל-SQL Server או Postgres ולהריץ את ה-Web API על שרת רשת.
•	גיבוי ושרידות: על משתמשי המערכת יהיה לגבות תקופתית את קובץ ה-SQLite (למשל מדי שבוע להעתיקו לכונן אחר) כדי למנוע אובדן נתונים במקרה קריסת מחשב. בנוסף, ניתן לשקול שהמערכת תשמור לוגים או תדפיס פיזית חלק מהמידע כגיבוי, אך כרגע לא נדרש.
•	אבטחת מידע: המערכת מכילה מידע רגיש (מה נמצא במלאי ומי קיבל מה – מידע לוגיסטי פנימי). תידרש סיסמה חזקה לכל משתמש, ואפשר לחייב החלפת סיסמה תקופתית (נהלי צה"ל לרוב דורשים שינוי סיסמה כל 3 חודשים – ניתן ליישם זאת בפיתוח מתקדם). התקשורת בדפדפן יכולה להיות ב-HTTP כי זה מקומי, אבל רצוי לשקול שימוש ב-HTTPS אם יהיה שרת נפרד, כדי למנוע יירוט נתונים ברשת הבסיס.
•	הנחות פשטות: המערכת אינה מנהלת מספר מחסנים או גדודים – היא מיועדת למחסן ספציפי (גדוד 388). אין צורך בריבוי-אתרים. כמו כן, לא מתבצע בתוכה ניהול של הזמנות רכש או מלאי מינימום/מקסימום (פרט להתרעות פשוטות אולי). אלו יכולות להישקל כהרחבות בעתיד.
•	שילוב עם Codex (AI) בפיתוח: צוות הפיתוח יעזר בכלי AI (כמו OpenAI Codex או GitHub Copilot) לייצור חלק מהקוד. לכן, תכנון המערכת והמסמך מנוסחים בצורה שיתאימו גם להנחיית כלי AI לבנות את הקוד באופן מודרך. יש התייחסות לכך בנספח (סעיף 12) עם Promptים ייעודיים לשלבים השונים.
האפיון הפונקציונלי הנ"ל מתווה באופן שלם את מסכי המערכת ואת האינטראקציות העיקריות. בהמשך נפרט את הדרישות בצורה של User Stories, את תכנית העבודה לשלבי הפיתוח, בחירות הטכנולוגיה, מבנה הנתונים, ה-API, בדיקות נדרשות, נתוני דוגמה, ולבסוף נספח promptים ל-Codex ליישום אוטומטי של חלק מהשלבים.
5. User Stories + Acceptance Criteria (אפיוני משתמש לפי Epics)
כדי להבטיח הבנה מלאה של דרישות המערכת, הדרישות הפונקציונליות יפורקו ל-User Stories – תרחישי שימוש מנקודת מבט המשתמש – כולל קריטריוני קבלה (Acceptance Criteria) שמגדירים מתי סטוריית משתמש נחשבת כממומשת בהצלחה. להלן קבוצות של User Stories לפי אפיקים (Epics) מרכזיים: קבלת ציוד, ניהול מלאי, היסטוריה ודיווח, ואבטחה/הרשאות.
Epic 1: תהליך קבלת ציוד (Equipment Receiving)
•	Story 1: כמחסנאי, אני רוצה להזין במהירות ובקלות את פרטי הציוד הנמסר לחייל במערכת, כדי שהמלאי יתעדכן מיד ויהיה תיעוד מדויק של ההוצאה.
Acceptance Criteria:
•	כאשר כל השדות הדרושים (שם מקבל, לפחות פריט אחד עם כמות) מוזנים כהלכה ולוחצים "שמירת קבלה", אז הקבלה נשמרת במערכת עם מזהה ייחודי, תאריך נוכחי, הפריטים והכמויות, והנתונים מתעדכנים במסד.
•	לאחר שמירת הקבלה, כמות המלאי של כל פריט באותה קבלה מופחתת בהתאם לכמות שנמסרה. לדוגמה, אם נמסרו 2 יחידות פריט X והמלאי הקודם היה 10, לאחר השמירה יהיה 8.
•	לאחר הצלחה, מופיעה למשתמש הודעת אישור, והטופס מתאפס לשימוש חוזר. הקבלה החדשה ניתנת לצפייה במסך ההיסטוריה.
•	אם המשתמש מנסה לשמור כאשר חסר שדה חובה, למשל לא הזין שם מקבל או לא הוסיף פריטים, אז הפעולה תיחסם – תוצג הודעת שגיאה מתאימה ולא תיווצר קבלה.
•	אם הוזנו נתונים לא תקינים (כגון כמות = 0 או ערך שלילי), המערכת לא תאפשר שמירה ותתריע למשתמש לתקן את הערך.
•	המערכת מאפשרת במסגרת קבלה אחת להכניס ריבוי פריטים (שורות מרובות) באופן חלק – ניתן להוסיף לפחות 10 פריטים שונים לפני סיום, והכל נשמר בקבלה אחת.
•	Story 2: כמחסנאי, אני רוצה להימנע מרישום כפול או שגוי של פריטים בעת קבלת ציוד, כדי שהמידע יהיה נקי וללא כפילויות.
Acceptance Criteria:
•	בבחירת פריט להוספה, עלי לבחור מתוך רשימת פריטים קיימים ולא להקליד שם חופשי – המערכת מציגה רק פריטים תקפים שוגדרו, ובכך מונעת הקלדת שם פריט עם שגיאות כתיב או וריאציות שונות.
•	אם אנסה להוסיף פעמיים את אותו פריט ברשימת הפריטים של קבלה אחת, המערכת תאחד או תחסום את הכפילות. לדוגמה: אם כבר הוספתי "מטען למחשב" פעם אחת, ניסיון להוסיפו שנית יקפיץ הודעה "הפריט כבר קיים בקבלה" ולא ייצור שורה שנייה זהה (או שיגדיל את הכמות בשורה הקיימת – כל פתרון מונע כפילות ייחשב קביל).
•	כל קבלה נשמרת פעם אחת בלבד. אין מצב שהמערכת תשמור בטעות את אותה קבלה פעמיים. קריטריון: אם המשתמש לוחץ פעמיים על "שמור" מהר, המערכת תטפל בכך (למשל תחסום כפתור לאחר לחיצה ראשונה או תבדוק כפילות) כך שתיווצר רק רשומה אחת.
•	מספר הקבלה (ReceiptID) יהיה ייחודי ולא חוזר, גם אם היו מחיקות – זאת כדי למנוע בלבול בין רשומות.
•	Story 3 (אופציונלי לעתיד): כמחסנאי, אני רוצה להשתמש בסריקת ברקודים כדי להזין פריט וכמות, כדי לזרז עוד יותר את התהליך ולצמצם הקלדה ידנית.
Acceptance Criteria:
•	כאשר אני ממקד את הסמן בשדה הפריט וסורק באמצעות סורק ברקוד פריט קיים, המערכת מזהה את הקוד, בוחרת אוטומטית את הפריט התואם ברשימה, וממקמת את הסמן בשדה הכמות (או מגדילה ב-1 אוטומטית).
•	תומכי ברקוד: לכל פריט במערכת יש מאפיין קוד ייחודי שניתן להדפיס כברקוד ולהצמיד לפריט במחסן. סריקת ברקוד זה צריכה להתמפות לקוד הפריט במערכת.
•	אם נסרק קוד לא ידוע, תופיע הודעה המתריעה שהפריט לא קיים במערכת.
(ה-Story הזה אינו חובה למימוש הראשוני, אך מראה את כיוון ההתייעלות העתידי; קריטריונים אלו לא חייבים להיות ממומשים בגרסה הראשונה.)
Epic 2: ניהול פריטי מלאי (Item Management)
•	Story 1: כמנהל מערכת או מחסנאי אחראי, אני רוצה להוסיף פריטי ציוד חדשים למערכת, כדי לאפשר את הוצאתם במערכת כאשר ציוד חדש נכנס לשימוש.
Acceptance Criteria:
•	במסך "ניהול פריטים", כאשר אני ממלא שם פריט חדש ושומר, הפריט החדש מופיע ברשימת הפריטים, עם מזהה (ID) שהוקצה אוטומטית, וקוד אם סופק.
•	הפריט החדש זמין מידית לבחירה במסך קבלת ציוד (ניתן לראותו ברשימת הפריטים שם).
•	לא ניתן להזין שם פריט ריק – זהו שדה חובה. ניסיון שמירה עם שם ריק יציג שגיאה ולא ייצור פריט.
•	אם הוזן קוד פריט שכבר קיים בפריט אחר, הפעולה תידחה עם הודעת שגיאה "קוד הפריט כבר בשימוש". (אותו כלל לגבי שם פריט, אם הוחלט ששמות חייבים ייחודיים).
•	בהוספת פריט, אם לא צוינה כמות התחלתית, ברירת המחדל תהיה 0 (או שהמערכת תחייב להזין, תלוי החלטה – נקבל 0 כברירת מחדל וניתן לעדכן אחר כך).
•	Story 2: כמחסנאי, אני רוצה לערוך את פרטי פריט קיים (שם, קוד או כמות), כדי לתקן טעויות או לשנות את מצב המלאי בהתאם למצב בפועל.
Acceptance Criteria:
•	במסך ניהול פריטים, לחיצה על עריכת פריט מציגה את הטופס עם פרטי הפריט הנוכחיים. ניתן לשנות את השדות (למשל לתקן איות בשם).
•	כאשר שומרים את העריכה, הפרטים המעודכנים נראים בטבלה, והשינוי משפיע בכל מקום רלוונטי (למשל, אם שיניתי את שם הפריט, כעת במסך קבלת ציוד יופיע השם החדש).
•	שינוי כמות במלאי: אם אני מגדיל או מפחית את הכמות במסגרת עריכה, השינוי משוקף מידית במלאי הזמין.
o	לדוגמה: פריט "סוללה 12V" היה 18 במלאי (אחרי חלוקות קודמות). הגיע משלוח חדש של 10 יח'. אני משנה את הכמות ל-28 ושומר. עכשיו בכל מקום (טבלת ניהול, אולי תצוגה במסך קבלה) רואים 28 כמות זמינה.
o	המערכת שומרת לוג שינוי (אולי רשומה ברמת back-end) שמסביר שהייתה הוספת 10 ידנית על ידי משתמש X בזמן Y, למעקב. (לא חובה לחשיפה בממשק, אבל כתנאי קבלה פנימי: פעולה זו לא תמחק היסטוריה אלא מתועדת).
•	לא ניתן לערוך מזהה של פריט (זהו שדה מערכת, לא יוצג לעריכה).
•	לא ניתן לשנות קוד פריט לקוד שכבר קיים בפריט אחר (כנ"ל כמו בהוספה).
•	אם פריט סומן כ"לא פעיל" (נניח בצ'קבוקס), הוא לא יופיע ברשימת הפריטים לבחירה בקבלת ציוד לאחר מכן.
•	ביצוע עריכה עם שדות לא תקינים (שם ריק, מספר שלילי בכמות וכו') ייעצר עם הודעת שגיאה ולא יישמר עד תיקון.
•	Story 3: כמנהל/מחסנאי, אני רוצה להסיר פריט שאינו רלוונטי עוד, כדי לשמור את רשימת הפריטים במערכת נקייה ועדכנית.
Acceptance Criteria:
•	במסך ניהול פריטים, לחיצה על כפתור מחיקה ליד פריט תביא לחלון אישור "האם למחוק פריט X?".
•	אם מאשרים, והפריט מעולם לא חולק (אין אף קבלה שכוללת אותו), המערכת תמחק את הפריט לחלוטין ממסד הנתונים. הוא ייעלם מהטבלה ומהאפשרויות בכל מקום.
•	אם לפריט יש היסטוריית קבלות (זוהה ע"י בדיקה אם קיים ReceiptLine מקושר אליו), המערכת לא תמחק. במקום, יוצג מסר: "לא ניתן למחוק פריט שקיימות עבורו קבלות. ניתן לסמן אותו כלא פעיל." והפריט יישאר.
•	פריט שסומן כלא פעיל יתנהג כאילו הוסר מבחינת המשתמש הרגיל (לא יופיע למסירה), אך יישאר בטבלה (ניתן להציגו אולי באפור או תחת סינון "כולל לא פעילים").
•	ניסיון מחיקה של פריט לא פעיל עם היסטוריה ינהג כנ"ל (לא מוחק כי יש היסטוריה). רק אם יבצעו מחיקה על פריט חדש בלי היסטוריה זה יתבצע.
Epic 3: היסטוריה ובקרת מלאי
•	Story 1: כמחסנאי או מפקד, אני רוצה לצפות ברשימת כל קבלות הציוד שהתבצעו, כדי לבצע מעקב ואימות של פעילות המחסן.
Acceptance Criteria:
•	במסך "היסטוריה", אני רואה טבלה של קבלות, כמפורט בסעיף האפיון. כברירת מחדל מוצגות הקבלות האחרונות (לפי סדר כרונולוגי יורד).
•	כל רשומה מציגה לפחות: תאריך, מקבל, ומידע סיכומי על הפריטים (למשל מספר פריטים או כמה שמות ראשונים).
•	אני יכול לגלול או לדפדף ולראות קבלות קודמות (אם הרבה). הטעינה של הנתונים מתרחשת ללא שגיאות, גם אם יש מאות רשומות.
•	לחיצה על רשומה נפתחת (מודאל או עמוד נפרד) שמציגה את כל פרטי הקבלה: רשימת הפריטים והשורות עם כמויות, בדיוק כפי שנרשמו, וכן פרטים נוספים כמו מי המשתמש שרשם, הערות אם היו.
•	במסך הפרטים יש כפתור סגירה כדי לחזור לרשימה.
•	המידע בהיסטוריה תואם בדיוק למה שנרשם בזמן אמת: כלומר, אם חולקו 2 סוללות לאותו חייל, בהיסטוריה יופיע "סוללה 12V x2" תחת אותה קבלה.
•	קריטריון חשוב: אין "קפיצות" או חוסרים ברצף מספרי הקבלות – לוודא שכל קבלה שנשמרה אכן מופיעה (ניתן לבדוק לפי מספרי הקבלה ההולכים ועולים).
•	Story 2: כמפקד/קצין לוגיסטיקה, אני רוצה לסנן ולחפש בהיסטוריה לפי קריטריונים, כדי למצוא מידע ספציפי (כמו מי קיבל פריט מסוים או מה חולק בתקופה מסוימת).
Acceptance Criteria:
•	אם אני מזין טווח תאריכים בסינון, המערכת מעדכנת את הרשימה ומציגה רק קבלות שנופלות בין התאריכים (כולל הקצוות). למשל, בחירה 1-31 בינואר 2026 תציג רק קבלות מתאריכים אלו.
•	אם אני מזין מחרוזת בשדה החיפוש (למשל שם חייל או שם פריט), המערכת מציגה רק קבלות שבהן המחרוזת מופיעה בשם המקבל או בשם אחד הפריטים.
•	הסינון מתבצע בצד השרת (כלומר API מאפשר שאילתות עם פרמטרים) או בצד לקוח לאחר שליפת כל המידע – בכל אופן התוצאה זהה.
•	ניתן לשלב סינונים: למשל, גם טווח תאריך וגם שם פריט.
•	מהירות הסינון: עבור עד כמה אלפי רשומות, התגובה מגיעה תוך כמה שניות לכל היותר.
•	אם אין תוצאות תואמות לסינון, מוצג "לא נמצאו רשומות" במקום הטבלה.
•	Story 3: כמנהל, אני רוצה להיות מסוגל לתקן רישום שגוי בהיסטוריה במקרה הצורך, כדי שמאגר הנתונים יהיה אמין וללא טעויות כפולות.
Acceptance Criteria:
•	(אפשרות ראשונה) המנהל יכול לבטל קבלה דרך מסך ההיסטוריה: בחלון פרטי קבלה קיים כפתור "בטל קבלה". לחיצה עליו תדרוש אישור.
•	אם אושר, המערכת תסמן את הקבלה כמבוטלת (Cancelled) – ייתכן ע"י שדה מצב במסד. קבלה מבוטלת עדיין תוצג ברשימה אבל מסומנת (לדוגמה עם קו חוצה או צבע אחר, או עמודת מצב="מבוטלת").
•	בעת ביטול, המערכת תעדכן את המלאי: תוסיף בחזרה את כמויות הפריטים שהיו בקבלה (כלומר כאילו הקבלה לא קרתה).
•	קבלה מבוטלת לא תיספר בדוחות סיכום (אם יעשו) ולא תופיע כברירת מחדל אלא רק אם מבקשים לראות גם מבוטלות.
•	(אפשרות שנייה) לחלופין, אם בוחרים שלא לאפשר ביטול: אז קריטריון הוא שלא תתבצע מחיקה כלל דרך הממשק. תיקון שגיאות ייעשה ע"י הוספת קבלות הפוכות או עריכת המלאי ידנית. במקרה זה, Story זה לא נדרש למימוש.
•	אם יש מנגנון ביטול, הוא יהיה מוגבל למשתמש בעל תפקיד מנהל בלבד. משתמש רגיל לא יראה כפתור זה.
•	Story 4: כמחסנאי, אני רוצה לזהות כאשר פריט במלאי מגיע לכמות נמוכה, כדי שאוכל ליזום מילוי מחדש או דיווח לפני שנגמר. (תכונת "התראה" קשורה לבקרת מלאי, נזכיר כ-story יתכן עתידי)
Acceptance Criteria:
•	עבור כל פריט ניתן להגדיר "סף מינימום" (min level). אם לא הוגדר, ברירת מחדל 0 (אין התראה).
•	בכל פעם שמבצעים קבלה (הוצאה) וכתוצאה ממנה כמות הפריט יורדת אל מתחת לסף, המערכת תציג התראה למחסנאי: למשל "התראה: נותרו רק 2 יח' ממכשיר קשר RF-7800 במלאי!".
•	התראות יצטברו גם במקום מרכזי (אולי סימן אזהרה ליד אותו פריט ברשימת הפריטים).
•	קריטריון הצלחה: אם היה 5 במלאי, סף מינ' 5, ומסרתי 1 – עם שמירת הקבלה תופיע התראה על אותו פריט (4 נותרו שזה מתחת לסף).
(גם Story 4 כאן הוא שדרוג אפשרי, לא בהכרח דרישה מיידית, אך מציין חשיבה "חכמה" של המערכת.)
Epic 4: אבטחה והרשאות (Authentication & Authorization)
•	Story 1: כמשתמש מערכת (מחסנאי או מנהל), אני רוצה להתחבר באמצעות שם משתמש וסיסמה, כדי לוודא שרק לי יש גישה לפונקציונליות ואני רואה רק את מה שמורשה לי.
Acceptance Criteria:
•	כאשר אני מזין אישורי התחברות נכונים (שם משתמש וסיסמה תקינים) ולוחץ "התחבר", המערכת מאמתת אותי ומעבירה אותי למסך הראשי.
•	לאחר ההתחברות, כל בקשותיי למידע (לדוגמה, ניסיון לגשת למסך היסטוריה או להוציא ציוד) מתקבלות על ידי השרת – איני מתבקש שוב להזדהות, כי יש Session פעיל.
•	אם אני מזין סיסמה שגויה, ההתחברות נכשלת: אני נשאר בדף ההתחברות ורואה הודעת שגיאה. הסיסמה לא נחשפת (הקלט סיסמה מוצג בכוכביות).
•	עד שלא התחברתי בהצלחה, איני יכול להגיע לשאר המסכים. ניסיון לנווט באופן ישיר (למשל הזנת URL של מסך ניהול פריטים) ינתב אותי חזרה לדף login.
•	אבטחת סיסמה: במסד הנתונים, סיסמת המשתמש שמורה כערך מוצפן/מגוּבה (Hash+Salt). קריטריון זה נבדק על ידי עיון במסד נתונים: הערכים אינם קריאים כסיסמאות המקור.
•	תקשורת: קריאות ה-API של התחברות מעבירות את הסיסמה בצורה מאובטחת (אם ב-HTTP פנימי, לפחות לא חושפים מעבר למה שצריך; אם היה HTTPS אז מוצפן ברשת).
•	מנגנון נעילה: לאחר 5 ניסיונות כושלים ברצף עבור אותו משתמש, החשבון ננעל ל-5 דקות (ניתן לכוונן). קריטריון: ניסיון שישי תוך פרק הנעילה יידחה אוטומטית. (לא חובה למימוש מיידי, אך רצוי)
•	Story 2: כמנהל מערכת, אני רוצה שיכולת ניהול הפריטים והמערכת תהיה מוגבלת למנהלים בלבד, כדי למנוע משמשים זוטרים לשנות הגדרות.
Acceptance Criteria:
•	משתמש בעל תפקיד "Admin" יכול לגשת לכל המסכים, כולל "ניהול פריטים" וייתכן "ניהול משתמשים" אם קיים.
•	משתמש בעל תפקיד "User" (מחסנאי רגיל) יכול לבצע קבלות ולהציג היסטוריה, אך ייתכן שאין לו גישה למסך ניהול הפריטים (ניתן למנוע זאת בהגדרות ההרשאה).
o	מבחן: אם אני מחובר כמשתמש רגיל, ניסיון לנווט ל"דף ניהול פריטים" לא יוצג (או יופיע הודעה "אין לך הרשאה" אם הוזן URL ישירות).
•	פעולות מסוימות כמו מחיקת פריט או ביטול קבלה (מהסיפורים לעיל) יהיו זמינות רק למנהל.
•	במסד הנתונים קיים שדה Role לכל משתמש, והשרת מוודא את התפקיד לפני ביצוע פעולות רגישות.
•	ממשק המשתמש יכול להסתיר/לא לאפשר לחצן שלא רלוונטי. לדוגמה, למחסנאי פשוט לא יופיע כפתור "מחק" בטבלת פריטים, או שהלחצן לחיץ אך השרת יחסום.
•	ניתן לאמת זאת על ידי יצירת שני משתמשים (admin ו-user), כניסה כ-user ובדיקה שאי אפשר לבצע שינויי ניהול.
•	Story 3: כמשתמש, אני רוצה להתנתק מהמערכת בסיום העבודה, כדי לוודא שאחרים לא ישתמשו בהרשאות שלי במקרה שיישאר דף פתוח.
Acceptance Criteria:
•	לחיצה על כפתור "התנתק" (Logout) תסיים את ה-Session שלי: הלקוח ישכח את האסימון/סשן והשרת יבטל כל אסימון רלוונטי (אם JWT אולי לא ניתן לבטל בשרת, אבל אפשר להסתמך על תפוגה).
•	לאחר התנתקות, המשתמש מוחזר למסך ההתחברות.
•	ניסיון לבצע פעולה מייד אחרי התנתקות (למשל לחזור לעמוד הקודם בדפדפן) יביא למסך login, כי אין כבר הרשאה שמורה.
•	אם משתמש לא פעיל לפרק זמן (למשל 30 דקות) – הקריטריון הוא שהמערכת תדרוש התחברות מחדש אוטומטית. (אפשר לבדוק זאת ע"י השארת הדף ללא פעילות וראייה שנדרש login).
•	כל משתמש (כולל admin) יכול להתנתק; אין מושג של "משתמש נשאר תמיד מחובר ללא אפשרות לצאת".
•	Story 4 (ניהול משתמשים - עתידי): כמנהל, אני רוצה להוסיף/למחוק משתמשי מערכת חדשים (מחסנאים), כדי להתאים את המערכת לשינויים בכוח האדם.
Acceptance Criteria:
•	הוספת משתמש: כניסה למסך (שאינו קיים עדיין בגירסה הראשונה, אבל ייתכן כתוספת) "ניהול משתמשים", הוספת שם משתמש, סיסמה, ותפקיד, ושמירה – המשתמש החדש יוכל להתחבר מיד.
•	מחיקת משתמש: מחיקה תתאפשר רק אם המשתמש לא רשם קבלות בעבר (אחרת אולי סימון כלא פעיל).
•	איפוס סיסמה: המנהל יכול לשנות סיסמה למשתמש (למשל אם שכח).
•	כללים: לא ניתן שני משתמשים עם אותו שם, סיסמה חייבת לעמוד במדיניות (אורך מינימלי).
(שוב, Story 4 לא ימומש בהתחלה כי לפי הדרישות לא בטוח שצריך UI לזה; אפשר לנהל משתמשים ברמת DB. אבל הוא נרשם ככלי תכנון להמשך.)
סיכום אפיקי ה-User Stories: הדרישות מגדירות חוויית משתמש שבה המחסנאי מסוגל לבצע את משימותיו היומיומיות (הוצאת ציוד) מהר יותר ובאמינות גבוהה, המנהל שולט במלאי ומוודא שכל שינוי מתועד, ומבחינה טכנית–ארגונית, המידע מאובטח ומנוהל בתורה מקצועית. כל Story המפורט למעלה מציין את התנאים בהם נשיג את שביעות רצון ה"לקוח" (המשתמש) מהמערכת.
6. תכנית עבודה מדורגת לצוות הפיתוח
להלן שלבי הפיתוח המומלצים ליישום הפרויקט, בסדר כרונולוגי. חלוקה זו תאפשר התקדמות הדרגתית תוך הבטחת שלמות הפתרון בכל שלב לפני המעבר לשלב הבא. כל שלב מניב תוצרים שניתן לבדוק לפני המשך הפיתוח.
שלב 0: הכנות והגדרת סביבה
- התקנת כלים: ודא שלצוות יש את כל הכלים הנחוצים: Visual Studio 2022 (או גרסה עדכנית) עבור פיתוח backend, Node.js וסביבת Vite עבור front-end, ודפדפנים עדכניים לבדיקה. התקן גם את חבילות ה-NuGet וה-NPM הצפויות (ASP.NET Core, EF Core, React וכו').
- Git/ניהול גרסאות: הקם ריפוזיטורי Git חדש עבור הפרויקט "Bazap2.0". הגדר מבנה סניפים אם נדרש (main/develop וכו').
- איסוף דרישות סופי: לעבור שוב על מסמך אפיון (נוכחי) עם בעלי העניין (מחסנאי, מפקד) כדי לוודא שלא פספסנו דבר, לפני התחלת הקוד.
- אפיון טכני מפורט: ליצור טבלאות ERD ותרשימי זרימה אם נדרש (ניתן גם לדלג אם המסמך מספיק ברור לצוות).
שלב 1: יצירת פרויקט וסביבת פיתוח
- Backend: בעזרת Visual Studio, צור סולושן בשם BazapSolution. בתוך הסולושן, צור פרויקט ASP.NET Core Web API בשם Bazap.Api. בחר ב-ASP.NET Core (גרסה 7 או 8) עם Template ריק (אנחנו נוסיף בעצמנו). ודא שהפרויקט בנוי על NET6/NET7/NET8 לפי ה-LTS הקיימת (NET 8 LTS נכון ל-2024/5). הרץ את הפרויקט לוודא שהוא מקונפג ורץ (תקבל API דיפולטי אולי עם מזג אוויר – אפשר למחוק בקרת דמו).
- Frontend: התקן באמצעות Node את create-vite@latest. צאץ את פרויקט Vite: בספריית הסולושן צור תיקייה Bazap.Client והרץ npm create vite@latest עם שם הפרויקט, בחר framework: React, variant: TypeScript. זה ייצור שלד של אפליקציית React. ודא שניתן להריץ npm install ואז npm run dev ולראות את אפליקציית ההאלו וורלד.
- Integrating: למרות שה-Frontend וה-Backend נפרדים, נסה להריץ את שניהם במקביל (Web API כנראה ירוץ על https://localhost:5001, ו-React על https://localhost:5173). אפשר כבר כאן לטפל ב-CORS: בקובץ Startup/Program של ה-API, הוסף מדיניות CORS שמתירה ל-Origin של 5173 לפנות (AllowAnyOrigin ב-development).
- הכן גם פרויקט בדיקות (Unit Tests) אם רוצים TDD, אבל אפשר גם להוסיף בהמשך.
שלב 2: הגדרת המודל ומסד הנתונים (EF Core)
- הוסף לפרויקט Bazap.Api את חבילת NuGet של EntityFrameworkCore SQLite (לדוגמה: Microsoft.EntityFrameworkCore.Sqlite) וגם Microsoft.EntityFrameworkCore.Tools עבור Migrations.
- צור תיקייה Models או Entities ב-Backend, וצור מחלקות C# עבור היישויות: Item, Receipt, ReceiptLine, User (לפי ההגדרות בסעיף 8 למטה). ודא שהגדרת יחסי גומלין: למשל ב-ReceiptLine יש prop ל-Item ו-Receipt ו-Keys זרים.
- צור את הקונטקסט (BazapContext : DbContext) עם DbSet לכל Entity. הגדר ב-OnModelCreating את המפתחות ויחסים מורכבים אם צריך (למשל Composite key אם בחרנו, Cascade delete מ-Receipt->ReceiptLines, No cascade מ-Item->ReceiptLines).
- בקובץ appsettings.json של ה-API, קבע connection string עבור SQLite, למשל: "ConnectionStrings": { "BazapDatabase": "Data Source=bazap.db;" }.
- ב-Program.cs, הוסף את הקונטקסט לשירותים: builder.Services.AddDbContext<BazapContext>(options => options.UseSqlite(builder.Configuration.GetConnectionString("BazapDatabase")));.
- מיגרציה ראשונית: הרץ פקודת EF (דרך Package Manager Console או CLI) Add-Migration InitialCreate ואז Update-Database. וודא שנוצר קובץ bazap.db בפרויקט (אולי צריך לציין Path). אם המיגרציה נכשלה, תקן מודל. אם הצליחה, אפשר גם לפתוח את DB עם DB Browser לוודא שיש טבלאות נכונות.
- Seed Data בסיסי: אפשר כבר עכשיו, לאחר המודל, להגדיר Seed התחלתי: ניתן להשתמש ב-OnModelCreating (HasData) כדי להזין נתונים, או לחילופין לכתוב סקריפט קטן שמכניס עם הקונטקסט (בזמן Startup). ניתן לדחות seed לשלב 7 או 11 לפי הצורך; בשלב 2 מספיק לוודא שהכל עובד.
שלב 3: מימוש בסיסי של API (Controllers & Endpoints)
- התחל עם יישות אחת פשוטה: למשל Items. צור תיקייה Controllers ב-API, והוסף ItemsController. השתמש ב-Template Web API Controller עם פעולות CRUD. ודא שמסלול הבסיס [Route("api/[controller]")].
- מימוש פעולות ב-ItemsController: - GET /items – מחזיר את כל הפריטים (Use context.Items.Include?) בשלב זה אין relations מורכבות.
- GET /items/{id} – פריט בודד (כולל מלאי). החזר 404 אם לא קיים.
- POST /items – מקבל Item DTO (או הישר entity) ומוסיף DB. בצע בדיקה שאין כפילות (לדוגמה אם code unique, בדוק). החזר 201 עם item id.
- PUT /items/{id} – עדכון. בדוק קיום, עדכן שדות (פרט ל-ID שלא משתנה). עבור שינוי Quantity, שקול אולי Logic: לשמור delta? אבל פשט: נניח שמכניסים ערך חדש ומחליפים.
- DELETE /items/{id} – בדוק האם ניתן (האם יש ReceiptLines עם itemId זה). אם כן, החזר 400 עם הודעה "cannot delete". אם אין, מחק והחזר 204.
- בדוק את ה-Items API עם כלי כגון Postman או VS swagger (הרץ את ה-API וגש ל/swagger). ודא שכל פעולה עובדת.
- הוסף Controllers עבור Receipt ו-Auth: - ReceiptsController: - GET /receipts – שליפת רשימת קבלות. מומלץ לכלול גם את השורות (Include ReceiptLines ואז Include Item בתוך כל line כדי שיהיה שם פריט). לחלופין אפשר להחזיר DTO עם מבנה נוח (Receipt עם List of lines).
- GET /receipts/{id} – שליפה פרטנית עם פירוט מלא.
- POST /receipts – קבלת ReceiptDTO עם ReceiverName, אולי UserId (ניקח מה-auth token בפועל), ורשימת lines (ItemId+Quantity). המימוש: - צור אובייקט Receipt, חבר לו ReceiptLines מתוך ה-DTO. - לפני שמירה: עבור כל ReceiptLine, בדוק שיש מספיק מלאי מה-Item (Item.QuantityInStock >= req.Quantity). אם לא, אפשר להחליט: או שמאפשרים (המלאי יהיה שלילי, פחות טוב), או שחוסמים (Return 400 "אין מספיק במלאי"). לבחירתנו. - הפחת את הכמות מהמלאי: עבור כל ReceiptLine, עשה item.QuantityInStock -= quantity. - שמור את ה-Receipt (הקונטקסט ישמור גם את ה-lines בגלל relationship). - החזר 201 Created עם מיקום /receipts/{newId}. - אפשר לאפשר delete /receipts/{id} אם רוצים (לביטול), שימצא את הרשומה, יוסיף בחזרה למלאי את הכמויות, יסמן כבטל (אולי שדה IsCancelled true במקום למחוק לגמרי). אבל בגרסה בסיסית אפשר להשמיט delete כדי לא לבלבל.
- אופציות לסינון: ניתן להוסיף GET /receipts?fromDate=&toDate= וכו', או להוסיף endpoints נפרדים. אפשר לדחות ליותר מאוחר.
- AuthController: - POST /auth/login – מקבל JSON עם Username, Password. - מחפש במסד הנתונים את ה-User עם username הנתון. - אם לא קיים או סיסמה לא מתאימה (Hash verify), החזר 401 Unauthorized. - אם מתאים, צור JWT token (דורש להגדיר ב-Startup הוספת Authentication JWT, עם signing key וכו'. אפשר לממש זאת). - החזר token ללקוח. - אופציונלי: POST /auth/logout – לא תמיד נהוג ב-JWT (כי Logout בצד לקוח). אפשר לוותר.
- (אם יש Manage Users) – יצור endpoints /users אבל לא נדרש כעת.
- UsersController (אופציונלי): אם רוצים, אפשר לאפשר admin להוסיף משתמש דרך API, אבל בשלב ראשון אולי ניצור משתמשים דרך Seed ולא API. - Test the API: שוב, השתמש ב-Postman/Swagger: - תריץ POST /items לכמה פריטים, ואז GET /items לבדוק. - תריץ POST /receipts עם פריטים לראות שזה מקטין המלאי. - תריץ login עם משתמש מ-seed לראות שמקבלים token. - נסה קריאות מוגנות (ייתכן סימון [Authorize] על controllers) בלי ועם טוקן. (צריך להגדיר JWT Bearer authentication ב-Program). - OAuth & Policies: הוסף [Authorize] מעל ItemsController, ReceiptsController (כי לא רוצים לאפשר ללא login). השאר AuthController ללא Authorize (כדי שיוכלו לקבל token). - בקובץ Program.cs הגדר: builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme).AddJwtBearer(...configs...) עם מפתח סימון. - הוסף app.UseAuthentication(); app.UseAuthorization();. - בבדיקה: נסה GET /items בלי טוקן – צריך 401. הכן טוקן באמצעות login, הוסף Authorization Header, נסה שוב – צריך לעבוד.
שלב 4: פיתוח צד לקוח – ממשק React
- מבנה פרויקט: פתח את Bazap.Client (ייתכן בנפרד עם VSCode). שם אתחיל לבנות את מבנה האפליקציה. אחליט אם להשתמש ב-React Router עבור ריבוי דפים (כן, נצטרך לפחות route ל/Login ואחד ל/App). התקן react-router-dom.
- קומפוננטת App: נגדיר את ה-Routes: - "/" או "/login" יצביע ל-LoginPage component. - "/receiving" -> ReceivingPage (קבלת ציוד). - "/items" -> ItemsPage (ניהול פריטים). - "/history" -> HistoryPage. - נוסיף גם route ל"" שמנתב ל-login או לדף 404 (לא חשוב כעת). - ניהול Authentication state: - נחליט אם להשתמש ב-Context או פשוט ב-localStorage. - אפשר ליצור Context AuthContext שמחזיק את המידע (user, token, וכו'), וספק (Provider) שעוטף את האפליקציה. - בקומפוננטת App בעת העלאה, נבדוק אם יש token תקין ב-localStorage -> נגדיר כ-"loggedIn". - ניצור רכיב <PrivateRoute> או נשתמש ב-feature של router v6 (נעשה check manual): למשל, אם user לא מחובר ונסה לגשת לנתיב מוגן, ננווט ל"/login". - עמוד התחברות (LoginPage): - טופס עם useState לשדות username, password, ו-handleSubmit שעושה preventDefault ואז קורא ל-API: POST /auth/login דרך fetch/axios. - אם הצליח, שומר את token (ב-auth context state + localStorage) ומנווט ל"/receiving". - אם נכשל, מציג שגיאה למשתמש ("שם משתמש או סיסמה לא נכונים"). - עיצוב: טופס מרכזי, כפתור. - עמוד קבלת ציוד (ReceivingPage): - כאן עיקר הלוגיקה. רכיבים פנימיים אפשר ליצור: למשל רכיב לפריט שנבחר (או פשוט הכל ב-Page). - State שנדרש: receiverName, selectedItemId, quantity, list of items in current receipt (array of {itemId, itemName, quantity}). - בנוסף, state של items master list (כל הפריטים מהמלאי) כדי למלא את dropdown. - On mount, נקרא ל-API GET /items כדי לקבל רשימת פריטים ומלאי. נשמור ב-state. - Dropdown: options from items state (value = itemId, text = name אולי עם code). - "Add" button handler: - Validate selectedItem & quantity >0. - Check if item already in list (if yes, optional: increment quantity on that entry; simpler: prevent duplicate and alert). - If ok, push to list state (with item name from items state to display). - Reset selected item field. - Render items table: iterate over list state. Show name, quantity. Add a remove button in each row that filters it out from list on click. - "Save Receipt" button handler: - Validate that receiverName not empty and list not empty. - Construct payload: { receiverName, lines: [ { itemId, quantity}, ... ] }. - Call API POST /receipts with token. - If success (201), show success message (could use a toast or just set a state "success: true" then conditionally render message). Also maybe capture returned new receipt id if needed (not necessarily needed to show). - Clear the form (receiverName = "", list = []). Optionally, refresh items list from server (to update stock numbers if we show them). In minimal, update the items state by subtracting from relevant items or do GET /items again to sync stock. Probably easier to do GET /items again. - If error (like 400 not enough stock), show error message ("לא מספיק במלאי", etc). - Possibly after saving, consider redirect to history or remain. Probably remain in form for next use. - UI nice-to-have: show available stock next to item name when selected? (e.g., after choosing item, show "זמין: X"). Could do by finding item in items state on selection and display quantity. - Also, maybe allow typeahead search in dropdown: could use a library or simple filter. But initial approach it's okay if it's just normal select with many options (not great if hundreds of items, but if dozens it's fine). If needed, implement an input text that filters the list below for selection. - עמוד ניהול פריטים (ItemsPage): - On mount, GET /items to get list. - Render a table of items with columns (Name, Code, Quantity, maybe Active) and actions. - Provide a button "Add Item" that toggles showing an add form (or navigate to /items/new route). For simplicity, maybe a modal for add: use a piece of state like showAddForm. - Add form fields: name, code, quantity. Handlers for changes. - On submit add: call API POST /items. If success, close form, refresh items list (call GET /items again or append local state if easier). - On edit: We can either inline editable fields in table or also have a modal when clicking edit icon. Simpler: modal/pop-up similar to add, but filled with selected item data. Possibly reuse the form component for add/edit. - On save edit: call API PUT /items/id. If success, refresh list (or update state for that item). - On delete: when clicking delete icon, confirm via window.confirm (simple), then call DELETE /items/id. If success (204), remove from state list. If fails (like 400 cannot delete), show alert message with reason. - UI: possibly highlight if item is inactive (maybe grey row or with text 'inactive'). But initial version might not fully implement active flag toggling from UI due to complexity; could skip inactive concept or include a simple toggle in edit form. - Also allow searching/filter items if list is long (optional). - עמוד היסטוריה (HistoryPage): - On mount, GET /receipts (or maybe an initial limited set). Could fetch all for simplicity if not huge. Or implement pagination via API (skip for now, we can handle client side). - Save receipts in state. Also keep an original array for resets after filtering. - Filtering controls state: fromDate, toDate, searchTerm, filterItem. Build UI accordingly (maybe use <input type=date> for date, text for search, select for item filter). - Provide filter button to apply filters: do the filtering in client (could do in server but to simplify initial, do client). Use JS to filter receipts state that meet conditions (date within range if given, includes term if given in either receiverName or any item name in the lines, if filterItem selected, check if that itemId present in lines). - Provide reset filter to show all again (basically set receipts state back to original or remove filters states). - Render table: columns for ID, date, receiver, summary. - For summary: maybe combine items in a string or show count like "X items". Possibly better to list names partly: For example if <=2 items then list them with quantity, if more then "and N more". But not required. We can simply display e.g. number of lines: "2 פריטים". - Provide a view details action: could be an expand row (less accessible, easier might be: clicking the row triggers modal with details). - Modal details: show receipt ID, date, receiver, user (if included), then table of lines (Item name, quantity). If there's a cancel option and user is admin, show "Cancel Receipt" button. - Cancel Receipt logic (if implemented): clicking will call maybe DELETE /receipts/id or a special endpoint /receipts/{id}/cancel. If success, update receipts state: mark that one as cancelled (could add a property in the object, or remove it if we prefer not showing cancelled by default). Possibly also fetch items to update stock or simply add stock back in state. For initial, can skip implementation. - If implemented, ensure only admin sees that button: perhaps the auth context has role info that we can use to conditionally show it. - Provide pagination if needed: if receipts > 50, either do manual pages or use some library. Initially, maybe just show all, trust that usage won't blow up. - UI: maybe color code cancelled receipts (if we do them) or add an "(מבוטל)" label. - תפריט וניווט משותף: - Create a component Navbar with links (a <nav> bar at top). Contains links: "קבלת ציוד", "ניהול פריטים", "היסטוריה", and "התנתקות". - Place Navbar in App above the <Outlet/> (so it shows on each protected page). Possibly hide it on login page (so in the Router config, wrap the protected routes in a layout that includes Navbar, exclude login route). - The logout link should onClick: clear token (auth context / localStorage), and navigate to "/login". Also possibly tell server to invalidate token if that was possible, but with JWT not easily; rely on expiry. - The Navbar can also show the username (auth context likely will store username from login, could decode from token or have gotten from login response maybe). - Styling: Use Bootstrap or Material UI to speed up styling: - If Bootstrap, install via npm and import CSS in main.tsx. Use classes like .container, .btn, .table for quick styling. - If Material UI, install packages and wrap App in ThemeProvider, etc, use their components (more heavy). - Could even do plain CSS, but libraries save time for layout. - For our case, maybe use simple Bootstrap for grids and forms. Alternatively, use the component library in MUI if comfortable. - Testing UI manually:* - Start the API and the React dev server. - Try logging in with wrong and right credentials. - After login, try adding an item, then issuing a receipt, etc. - Check if UI reflects changes (like stock decrement). - Try refresh page (should remain logged in if token stored – ensure App reads localStorage token on init and auto logs in). If not handling it, maybe do it. - Check navigation flows (go to history, back, etc). - Fix any obvious bugs. - At this point, we have a mostly working end-to-end skeleton.
