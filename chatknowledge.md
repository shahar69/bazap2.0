Bazap 2.0 – מסמך תיעוד ותכנון פיתוח מקיף
1. רקע מלא
תהליך קבלת הציוד כיום: יחידת התקשוב של גדוד 388 מפעילה מחסן ציוד טכני, שבו נרשם ציוד הניתן לחיילים בצורה ידנית או בקבצי אקסל. חייל המגיע לקבל ציוד ממלא טופס נייר או שהמחסנאי מקליד את פרטיו ואת פרטי הפריטים בתוכנה בסיסית. הנתונים נרשמים בספרים או בגליונות אלקטרוניים, ולאחר מכן ייתכן שמעתיקים אותם למחשב המרכזי. תהליך זה כרוך ברישום ידני של שם המקבל, תאריך, סוג הפריט וכמות, ולעיתים גם חתימת החייל על טופס קבלה פיזי. הרישום הידני נעשה תוך כדי חלוקת הציוד, מה שמאט את חלוקת הציוד בפועל.
הבעיות בתהליך הנוכחי: התהליך הידני גורם לאיטיות משמעותית – על המחסנאי לעצור ולכתוב/להקליד כל פרט במקום לבצע חלוקה מהירה. בנוסף, ריבוי רישומים מקבילים (לדוגמה גם בטופס וגם באקסל) מוביל לכפילויות וסיבוך בריכוז הנתונים. טעויות הקלדה הן שכיחות: שמות פריטים מוקלדים בשגיאות, מספרים נרשמים לא נכון, או פריטים עלולים להירשם פעמיים. חוסר אחידות ברישום (למשל כל מחסנאי כותב תיאור מעט שונה לפריט דומה) יוצר חוסר עקביות. כתוצאה, המלאי עלול להיות לא מדויק, וקשה לחפש היסטוריה – מציאת מי קיבל פריט מסוים דורשת חיפוש ידני בניירת או בקובץ. גם הפקת דו"חות או תמונת מצב של כמות הציוד הקיימת במלאי מורכבת וגוזלת זמן.
הקשר המבצעי של גדוד 388 והצורך: גדוד 388 פועל בגזרת צפון, ויחידת התקשוב שלו אמונה על זמינות ציוד קשר ומחשוב לכל פעילות מבצעית ואימונים. דיוק ומהירות בחלוקת ציוד הן קריטיות: בעת פעילות דחופה, כל עיכוב במחסן פוגע במוכנות הכוח. כמו כן, אם ציוד לא נרשם כהלכה, עלול להיווצר חוסר ציוד פתאומי בשטח (כי חשבו שיש במלאי אך בפועל חולק ולא תועד) – דבר המהווה סיכון מבצעי. יש צורך בפיקוח ובקרה על מי קיבל איזה ציוד ומתי, כדי שבסיום פעילות ניתן יהיה לוודא החזרת ציוד ולאתר ציוד חסר. בנוסף, לאור הדרישות במערך התקשוב, יש לציית לנהלי צה"ל לניהול ציוד טכני, דבר הכולל תיעוד מלא של כל העברות הציוד. המערכת המוצעת אמורה לתת מענה לצרכים אלו על ידי ייעול תהליך הקבלה וצמצום טעויות – מחקרים מראים שהטמעת מערכת ממוחשבת מובנית לתהליך קבלת סחורה מפחיתה טעויות בכ־80%[1], מה שיתרום משמעותית לדיוק המלאי ולמוכנות הגדוד.
2. מטרות המערכת
שיפור מהירות התהליך: המערכת הדיגיטלית תקצר את הזמן הנדרש לרישום קבלת ציוד. כל קבלה תוזן ישירות למערכת דרך ממשק מהיר, ללא צורך ברישום כפול. באופן זה החייל מקבל את הציוד מהר יותר, והמחסנאי לא מתעכב על ניירת תוך כדי החלוקה.
הפחתת כפילויות וטעויות: רישום במערכת מרכזית מונע כפילויות – כל אירוע קבלה מקבל מזהה יחיד, והנתונים מוזנים פעם אחת. המערכת תכלול ולידציות (בדיקות תקינות) למניעת טעויות הקלדה: בחירת פריטים מרשימה מוגדרת במקום הקלדה חופשית, בדיקת תקינות כמו כמות חיובית בלבד וכו'. כך יימנעו שגיאות אנוש ברישום שם פריט או כמות.
שיפור דיוק המלאי ואמינות המידע: כל תנועת ציוד (קבלה על ידי חייל) תתעדכן מיד במלאי. המערכת תעדכן אוטומטית את כמות הפריטים הזמינה לאחר כל קבלה, ובכך תספק תמונת מצב עדכנית של המלאי בכל רגע. עם מערכת כזו, סביר שהמלאי יהיה מדויק יותר ומסונכרן בין כל המשתמשים, כי אין פער בין מה שחולק בפועל למה שמתועד.
מעקב היסטורי ובקרה: המערכת תשמור היסטוריה מלאה של כל הקבלות. ניתן יהיה לחפש במהירות מי קיבל מה ומתי, ללא נבירה בניירת. הדבר מאפשר בקרה טובה יותר – המפקדים יכולים לצפות בדו"חות ולהבין את צריכת הציוד לאורך זמן, לזהות דפוסים (למשל פריט שמתבזבז מהר) ולהיערך בהתאם. במקרי ציוד חסר, היסטוריית החלוקה מסייעת להתחקות מי היה האחרון שקיבל אותו.
שליטה והרשאות: באמצעות דרישת התחברות (Login), רק אנשי המחסן/היחידה המורשים יוכלו לבצע פעולות במערכת. בכך נשמרת אבטחת המידע והציוד – חייל רגיל לא יוכל "לעצמו" להוציא פריט במערכת. בנוסף, מערכת ההרשאות תאפשר זיהוי מי ביצע כל פעולה (audit trail), מה שמגביר אחריותיות ומונע ניצול לרעה.
ייעול וקבלת החלטות: המערכת ה"חכמה" תוכל לספק נתונים לתחקור—לדוגמה, להתריע על פריט שתדירות הוצאתו גבוהה במיוחד (אולי סימן שרצוי להחזיק ממנו יותר במלאי) או להתריע על פריט שכמותו יורדת מתחת לרף שהוגדר. בכך, מעבר לפתרון הבעיות המיידיות, המערכת משיגה שיפור בניהול: זמני תגובה מהירים יותר, פחות תקלות אדמיניסטרטיביות, ויכולת תכנון טוב יותר של המלאי (מה שצריך לחדש, מה שפחות בשימוש). בסופו של דבר, המערכת תשפר את המוכנות המבצעית של הגדוד על ידי הבטחת זמינות ציוד מדויקת ומהירה.
3. תיאור הפתרון הכללי: WebApp מהירה וחכמה
 
המערכת המוצעת, "Bazap 2.0", היא יישום ווב (WebApp) מודרני לניהול קבלת ציוד באופן מהיר וחכם. מדובר במערכת מבוססת דפדפן שתפותח בכלים עדכניים – צד לקוח עשיר לתפעול נוח ומהיר, ושרת צד-שרת אמין לטיפול בלוגיקה ובנתונים. השימוש במערכת יהיה דרך מחשב או טאבלט במחסן (באמצעות רשת פנימית), כך שהמחסנאי יוכל לתפעל אותה בזמן חלוקת הציוד בשטח המחסן.
ארכיטקטורה כללית: הפתרון יופרד לשני חלקים עיקריים – לקוח (Frontend) ושרת (Backend). צד הלקוח יהיה אפליקציית React מהירה (עם מנוע פיתוח Vite) הכתובה ב-TypeScript, שתספק ממשק משתמש (UI) אינטראקטיבי בשפה העברית. צד השרת יהיה שירות ASP.NET Core Web API שירוץ על שרת מקומי (או מחשב המחסן) וישמש כ"שכבת העסק" והגישה למסד הנתונים. מסד הנתונים יהיה קובץ SQLite מקומי, שיאפשר שמירת נתוני המלאי והקבלות בצורה רלציונית ובטוחה. הלקוח יתקשר עם השרת באמצעות קריאות HTTP (פורמט JSON), כך שבכל פעם שמחסנאי מזין קבלה חדשה או מבקש מידע – תישלח בקשה ל-API, והשרת יעבד את הלוגיקה (למשל עדכון מלאי) ויחזיר תשובה מתאימה.
מאפייני "מהירות" ו"חוכמה": המערכת תוכננה להיות מהירה – הן בביצועים והן בשימושיות. מבחינת ביצועים: הטכנולוגיות הנבחרות (React+Vite, ASP.NET Core, SQLite) ידועות ביעילותן; טעינת הדפים תהיה מיידית כמעט, ופעולות כמו שמירת קבלה יעשו בשבריר שנייה. בנוסף, UI אינטראקטיבי ימנע רענון דף מלא – רק הנתונים משתנים דינמית, מה שחוסך זמן. מבחינת שימושיות: הממשק ייבנה כך שידרוש מינימום הקלדה חופשית – בחירת פריטים מתוך רשימה מוגדרת, אפשרות לסרוק ברקוד של פריט (בעתיד) וכד'. המערכת תכלול השלמה אוטומטית בעת חיפוש פריט, ותיתן משוב מיידי על שדות לא תקינים. "חכמה" מתבטאת גם ביכולתה למנוע טעויות (למשל אזהרה אם מנסים להוציא פריט שכבר אין ממנו במלאי) ואולי אפילו להציע כמויות תקניות (לדוגמה, אם פריט מסוים בדרך כלל מחולק בזוגות – המערכת תוכל להתריע אם מוזן מספר אי-זוגי). המערכת תומכת בריבוי משתמשים מורשים, ואם בעתיד ירצו לעבוד ביותר מעמדת מחשב אחת – ניתן להרחיב את הפתרון להתחברות ממספר עמדות (SQLite יכול לתמוך במספר חיבורים לקריאה/כתיבה, או שניתן יהיה לשדרג למסד נתונים שרתיב לפי הצורך).
תמצית זרימת העבודה במערכת: מחסנאי יתחבר למערכת עם שם משתמש וסיסמה. הוא ייגש למסך "קבלת ציוד", יבחר חייל מקבל (לדוגמה הזנת שמו/מספר אישי) ויציין אילו פריטים וכמה מכל סוג ניתנים. המערכת תרכז את הפריטים לקבלה הנוכחית, ותאפשר בלחיצת כפתור לסיים ולשמור את הקבלה. בשמירה, השרת ירשום את כל פרטי הקבלה, יעדכן את כמויות המלאי של אותם פריטים, ויחזיר אישור. הנתונים יישמרו במסד הנתונים מיד, ויהיו זמינים לצפייה במסך היסטוריה. המערכת בנויה כך שברגע נתון רק פעולה אחת נחוצה מהמשתמש (לדוגמה: לבחור פריט מרשימה במקום להקליד קוד ידנית, מה שחוסך זמן).
דגש על אמינות ופשטות: בהינתן שמדובר בצוות שאינו צוות תוכנה, המערכת תוכננה פשוטה לתפעול ולתחזוקה. התקנת המערכת קלה (הפעלה של קובץ התקנה או פריסה דרך Visual Studio), ללא תלות בתשתיות מורכבות. מסד SQLite מאפשר עבודה גם ללא חיבור רשת מלא – כל עוד המחשב המקומי פועל, המערכת זמינה. בנוסף, כל הנתונים מגובים בקובץ יחיד שניתן לגבותו מעת לעת. במידת הצורך, ניתן יהיה להתקין את המערכת גם על מחשב נוסף לצורכי גיבוי או עבודה במקביל (אך אז רצוי מסד מרכזי – שדרוג אפשרי עתידי).
לסיכום, הפתרון הכללי הוא מערכת ניהול קבלה ממוחשבת המאפשרת למחסנאי לבצע את עבודתו במהירות ובדייקנות, תוך ביטול מרבית הבעיות של התהליך הנוכחי. שילוב הטכנולוגיות העדכניות והאינטגרציה ביניהן ב-Bazap 2.0 יאפשר ליחידה לקפוץ דור טכנולוגי קדימה בניהול הציוד.
4. אפיון פונקציונלי מלא
המערכת תסופק כיישום Web עם מספר מסכים עיקריים התואמים לתהליכים ולאובייקטים המרכזיים: מסך קבלת ציוד, מסך ניהול פריטים, מסך היסטוריה, ומסך התחברות. בהמשך מתואר כל מסך, רכיבי ה-UI שבו, וזרימת העבודה המצופה (Happy Path) בכל אחד. כמו כן מפורטים כללי המערכת והנחות היסוד החשובות.
מסך קבלת ציוד (הוצאת ציוד למחזיק)
תיאור כללי: זהו המסך המרכזי שבו המחסנאי מתעד אירוע של מסירת ציוד לחייל (קבלת הציוד מבחינת החייל). המסך מאפשר יצירת "קבלה" חדשה של מספר פריטים בכמות מסוימת, המשויכת למקבל אחד ובתאריך נוכחי.
רכיבי UI במסך קבלת ציוד:
•	כותרת ודף חדש: כותרת בראש העמוד: "קבלת ציוד". מתחתיה יוצג טופס להזנת פרטי הקבלה החדשה.
•	שדה מקבל הציוד: שדה להזנת פרטי החייל שמקבל את הציוד. זה יכול להיות שדה טקסט לכתיבת שם החייל או מספרו האישי. אפשרות לשדה אוטומטי עם השלמה (אם קיימת אינטגרציה לרשימת חיילים, אך במימוש הראשוני נסתפק בהקלדה חופשית כדי לא לסבך). השדה יהיה חובה למילוי.
•	הוספת פריטים לקבלה: חלק מרכזי בטופס המאפשר לציין אילו פריטים נמסרים וכמה. רכיבים:
•	שדה בחירת פריט: רשימה נפתחת (ComboBox) של כל הפריטים הקיימים במלאי/במערכת. המשתמש יבחר את שם הפריט מהרשימה (ניתן גם להתחיל להקליד לחיפוש מהיר ברשימה).
•	שדה כמות: שדה מסוג Number להזנת כמות הפריט שנמסרת. כברירת מחדל 1, וניתן להגדיל. תתבצע ולידציה שהמספר חיובי ושלם.
•	כפתור "הוסף פריט": לחצן שלחיצה עליו תוסיף את הפריט והכמות שצוינו לרשימת הפריטים של הקבלה הנוכחית. אם אחד השדות ריקים או לא תקינים, תופיע הודעת שגיאה ולא תתבצע הוספה.
•	טבלת פריטים שנוספו: מתחת לשדות ההוספה, תוצג טבלה המציגה את כל הפריטים שנוספו לקבלה הנוכחית עד כה. עבור כל פריט יוצגו עמודות: קוד/מזהה פריט, שם הפריט, כמות. בנוסף, לכל שורה כפתור מחיקה (אייקון "אשפה") המאפשר להסיר פריט מרשימת הקבלה אם נעשתה טעות. הטבלה מתעדכנת דינמית בכל הוספה או מחיקה.
•	פעולות סיום: בחלק התחתון של הטופס:
•	כפתור "שמירת קבלה": בלחיצה עליו תתבצע סיום התהליך – המערכת תשמור את הקבלה במסד הנתונים, כולל כל פריטי הטבלה, תעדכן את המלאי, ותציג למשתמש אישור. כפתור זה יהיה פעיל רק אם יש לפחות פריט אחד בטבלה (כדי למנוע שמירת קבלה ריקה) ואם הוזן מקבל.
•	כפתור "נקה/בטל": אפשרות לאתחל את הטופס במידה והתחרטו או רוצים להתחיל מחדש (מאפס את שדה המקבל ואת טבלת הפריטים).
•	הודעות שגיאה והנחיות:
•	אם המשתמש לחץ "הוסף" ללא בחירת פריט או ללא כמות, יוצג ליד השדה החסר הודעת שגיאה ("יש לבחור פריט", "יש להזין כמות").
•	אם הכמות שהוזנה היא 0 או שלילית, תופיע שגיאה "כמות לא תקינה".
•	אם הכמות המבוקשת גבוהה מהכמות הזמינה במלאי לאותו פריט, המערכת יכולה (כתוספת חכמה) לתת אזהרה או למנוע, בהתאם למדיניות (בגרסה ראשונה, אפשר רק להתריע "אזהרה: כמות במלאי נמוכה", אך לא בהכרח לחסום – בהמשך אולי חסימה).
•	אם מנסים להוסיף את אותו פריט פעמיים, המערכת תמנע כפילות: ייתכן שתופיע הודעה "פריט זה כבר נוסף, ניתן לשנות את הכמות בשורה הקיימת" או שהמערכת בעצמה תאחד את השורות (למשל, אם הפריט X כבר בטבלה עם כמות 2, והמשתמש מוסיף שוב כמות 1, המערכת תגדיל את השורה לכמות 3 במקום ליצור שורה חדשה).
•	משוב לאחר שמירה: לאחר לחיצה על "שמירת קבלה" וביצוע תקין, יוצג מסר הצלחה – למשל הודעה "הקבלה נשמרה בהצלחה" בירוק. הטבלה והשדות יתאפסו כדי להיות מוכנים לקליטת קבלה חדשה מיד (שימושי כאשר כמה חיילים מגיעים ברצף). ייתכן שהמערכת גם תציע להדפיס אישור למסירה (לחתימת החייל), אך אפשרות זו בתעדוף משני וניתן להשאיר אותה כידנית אם נדרש.
זרימת עבודה (Happy Path) במסך קבלת ציוד:
1.	המחסנאי בוחר בתפריט את מסך "קבלת ציוד" (לאחר שכבר התחבר למערכת).
2.	הוא רואה טופס ריק. בשדה "מקבל" הוא מזין למשל: "טוראי יוסי כהן".
3.	בשדה בחירת פריט הוא בוחר "מכשיר קשר RF-7800" מתוך הרשימה, ובשדה כמות מזין "1". לוחץ "הוסף פריט" – השורה נוספת לטבלה.
4.	הוא ממשיך לבחור פריט נוסף: "בטרייה 12V", כמות "2". לוחץ הוסף – גם שורה זו מופיעה בטבלה.
5.	כעת הטבלה מציגה 2 שורות. המחסנאי בודק שהכל תקין, ולוחץ "שמירת קבלה".
6.	המערכת מציגה הודעת "נשמר בהצלחה". מאחורי הקלעים: רשומה חדשה של קבלה נוצרה במסד הנתונים, עם שני פריטי קבלה (שורות) המשויכים אליה; יתרת המלאי של מכשיר הקשר ירדה ב-1 ושל הבטריות ירדה ב-2.
7.	הטופס מתנקה לשימוש הבא. המחסנאי יכול כעת לתת לחייל את הפריטים ולסיים את הטיפול בו. אם מיד מגיע החייל הבא, ניתן להתחיל למלא קבלה חדשה ללא רענון דף.
כללים והנחות מיוחדות במסך זה:
•	פעולת השמירה לא תתאפשר אם אין פריטים בטבלה, או אם שדה המקבל ריק. זאת כדי להבטיח שכל קבלה מכילה את הנתונים החיוניים.
•	זמן ותאריך הקבלה ייקבעו אוטומטית בעת השמירה (timestamp של המערכת) – אין צורך ולא ניתן לערוך את התאריך ידנית (כדי למנוע טעויות תאריך).
•	קבלה שנסטרה (נשמרה) לא תהיה ניתנת לעריכה בדיעבד דרך מסך זה – תיקון טעויות ייעשה דרך מנגנון אחר (אולי מחיקת הקבלה ויצירה מחדש על ידי אדמין, ראו דיון בהמשך).
•	המסך מיועד בעיקר לתפקיד "מחסנאי" או כל משתמש שמורשה להוציא ציוד. משתמש שאינו מורשה לא יגיע למסך זה (הממשק ידאג לכך דרך הרשאות).
•	לגבי החזרת ציוד: בגירסה 2.0 זו, אין מסך נפרד ל"החזרת ציוד". הנחת עבודה היא שהחזרת ציוד, במידה ויש לתעדה, תעשה ע"י הוספת מלאי ידנית במסך ניהול פריטים או על ידי יצירת "קבלה שלילית" (לא ממומש כעת). בשלב ראשון, ניהול ההחזרות יתבצע מחוץ למערכת או ברישום ידני, והמיקוד כאן הוא הוצאה (קבלה ע"י החייל).
מסך ניהול פריטים
תיאור כללי: מסך זה מאפשר צפייה ועריכה של רשימת כל הפריטים המנוהלים במערכת. כאן מוגדרים הפריטים שאפשר להוציא. זה כולל הוספת פריט חדש (למשל אם מגיע ציוד חדש למחסן שטרם היה ברשימה), עדכון פריט (למשל שינוי שם או תיקון כמות במלאי), ואפשרות להסרת פריט (במידה והוא יצא משימוש). מסך זה חשוב כדי להבטיח שרשימת הפריטים במערכת משקפת את המציאות במחסן.
רכיבי UI במסך ניהול פריטים:
•	כותרת: "ניהול פריטים".
•	טבלת פריטים: טבלה המציגה את כל הפריטים הקיימים במערכת (מתוך טבלת ה-Item במסד הנתונים). עבור כל פריט עמודות כגון:
•	מק"ט/קוד פריט: מזהה ייחודי או קוד שהוגדר (יכול להיות מספר סידורי פנימי או קוד שהמחסנאי הגדיר).
•	שם הפריט: תיאור קצר, למשל "מכשיר קשר מוטורולה".
•	כמות במלאי: הכמות הנוכחית הזמינה (מחושבת על פי מה שהוזן כהתחלתי פחות כל מה שהוצא דרך קבלות). זהו שדה מידע – ייתכן שיהיה "קריאה בלבד" בטבלה (לא עריך ישירות כאן, אלא דרך פעולות).
•	סטטוס/הערה: אם פריט אינו פעיל יותר (למשל "חסר זמנית" או "יצא משימוש") זה יכול להיות מסומן. בעיצוב ראשוני ניתן להציג רק פריטים פעילים, או עם סימון עבור לא פעילים.
•	פעולות: בעמודה אחרונה לכל שורה – כפתורי פעולה: "עריכה" (אייקון עט) ו"מחיקה" (אייקון פח).
•	כפתור הוספת פריט חדש: מעל או מתחת לטבלה, כפתור בולט "הוספת פריט חדש". לחיצה עליו תאפשר הזנת פריט חדש.
•	טופס הוספה/עריכה: פעולה של הוספה או עריכה תפתח טופס (ייתכן כחלון קופץ modal או באזור ייעודי במסך) בו ניתן להזין/לעדכן את פרטי הפריט:
•	שדה "שם פריט" – טקסט, חובה.
•	שדה "קוד פריט" – טקסט, אופציונלי אך מומלץ (אם לא יוזן, אולי המערכת תיצור אוטומטית קוד מזהה מספרי).
•	שדה "כמות התחלתית" – מספר שלם, ניתן להזין את המלאי ההתחלתי כאשר מוסיפים פריט חדש (למשל אם קלטנו 5 יחידות מפריט חדש למחסן). בעריכה, ניתן להשתמש בשדה זה לעדכון כמות במקרים מיוחדים (למשל תוספת מלאי ממקור חיצוני או תיקון ספירת מלאי).
•	שדה "פעיל/לא פעיל" – צ'קבוקס לסימון האם הפריט זמין להוצאה. פריט לא פעיל לא יופיע במסך קבלת ציוד.
•	לחצני "שמירה" ו"בטל": לשמירת הפריט החדש/העדכון, או ביטול הפעולה.
•	אינטראקציות:
•	לחיצה על "הוספת פריט חדש": מציגה טופס ריק למילוי, המחסנאי ממלא פרטים ושומר.
•	לחיצה על "עריכה" ליד פריט בטבלה: מציגה את טופס הפריט עם ערכים נוכחיים הניתנים לעריכה (למשל לשנות את השם, או לתקן מלאי אם צריך).
•	לחיצה על "מחיקה" ליד פריט: המערכת תבקש אישור "האם אתה בטוח שברצונך למחוק?". אם יאושר, תנסה למחוק את הפריט.
•	כללים עסקיים בניהול פריטים:
•	בעת הוספת פריט, יש לוודא שלא קיים כבר פריט עם אותו שם או אותו קוד. אם מזוהה כפילות, תופיע שגיאה ("פריט בשם/קוד זה כבר קיים").
•	בעת עריכת פריט, בפרט אם משנים את הכמות במלאי ידנית: המערכת צריכה לוודא שהמשתמש מבין שזה עלול להשפיע על הנתונים (אולי התרעה "שינוי כמות עלול ליצור אי-התאמה עם היסטוריית קבלות"). למעשה, שינוי הכמות באופן ידני הוא תחליף לתיעוד החזרה או תוספת ציוד מחוץ למערכת.
•	מחיקת פריט תותר רק אם הפריט לא שויך לאף קבלה קיימת (כלומר לא נעשה בו שימוש עדיין). אם מנסים למחוק פריט שיש לו היסטוריה, המערכת תספק הודעה ולא תמחק בפועל ("לא ניתן למחוק פריט שכבר חולק, ניתן לסמן כלא פעיל במקום").
•	שינוי שם או סימון כלא פעיל לפריט עם היסטוריה יתאפשר (כדי לתקן או להפסיק שימוש), אבל לא ימחק את ההיסטוריה.
•	כמות המלאי של פריט מחושבת כך: כמות נוכחית = כמות אחרונה ידועה + כמות נוספה ידנית (בעריכה) - סך כל הכמויות שחולקו בקבלות. בפועל, ניתן לאחסן במסד גם שדה "QuantityInStock" שמתעדכן אוטומטית בכל יצירת קבלה, וכמו כן מתעדכן אם המשתמש שינה ידנית.
זרימת עבודה לדוגמה במסך ניהול פריטים:
•	הוספת פריט חדש: נניח הגיע סוג חדש של אוזניות קשר למחסן ויש להזינו. המחסנאי לוחץ "הוספת פריט חדש". הוא ממלא: שם = "אוזניות קשר XYZ", קוד = "HDR-02", כמות התחלתית = 10. לוחץ "שמירה". המערכת יוצרת רשומה חדשה של פריט עם מזהה חדש, ומעדכנת את הטבלה. כעת "אוזניות קשר XYZ" מופיע ברשימת הפריטים, וכמו כן יהיה זמין לבחירה במסך קבלת ציוד.
•	עריכת פריט (עדכון מלאי): למשל, בוצעה ספירת מלאי והתברר שבפועל יש 30 כבלים במקום 25. המחסנאי מוצא בטבלה את "כבל רשת 5m", לוחץ עריכה. בשדה כמות הוא מעדכן מ-25 ל-30. לוחץ "שמירה". המערכת מחשבת את ההפרש (5 נוספו) ויכולה ברקע לעדכן רישום שהיו 5 כבלים שנוספו בלי קבלה (אולי כ"ייבוא למלאי"). לאחר השמירה, הטבלה מראה כמות 30. כעת אם ייגשו למסך קבלת ציוד, אותה כבל רשת תוצג עם מלאי 30 זמין.
•	מחיקת פריט: נניח פריט נסוג משימוש (למשל דגם מחשב ישן שלא מחלקים יותר). אם לא חולק מעולם (אין היסטוריה), ניתן למחוק. אבל אם חולק בעבר, המחסנאי יסמן אותו "לא פעיל" (דרך עריכה) ולא ישתמש בו יותר. ברשימת הפריטים אולי ניתן להסתיר פריטים לא פעילים כברירת מחדל, כדי לא להעמיס.
מסך היסטוריה (היסטוריית קבלות ציוד)
תיאור כללי: מסך ההיסטוריה מאפשר לצפות ברשימת כל הקבלות (אירועי קבלת ציוד) שתועדו במערכת. זהו מעין יומן פעילות של המחסן, המשמש לבקרה, מעקב ופיקוח. משתמשים (מחסנאי, קצין טכני, מפקד) יכולים להשתמש במסך זה כדי לענות על שאלות כמו "מי קיבל מחשב נייד בשבוע האחרון?" או "איזה ציוד חולק לתרגיל X?".
רכיבי UI במסך היסטוריה:
•	כותרת: "היסטוריית קבלות" או פשוט "היסטוריה".
•	סרגל חיפוש וסינון: בראש המסך יהיו אפשרויות סינון כדי לצמצם את הרשומות:
•	שדות לבחירת טווח תאריכים (מתאריך X עד Y) כדי להציג רק קבלות בתקופה רצויה.
•	שדה חיפוש טקסט חופשי – יכול לחפש לפי שם מקבל, שם פריט, או מזהה קבלה.
•	ייתכן פילטר לפי סוג פריט (Dropdown של רשימת פריטים כדי לראות כל הקבלות שכללו פריט מסוים).
•	כפתור "סנן" להחלת הסינון, וכפתור "איפוס" לניקוי.
•	טבלת היסטוריה: מציגה את רשימת הקבלות כפלט. כל שורת טבלה מייצגת קבלה אחת:
•	מס' קבלה: מזהה ייחודי (אוטומטי) של הקבלה.
•	תאריך ושעה: מתי נרשמה הקבלה.
•	שם המקבל: כפי שהוזן (חייל/גורם שקיבל את הציוד).
•	פריטים וכמויות: עמודה זו יכולה להציג תקציר, למשל "3 פריטים" או רשימה מקוצרת של שמות הפריטים (למשל "מחשב נייד x1, סוללה x2...").
•	נוצר ע"י משתמש: (אופציונלי) שם המשתמש המחסנאי שביצע את הרישום – חשוב כשיש כמה משתמשים, כדי לדעת מי הוציא.
•	פעולה/פרטים: כפתור "צפה" או "פרטים" בשורה כדי לראות את מלוא פרטי הקבלה.
•	תצוגת פרטי קבלה: בעת לחיצה על "צפה" בשורה, אחת משתי אפשרויות:
•	או שיפתח חלון קופץ/מודאלי עם פירוט: יציג את כל הפריטים שהיו בקבלה הזו, עם הכמויות המדויקות, ואולי הערות אם היו.
•	או שנעבור לעמוד נפרד "פרטי קבלה" (אך עדיף מודאלי כדי לא לעזוב את רשימת ההיסטוריה). במודאל יופיע: רשימת פריטים (שם+כמות) כמפורט, שם המקבל, תאריך, המשתמש שרשם.
•	במודאל יכול להיות גם כפתור "סגור" וכפתור "בטל קבלה" (אם מתירים ביטול/מחיקה, ראה להלן).
•	דפדוף/עמודי עמודים: אם יש הרבה רשומות, הטבלה תהיה עם דפדוף (pagination) למשל 50 קבלות לעמוד. אפשר לעבור בין עמודים.
•	ייצוא: לא חובה, אבל ניתן לשקול כפתור "ייצא לאקסל" או "הדפס דוח" עבור טווח הסינון הנוכחי. בכך אם רוצים להגיש דוח תקופתי, זה מקל.
כללים עסקיים במסך היסטוריה:
•	כברירת מחדל יוצגו הקבלות מהחדשות לישנות (מיון יורד לפי תאריך).
•	סינון לפי פריט: אם המשתמש בוחר פריט מסוים, יוצגו רק קבלות שבהן הייתה שורת קבלה עם אותו פריט. זה מצריך שאילתות מתקדמות (כולל JOIN או חיפוש ברשימת השורות).
•	זמני שמירת הנתונים: בהנחה שאין עניין פרטיות רגיש – נשמור היסטוריה ללא הגבלת זמן (כדי לראות גם שנים אחורה). אם יש דרישה לנקות, ניתן להוסיף בהמשך אפשרות ארכיון.
•	ביטול/מחיקת קבלה: בגירסת בסיס, לא ניתן למחוק קבלה דרך הממשק (כדי לא לפגוע בשרשרת האספקה ולמנוע "העלמת" רישומים). אולם, ייתכן מצב שקבלה נרשמה בטעות ויש לתקן. אפשרות אחת היא ליצור מנגנון "ביטול קבלה" – כפתור במודאל הפרטים שאומר "בטל את הקבלה הזו". אם לוחצים, תידרש סיסמת מנהל לאישור. הביטול יכול להתבטא כך: יצירת רשומת קבלה הפוכה (נגדית) שמחזירה את הפריטים למלאי, או פשוט סימון הקבלה כמבוטלת + החזרת המלאי. כדי לפשט, אפשר לומר: כרגע אין מחיקה, ואם יש טעות, על מנהל המערכת לתקן ידנית דרך מסד הנתונים או דרך הוספת מלאי בפריט (פתרון עקיף).
•	הרשאת צפייה: גם משתמש רגיל (מחסנאי) וגם מנהל יכולים לצפות בהיסטוריה. ייתכן שאפילו יתנו גישת "צפייה בלבד" למפקדים – למשל מפקד שיוכל להתחבר ולראות היסטוריה אך לא לשנות/להוסיף. דבר זה דורש תפקידים שונים.
זרימת עבודה לדוגמה במסך היסטוריה:
•	קצין התקשוב נכנס למערכת, ובמקום להיכנס למסך קבלת ציוד, הוא פותח את "היסטוריה". הוא רואה רשימה של כל הקבלות שבוצעו. הוא מסנן בתיבת החיפוש את המילה "מחשב", ורואה את כל הפעמים שמחשב נייד חולק. מהטבלה הוא מוצא שב-5.1.2026 חולק מחשב נייד ללוי רן. הוא לוחץ "צפה" ליד אותו רישום, ומקבל חלון שמראה: "קבלה מס' 17, תאריך 5.1.2026 14:35, מקבל: סרן רן לוי, פריטים: מחשב נייד Toughbook x1, מטען למחשב x1. נרשם ע"י: admin". הקצין מוודא שהמחשב הזה חזר, ואם לא – יש לו את שם המקבל לפנות אליו.
•	דוגמה נוספת: מחסנאי רוצה לסכם כמה מכשירי קשר יצאו ברבעון האחרון. הוא מסנן תאריך מ-1.1.2026 עד 31.3.2026, ובוחר בפריט "מכשיר קשר RF-7800" בפילטר. הטבלה מציגה אולי 3 רשומות של קבלות שכללו פריט זה. הוא יכול ידנית לראות שסך הכמויות ברשומות הוא 3 יח'. (בעתיד אולי נוסיף סיכום אוטומטי).
•	אם היה אפשר ביטול: נניח קבלה נרשמה פעמיים בטעות לאותו חייל. המחסנאי מזהה זאת בהיסטוריה, פונה למנהל – המנהל ימצא את הקבלה הנוספת, יפתח, ילחץ "בטל קבלה". המערכת תשאל "לבטל את קבלה 18? הפריטים יחזרו למלאי.", מאשר, והקבלה מסומנת כמבוטלת (אולי נשארת ברשימה עם ציון מיוחד). המלאי מתעדכן חזרה.
מסך התחברות (Login)
תיאור כללי: זהו המסך הראשון שהמשתמשים יראו, המשמש לאימות זהותם לפני שימוש במערכת. רק לאחר התחברות מוצלחת יתאפשר גישה למסכים האחרים. מטרת ההתחברות היא אבטחה (שרק מורשים יפעלו) וגם רישום מי המשתמש הפעיל לצורך Audit Trail.
רכיבי UI במסך התחברות:
•	שדות התחברות:
•	"שם משתמש" – Textbox להזנת username.
•	"סיסמה" – Textbox מסוג password (התוויה מוסתרת) להזנת סיסמה.
•	כפתור "התחבר": שליחה של הטופס. יהיה פעיל רק אם מולאו שני השדות.
•	זכירת משתמש: (אופציונלי) צ'קבוקס "זכור אותי" כדי להישאר מחובר. אפשרות זו נשקלת אם יש צורך (בסביבה צבאית ייתכן שלא כדי למנוע גישה לא מורשית אם שכחו להתנתק).
•	הודעות שגיאה: אם ההתחברות נכשלה (שם משתמש או סיסמה שגויים), יוצג הודעה "שם המשתמש או הסיסמה שגויים, נסה שוב." גם במקרה שהשרת לא זמין או שגיאה אחרת – יציג מסר מתאים ("לא ניתן להתחבר לשרת, בדוק חיבור.").
•	עיצוב: מסך זה יהיה פשוט ונגיש. אולי יכלול לוגו היחידה או תמונת אילוסטרציה קטנה (כגון סמל תקשוב או גדוד 388) לטאצ' אישי. מעבר לכך, רק השדות והכפתור. רצוי למקם אותו מרכז במסך.
•	איפוס סיסמה: לא יהיה מנגנון שחזור סיסמה אוטומטי (אין דוא"ל וכו'), אלא אם צריך לשנות – מנהל מערכת יעשה זאת ידנית (מחוץ למערכת, או אולי נוסיף מסך ניהול משתמשים בעתיד).
•	לאחר התחברות: אם הנתונים תקינים, המערכת תעביר אוטומטית לדף הראשי (נניח דף קבלת ציוד). במקביל תישמר אסימון (Token) או Session שמאפשר להישאר מחובר.
כללים והערות:
•	ניהול משתמשים: במסמך זה לא התבקש מסך ניהול משתמשים, לכן נניח שהמערכת תבוא עם משתמשים מוגדרים מראש (דרך Seed, ראה סעיף 11) ומנהל המערכת יוכל לערוך/להוסיף משתמשים דרך מסד הנתונים או כלי פשוט אם יפותח בהמשך.
•	אבטחת סיסמה: הסיסמה תישמר במסד באופן מוצפן (Hash+Salt) ולא בטקסט גלוי, כדי למנוע ניצול אם בסיס הנתונים נחשף. האימות יעשה על ידי השוואת hash.
•	הרשאות: ייתכן שני תפקידי משתמשים: מנהל ומחסנאי רגיל. מנהל יוכל הכל (כולל ניהול פריטים ומשתמשים), ומחסנאי רגיל אולי לא יוכל למחוק פריט או להוסיף משתמש. אבל ברמת מסכים כרגע, שניהם רואים את אותם מסכים (פרט לאפשרויות מחיקה/ביטול שמנהל יכול).
•	Timeout: אם משתמש נשאר לא פעיל, אפשר לקבוע Timeout (למשל 30 דקות) שמחייב login מחדש, לטובת אבטחה. זו החלטת קונפיגורציה שתומכת במערכת (JWT token exp למשל).
•	התנתקות (Logout): באפליקציית הלקוח יהיה כפתור "התנתק" (כנראה בתפריט עליון או תחתון) שמאפשר למשתמש לצאת מחשבון המשתמש, מה שיחזיר אותו למסך ההתחברות. בכך ניתן להעביר את העמדה למשתמש אחר או לנעול בסוף שימוש.
זרימת עבודה במסך התחברות:
1.	המחסנאי פותח את האפליקציה (כתובת URL מקומית). מוצג מסך התחברות. הוא מקליד שם משתמש (למשל: bazapAdmin) וסיסמה (נגיד: P@ssw0rd).
2.	לוחץ "התחבר". המערכת שולחת את הנתונים לשרת (API של התחברות). השרת בודק במסד את המשתמש והסיסמה (לאחר hashing) ומתאים.
3.	במקרה הצלחה, השרת מחזיר אסימון JWT חתום, או אישור Session. הלקוח שומר זאת (בזיכרון/LocalStorage) ומשנה מצב ל"מחובר".
4.	הלקוח מנווט אוטומטית למסך קבלת ציוד (או לדאשבורד ראשי במערכת). מעתה כל בקשת API מהלקוח תכלול את האסימון במידת הצורך (Authentication Header) כדי שהשרת ידע שהמשתמש מאומת.
5.	אם ההתחברות נכשלה, המשתמש יקבל הודעת שגיאה ויישאר בדף ההתחברות לנסות שוב. לאחר 3 ניסיונות כושלים, אפשר לשקול נעילה לזמן קצר (אך אפשר גם לוותר בהתחשב שזה סביבה פנימית).
6.	כשמסיים עבודה, המשתמש ילחץ "התנתק" – מה שימחק את האסימון מהדפדפן ויחזיר אותו למסך התחברות.
רכיבי UI משותפים ועיצוב כללי
•	תפריט ניווט: המערכת תכלול תפריט (ניווט עליון או צדדי) לניווט בין המסכים: "קבלת ציוד", "ניהול פריטים", "היסטוריה", ו"כפתור התנתקות". התפריט יוצג בכל המסכים (פרט למסך התחברות) כדי לאפשר מעבר מהיר. ייתכן וכיתוב עם שם המשתמש הנוכחי יוצג ליד כפתור ההתנתקות ("מחובר בתור: bazapAdmin").
•	עיצוב וטכנולוגיה צד לקוח: נשתמש ב-React עם ספריית רכיבים (ייתכן שימוש ב-Bootstrap או Material-UI עבור כפתורים, טבלאות וטפסים סטנדרטיים). העיצוב יהיה מינימליסטי אך ברור: רקעים בהירים, טקסט כהה, שדות בולטים. תמיכה מלאה בעברית (יישור לימין, פונטים קריאים). לדוגמה, תוויות (Labels) מעל שדות או בצידן, בהתאם לתבניות UI מקובלות ביישור לימין.
•	נגישות ושימושיות: יש לשים דגש שגודל הפונט והכפתורים יהיו מספקים לעבודה נוחה (לפעמים מחסנאי עובד בתנאי תאורה קשים או מהר – הכל צריך להיות ברור). כמו כן, המערכת תהיה ריספונסיבית במידת האפשר: אם ירצו להריץ על טאבלט בשטח – המסכים יסתדרו (React ו-Bootstrap בד"כ תומכים בכך). אבל בהתחשב שהשימוש העיקרי הוא בעמדת PC במחסן, זה לא דגש עליון.
•	הודעות אישור/שגיאה אחידות: בכל המערכת, נשתמש בקוד צבעים אחיד: הודעות הצלחה בירוק, שגיאה באדום, אזהרה בצהוב. הודעות יוצגו במקומות בולטים (למשל בחלק העליון של הטופס או כ-Popup קטן). לדוגמה, "פריט נוסף בהצלחה" יוצג לכמה שניות ונעלם.
•	שמירת מצב (State): אם משתמש מילא חלק מהטופס בקבלת ציוד וניווט בטעות לעמוד אחר, נשקול לשמור את המצב (כדי שהנתונים לא יאבדו). זה שיפור אפשרי אך לא חובה בגירסה ראשונה.
כללי מערכת והנחות יסוד
•	סביבה ופריסה: המערכת מתוכננת לפעול ברשת הפנימית של הגדוד/היחידה. ניתן להריץ את השרת על מחשב המחסן (Windows) ולהגדירו לשירות עצמי. אין צורך בחיבור אינטרנט חיצוני כדי לעבוד. ה-Frontend יכול לרוץ כדף דפדפן על אותה מכונה או מכונות ברשת המחסן.
•	מספר משתמשים ופעולות סימולטניות: הנחנו לרוב מחסנאי אחד עובד בזמן נתון. אם בכל זאת שניים ירצו לעבוד יחד, המערכת תומכת בכך (כל עוד מוגדרים שני משתמשים). SQLite מאפשר מספר קריאות/כתיבות בו-זמנית במידה נמוכה; עקב אופי העבודה (כמה שניות כל פעולה) לא צפוי קונפליקט גדול. אם יום אחד תהיה דרישה ליותר משתמשים פעילים במקביל, אפשר לשקול העברת המסד ל-SQL Server או Postgres ולהריץ את ה-Web API על שרת רשת.
•	גיבוי ושרידות: על משתמשי המערכת יהיה לגבות תקופתית את קובץ ה-SQLite (למשל מדי שבוע להעתיקו לכונן אחר) כדי למנוע אובדן נתונים במקרה קריסת מחשב. בנוסף, ניתן לשקול שהמערכת תשמור לוגים או תדפיס פיזית חלק מהמידע כגיבוי, אך כרגע לא נדרש.
•	אבטחת מידע: המערכת מכילה מידע רגיש (מה נמצא במלאי ומי קיבל מה – מידע לוגיסטי פנימי). תידרש סיסמה חזקה לכל משתמש, ואפשר לחייב החלפת סיסמה תקופתית (נהלי צה"ל לרוב דורשים שינוי סיסמה כל 3 חודשים – ניתן ליישם זאת בפיתוח מתקדם). התקשורת בדפדפן יכולה להיות ב-HTTP כי זה מקומי, אבל רצוי לשקול שימוש ב-HTTPS אם יהיה שרת נפרד, כדי למנוע יירוט נתונים ברשת הבסיס.
•	הנחות פשטות: המערכת אינה מנהלת מספר מחסנים או גדודים – היא מיועדת למחסן ספציפי (גדוד 388). אין צורך בריבוי-אתרים. כמו כן, לא מתבצע בתוכה ניהול של הזמנות רכש או מלאי מינימום/מקסימום (פרט להתרעות פשוטות אולי). אלו יכולות להישקל כהרחבות בעתיד.
•	שילוב עם Codex (AI) בפיתוח: צוות הפיתוח יעזר בכלי AI (כמו OpenAI Codex או GitHub Copilot) לייצור חלק מהקוד. לכן, תכנון המערכת והמסמך מנוסחים בצורה שיתאימו גם להנחיית כלי AI לבנות את הקוד באופן מודרך. יש התייחסות לכך בנספח (סעיף 12) עם Promptים ייעודיים לשלבים השונים.
האפיון הפונקציונלי הנ"ל מתווה באופן שלם את מסכי המערכת ואת האינטראקציות העיקריות. בהמשך נפרט את הדרישות בצורה של User Stories, את תכנית העבודה לשלבי הפיתוח, בחירות הטכנולוגיה, מבנה הנתונים, ה-API, בדיקות נדרשות, נתוני דוגמה, ולבסוף נספח promptים ל-Codex ליישום אוטומטי של חלק מהשלבים.
5. User Stories + Acceptance Criteria (אפיוני משתמש לפי Epics)
כדי להבטיח הבנה מלאה של דרישות המערכת, הדרישות הפונקציונליות יפורקו ל-User Stories – תרחישי שימוש מנקודת מבט המשתמש – כולל קריטריוני קבלה (Acceptance Criteria) שמגדירים מתי סטוריית משתמש נחשבת כממומשת בהצלחה. להלן קבוצות של User Stories לפי אפיקים (Epics) מרכזיים: קבלת ציוד, ניהול מלאי, היסטוריה ודיווח, ואבטחה/הרשאות.
Epic 1: תהליך קבלת ציוד (Equipment Receiving)
•	Story 1: כמחסנאי, אני רוצה להזין במהירות ובקלות את פרטי הציוד הנמסר לחייל במערכת, כדי שהמלאי יתעדכן מיד ויהיה תיעוד מדויק של ההוצאה.
Acceptance Criteria:
•	כאשר כל השדות הדרושים (שם מקבל, לפחות פריט אחד עם כמות) מוזנים כהלכה ולוחצים "שמירת קבלה", אז הקבלה נשמרת במערכת עם מזהה ייחודי, תאריך נוכחי, הפריטים והכמויות, והנתונים מתעדכנים במסד.
•	לאחר שמירת הקבלה, כמות המלאי של כל פריט באותה קבלה מופחתת בהתאם לכמות שנמסרה. לדוגמה, אם נמסרו 2 יחידות פריט X והמלאי הקודם היה 10, לאחר השמירה יהיה 8.
•	לאחר הצלחה, מופיעה למשתמש הודעת אישור, והטופס מתאפס לשימוש חוזר. הקבלה החדשה ניתנת לצפייה במסך ההיסטוריה.
•	אם המשתמש מנסה לשמור כאשר חסר שדה חובה, למשל לא הזין שם מקבל או לא הוסיף פריטים, אז הפעולה תיחסם – תוצג הודעת שגיאה מתאימה ולא תיווצר קבלה.
•	אם הוזנו נתונים לא תקינים (כגון כמות = 0 או ערך שלילי), המערכת לא תאפשר שמירה ותתריע למשתמש לתקן את הערך.
•	המערכת מאפשרת במסגרת קבלה אחת להכניס ריבוי פריטים (שורות מרובות) באופן חלק – ניתן להוסיף לפחות 10 פריטים שונים לפני סיום, והכל נשמר בקבלה אחת.
•	Story 2: כמחסנאי, אני רוצה להימנע מרישום כפול או שגוי של פריטים בעת קבלת ציוד, כדי שהמידע יהיה נקי וללא כפילויות.
Acceptance Criteria:
•	בבחירת פריט להוספה, עלי לבחור מתוך רשימת פריטים קיימים ולא להקליד שם חופשי – המערכת מציגה רק פריטים תקפים שוגדרו, ובכך מונעת הקלדת שם פריט עם שגיאות כתיב או וריאציות שונות.
•	אם אנסה להוסיף פעמיים את אותו פריט ברשימת הפריטים של קבלה אחת, המערכת תאחד או תחסום את הכפילות. לדוגמה: אם כבר הוספתי "מטען למחשב" פעם אחת, ניסיון להוסיפו שנית יקפיץ הודעה "הפריט כבר קיים בקבלה" ולא ייצור שורה שנייה זהה (או שיגדיל את הכמות בשורה הקיימת – כל פתרון מונע כפילות ייחשב קביל).
•	כל קבלה נשמרת פעם אחת בלבד. אין מצב שהמערכת תשמור בטעות את אותה קבלה פעמיים. קריטריון: אם המשתמש לוחץ פעמיים על "שמור" מהר, המערכת תטפל בכך (למשל תחסום כפתור לאחר לחיצה ראשונה או תבדוק כפילות) כך שתיווצר רק רשומה אחת.
•	מספר הקבלה (ReceiptID) יהיה ייחודי ולא חוזר, גם אם היו מחיקות – זאת כדי למנוע בלבול בין רשומות.
•	Story 3 (אופציונלי לעתיד): כמחסנאי, אני רוצה להשתמש בסריקת ברקודים כדי להזין פריט וכמות, כדי לזרז עוד יותר את התהליך ולצמצם הקלדה ידנית.
Acceptance Criteria:
•	כאשר אני ממקד את הסמן בשדה הפריט וסורק באמצעות סורק ברקוד פריט קיים, המערכת מזהה את הקוד, בוחרת אוטומטית את הפריט התואם ברשימה, וממקמת את הסמן בשדה הכמות (או מגדילה ב-1 אוטומטית).
•	תומכי ברקוד: לכל פריט במערכת יש מאפיין קוד ייחודי שניתן להדפיס כברקוד ולהצמיד לפריט במחסן. סריקת ברקוד זה צריכה להתמפות לקוד הפריט במערכת.
•	אם נסרק קוד לא ידוע, תופיע הודעה המתריעה שהפריט לא קיים במערכת.
(ה-Story הזה אינו חובה למימוש הראשוני, אך מראה את כיוון ההתייעלות העתידי; קריטריונים אלו לא חייבים להיות ממומשים בגרסה הראשונה.)
Epic 2: ניהול פריטי מלאי (Item Management)
•	Story 1: כמנהל מערכת או מחסנאי אחראי, אני רוצה להוסיף פריטי ציוד חדשים למערכת, כדי לאפשר את הוצאתם במערכת כאשר ציוד חדש נכנס לשימוש.
Acceptance Criteria:
•	במסך "ניהול פריטים", כאשר אני ממלא שם פריט חדש ושומר, הפריט החדש מופיע ברשימת הפריטים, עם מזהה (ID) שהוקצה אוטומטית, וקוד אם סופק.
•	הפריט החדש זמין מידית לבחירה במסך קבלת ציוד (ניתן לראותו ברשימת הפריטים שם).
•	לא ניתן להזין שם פריט ריק – זהו שדה חובה. ניסיון שמירה עם שם ריק יציג שגיאה ולא ייצור פריט.
•	אם הוזן קוד פריט שכבר קיים בפריט אחר, הפעולה תידחה עם הודעת שגיאה "קוד הפריט כבר בשימוש". (אותו כלל לגבי שם פריט, אם הוחלט ששמות חייבים ייחודיים).
•	בהוספת פריט, אם לא צוינה כמות התחלתית, ברירת המחדל תהיה 0 (או שהמערכת תחייב להזין, תלוי החלטה – נקבל 0 כברירת מחדל וניתן לעדכן אחר כך).
•	Story 2: כמחסנאי, אני רוצה לערוך את פרטי פריט קיים (שם, קוד או כמות), כדי לתקן טעויות או לשנות את מצב המלאי בהתאם למצב בפועל.
Acceptance Criteria:
•	במסך ניהול פריטים, לחיצה על עריכת פריט מציגה את הטופס עם פרטי הפריט הנוכחיים. ניתן לשנות את השדות (למשל לתקן איות בשם).
•	כאשר שומרים את העריכה, הפרטים המעודכנים נראים בטבלה, והשינוי משפיע בכל מקום רלוונטי (למשל, אם שיניתי את שם הפריט, כעת במסך קבלת ציוד יופיע השם החדש).
•	שינוי כמות במלאי: אם אני מגדיל או מפחית את הכמות במסגרת עריכה, השינוי משוקף מידית במלאי הזמין.
o	לדוגמה: פריט "סוללה 12V" היה 18 במלאי (אחרי חלוקות קודמות). הגיע משלוח חדש של 10 יח'. אני משנה את הכמות ל-28 ושומר. עכשיו בכל מקום (טבלת ניהול, אולי תצוגה במסך קבלה) רואים 28 כמות זמינה.
o	המערכת שומרת לוג שינוי (אולי רשומה ברמת back-end) שמסביר שהייתה הוספת 10 ידנית על ידי משתמש X בזמן Y, למעקב. (לא חובה לחשיפה בממשק, אבל כתנאי קבלה פנימי: פעולה זו לא תמחק היסטוריה אלא מתועדת).
•	לא ניתן לערוך מזהה של פריט (זהו שדה מערכת, לא יוצג לעריכה).
•	לא ניתן לשנות קוד פריט לקוד שכבר קיים בפריט אחר (כנ"ל כמו בהוספה).
•	אם פריט סומן כ"לא פעיל" (נניח בצ'קבוקס), הוא לא יופיע ברשימת הפריטים לבחירה בקבלת ציוד לאחר מכן.
•	ביצוע עריכה עם שדות לא תקינים (שם ריק, מספר שלילי בכמות וכו') ייעצר עם הודעת שגיאה ולא יישמר עד תיקון.
•	Story 3: כמנהל/מחסנאי, אני רוצה להסיר פריט שאינו רלוונטי עוד, כדי לשמור את רשימת הפריטים במערכת נקייה ועדכנית.
Acceptance Criteria:
•	במסך ניהול פריטים, לחיצה על כפתור מחיקה ליד פריט תביא לחלון אישור "האם למחוק פריט X?".
•	אם מאשרים, והפריט מעולם לא חולק (אין אף קבלה שכוללת אותו), המערכת תמחק את הפריט לחלוטין ממסד הנתונים. הוא ייעלם מהטבלה ומהאפשרויות בכל מקום.
•	אם לפריט יש היסטוריית קבלות (זוהה ע"י בדיקה אם קיים ReceiptLine מקושר אליו), המערכת לא תמחק. במקום, יוצג מסר: "לא ניתן למחוק פריט שקיימות עבורו קבלות. ניתן לסמן אותו כלא פעיל." והפריט יישאר.
•	פריט שסומן כלא פעיל יתנהג כאילו הוסר מבחינת המשתמש הרגיל (לא יופיע למסירה), אך יישאר בטבלה (ניתן להציגו אולי באפור או תחת סינון "כולל לא פעילים").
•	ניסיון מחיקה של פריט לא פעיל עם היסטוריה ינהג כנ"ל (לא מוחק כי יש היסטוריה). רק אם יבצעו מחיקה על פריט חדש בלי היסטוריה זה יתבצע.
Epic 3: היסטוריה ובקרת מלאי
•	Story 1: כמחסנאי או מפקד, אני רוצה לצפות ברשימת כל קבלות הציוד שהתבצעו, כדי לבצע מעקב ואימות של פעילות המחסן.
Acceptance Criteria:
•	במסך "היסטוריה", אני רואה טבלה של קבלות, כמפורט בסעיף האפיון. כברירת מחדל מוצגות הקבלות האחרונות (לפי סדר כרונולוגי יורד).
•	כל רשומה מציגה לפחות: תאריך, מקבל, ומידע סיכומי על הפריטים (למשל מספר פריטים או כמה שמות ראשונים).
•	אני יכול לגלול או לדפדף ולראות קבלות קודמות (אם הרבה). הטעינה של הנתונים מתרחשת ללא שגיאות, גם אם יש מאות רשומות.
•	לחיצה על רשומה נפתחת (מודאל או עמוד נפרד) שמציגה את כל פרטי הקבלה: רשימת הפריטים והשורות עם כמויות, בדיוק כפי שנרשמו, וכן פרטים נוספים כמו מי המשתמש שרשם, הערות אם היו.
•	במסך הפרטים יש כפתור סגירה כדי לחזור לרשימה.
•	המידע בהיסטוריה תואם בדיוק למה שנרשם בזמן אמת: כלומר, אם חולקו 2 סוללות לאותו חייל, בהיסטוריה יופיע "סוללה 12V x2" תחת אותה קבלה.
•	קריטריון חשוב: אין "קפיצות" או חוסרים ברצף מספרי הקבלות – לוודא שכל קבלה שנשמרה אכן מופיעה (ניתן לבדוק לפי מספרי הקבלה ההולכים ועולים).
•	Story 2: כמפקד/קצין לוגיסטיקה, אני רוצה לסנן ולחפש בהיסטוריה לפי קריטריונים, כדי למצוא מידע ספציפי (כמו מי קיבל פריט מסוים או מה חולק בתקופה מסוימת).
Acceptance Criteria:
•	אם אני מזין טווח תאריכים בסינון, המערכת מעדכנת את הרשימה ומציגה רק קבלות שנופלות בין התאריכים (כולל הקצוות). למשל, בחירה 1-31 בינואר 2026 תציג רק קבלות מתאריכים אלו.
•	אם אני מזין מחרוזת בשדה החיפוש (למשל שם חייל או שם פריט), המערכת מציגה רק קבלות שבהן המחרוזת מופיעה בשם המקבל או בשם אחד הפריטים.
•	הסינון מתבצע בצד השרת (כלומר API מאפשר שאילתות עם פרמטרים) או בצד לקוח לאחר שליפת כל המידע – בכל אופן התוצאה זהה.
•	ניתן לשלב סינונים: למשל, גם טווח תאריך וגם שם פריט.
•	מהירות הסינון: עבור עד כמה אלפי רשומות, התגובה מגיעה תוך כמה שניות לכל היותר.
•	אם אין תוצאות תואמות לסינון, מוצג "לא נמצאו רשומות" במקום הטבלה.
•	Story 3: כמנהל, אני רוצה להיות מסוגל לתקן רישום שגוי בהיסטוריה במקרה הצורך, כדי שמאגר הנתונים יהיה אמין וללא טעויות כפולות.
Acceptance Criteria:
•	(אפשרות ראשונה) המנהל יכול לבטל קבלה דרך מסך ההיסטוריה: בחלון פרטי קבלה קיים כפתור "בטל קבלה". לחיצה עליו תדרוש אישור.
•	אם אושר, המערכת תסמן את הקבלה כמבוטלת (Cancelled) – ייתכן ע"י שדה מצב במסד. קבלה מבוטלת עדיין תוצג ברשימה אבל מסומנת (לדוגמה עם קו חוצה או צבע אחר, או עמודת מצב="מבוטלת").
•	בעת ביטול, המערכת תעדכן את המלאי: תוסיף בחזרה את כמויות הפריטים שהיו בקבלה (כלומר כאילו הקבלה לא קרתה).
•	קבלה מבוטלת לא תיספר בדוחות סיכום (אם יעשו) ולא תופיע כברירת מחדל אלא רק אם מבקשים לראות גם מבוטלות.
•	(אפשרות שנייה) לחלופין, אם בוחרים שלא לאפשר ביטול: אז קריטריון הוא שלא תתבצע מחיקה כלל דרך הממשק. תיקון שגיאות ייעשה ע"י הוספת קבלות הפוכות או עריכת המלאי ידנית. במקרה זה, Story זה לא נדרש למימוש.
•	אם יש מנגנון ביטול, הוא יהיה מוגבל למשתמש בעל תפקיד מנהל בלבד. משתמש רגיל לא יראה כפתור זה.
•	Story 4: כמחסנאי, אני רוצה לזהות כאשר פריט במלאי מגיע לכמות נמוכה, כדי שאוכל ליזום מילוי מחדש או דיווח לפני שנגמר. (תכונת "התראה" קשורה לבקרת מלאי, נזכיר כ-story יתכן עתידי)
Acceptance Criteria:
•	עבור כל פריט ניתן להגדיר "סף מינימום" (min level). אם לא הוגדר, ברירת מחדל 0 (אין התראה).
•	בכל פעם שמבצעים קבלה (הוצאה) וכתוצאה ממנה כמות הפריט יורדת אל מתחת לסף, המערכת תציג התראה למחסנאי: למשל "התראה: נותרו רק 2 יח' ממכשיר קשר RF-7800 במלאי!".
•	התראות יצטברו גם במקום מרכזי (אולי סימן אזהרה ליד אותו פריט ברשימת הפריטים).
•	קריטריון הצלחה: אם היה 5 במלאי, סף מינ' 5, ומסרתי 1 – עם שמירת הקבלה תופיע התראה על אותו פריט (4 נותרו שזה מתחת לסף).
(גם Story 4 כאן הוא שדרוג אפשרי, לא בהכרח דרישה מיידית, אך מציין חשיבה "חכמה" של המערכת.)
Epic 4: אבטחה והרשאות (Authentication & Authorization)
•	Story 1: כמשתמש מערכת (מחסנאי או מנהל), אני רוצה להתחבר באמצעות שם משתמש וסיסמה, כדי לוודא שרק לי יש גישה לפונקציונליות ואני רואה רק את מה שמורשה לי.
Acceptance Criteria:
•	כאשר אני מזין אישורי התחברות נכונים (שם משתמש וסיסמה תקינים) ולוחץ "התחבר", המערכת מאמתת אותי ומעבירה אותי למסך הראשי.
•	לאחר ההתחברות, כל בקשותיי למידע (לדוגמה, ניסיון לגשת למסך היסטוריה או להוציא ציוד) מתקבלות על ידי השרת – איני מתבקש שוב להזדהות, כי יש Session פעיל.
•	אם אני מזין סיסמה שגויה, ההתחברות נכשלת: אני נשאר בדף ההתחברות ורואה הודעת שגיאה. הסיסמה לא נחשפת (הקלט סיסמה מוצג בכוכביות).
•	עד שלא התחברתי בהצלחה, איני יכול להגיע לשאר המסכים. ניסיון לנווט באופן ישיר (למשל הזנת URL של מסך ניהול פריטים) ינתב אותי חזרה לדף login.
•	אבטחת סיסמה: במסד הנתונים, סיסמת המשתמש שמורה כערך מוצפן/מגוּבה (Hash+Salt). קריטריון זה נבדק על ידי עיון במסד נתונים: הערכים אינם קריאים כסיסמאות המקור.
•	תקשורת: קריאות ה-API של התחברות מעבירות את הסיסמה בצורה מאובטחת (אם ב-HTTP פנימי, לפחות לא חושפים מעבר למה שצריך; אם היה HTTPS אז מוצפן ברשת).
•	מנגנון נעילה: לאחר 5 ניסיונות כושלים ברצף עבור אותו משתמש, החשבון ננעל ל-5 דקות (ניתן לכוונן). קריטריון: ניסיון שישי תוך פרק הנעילה יידחה אוטומטית. (לא חובה למימוש מיידי, אך רצוי)
•	Story 2: כמנהל מערכת, אני רוצה שיכולת ניהול הפריטים והמערכת תהיה מוגבלת למנהלים בלבד, כדי למנוע משמשים זוטרים לשנות הגדרות.
Acceptance Criteria:
•	משתמש בעל תפקיד "Admin" יכול לגשת לכל המסכים, כולל "ניהול פריטים" וייתכן "ניהול משתמשים" אם קיים.
•	משתמש בעל תפקיד "User" (מחסנאי רגיל) יכול לבצע קבלות ולהציג היסטוריה, אך ייתכן שאין לו גישה למסך ניהול הפריטים (ניתן למנוע זאת בהגדרות ההרשאה).
o	מבחן: אם אני מחובר כמשתמש רגיל, ניסיון לנווט ל"דף ניהול פריטים" לא יוצג (או יופיע הודעה "אין לך הרשאה" אם הוזן URL ישירות).
•	פעולות מסוימות כמו מחיקת פריט או ביטול קבלה (מהסיפורים לעיל) יהיו זמינות רק למנהל.
•	במסד הנתונים קיים שדה Role לכל משתמש, והשרת מוודא את התפקיד לפני ביצוע פעולות רגישות.
•	ממשק המשתמש יכול להסתיר/לא לאפשר לחצן שלא רלוונטי. לדוגמה, למחסנאי פשוט לא יופיע כפתור "מחק" בטבלת פריטים, או שהלחצן לחיץ אך השרת יחסום.
•	ניתן לאמת זאת על ידי יצירת שני משתמשים (admin ו-user), כניסה כ-user ובדיקה שאי אפשר לבצע שינויי ניהול.
•	Story 3: כמשתמש, אני רוצה להתנתק מהמערכת בסיום העבודה, כדי לוודא שאחרים לא ישתמשו בהרשאות שלי במקרה שיישאר דף פתוח.
Acceptance Criteria:
•	לחיצה על כפתור "התנתק" (Logout) תסיים את ה-Session שלי: הלקוח ישכח את האסימון/סשן והשרת יבטל כל אסימון רלוונטי (אם JWT אולי לא ניתן לבטל בשרת, אבל אפשר להסתמך על תפוגה).
•	לאחר התנתקות, המשתמש מוחזר למסך ההתחברות.
•	ניסיון לבצע פעולה מייד אחרי התנתקות (למשל לחזור לעמוד הקודם בדפדפן) יביא למסך login, כי אין כבר הרשאה שמורה.
•	אם משתמש לא פעיל לפרק זמן (למשל 30 דקות) – הקריטריון הוא שהמערכת תדרוש התחברות מחדש אוטומטית. (אפשר לבדוק זאת ע"י השארת הדף ללא פעילות וראייה שנדרש login).
•	כל משתמש (כולל admin) יכול להתנתק; אין מושג של "משתמש נשאר תמיד מחובר ללא אפשרות לצאת".
•	Story 4 (ניהול משתמשים - עתידי): כמנהל, אני רוצה להוסיף/למחוק משתמשי מערכת חדשים (מחסנאים), כדי להתאים את המערכת לשינויים בכוח האדם.
Acceptance Criteria:
•	הוספת משתמש: כניסה למסך (שאינו קיים עדיין בגירסה הראשונה, אבל ייתכן כתוספת) "ניהול משתמשים", הוספת שם משתמש, סיסמה, ותפקיד, ושמירה – המשתמש החדש יוכל להתחבר מיד.
•	מחיקת משתמש: מחיקה תתאפשר רק אם המשתמש לא רשם קבלות בעבר (אחרת אולי סימון כלא פעיל).
•	איפוס סיסמה: המנהל יכול לשנות סיסמה למשתמש (למשל אם שכח).
•	כללים: לא ניתן שני משתמשים עם אותו שם, סיסמה חייבת לעמוד במדיניות (אורך מינימלי).
(שוב, Story 4 לא ימומש בהתחלה כי לפי הדרישות לא בטוח שצריך UI לזה; אפשר לנהל משתמשים ברמת DB. אבל הוא נרשם ככלי תכנון להמשך.)
סיכום אפיקי ה-User Stories: הדרישות מגדירות חוויית משתמש שבה המחסנאי מסוגל לבצע את משימותיו היומיומיות (הוצאת ציוד) מהר יותר ובאמינות גבוהה, המנהל שולט במלאי ומוודא שכל שינוי מתועד, ומבחינה טכנית–ארגונית, המידע מאובטח ומנוהל בתורה מקצועית. כל Story המפורט למעלה מציין את התנאים בהם נשיג את שביעות רצון ה"לקוח" (המשתמש) מהמערכת.
6. תכנית עבודה מדורגת לצוות הפיתוח
להלן שלבי הפיתוח המומלצים ליישום הפרויקט, בסדר כרונולוגי. חלוקה זו תאפשר התקדמות הדרגתית תוך הבטחת שלמות הפתרון בכל שלב לפני המעבר לשלב הבא. כל שלב מניב תוצרים שניתן לבדוק לפני המשך הפיתוח.
שלב 0: הכנות והגדרת סביבה
- התקנת כלים: ודא שלצוות יש את כל הכלים הנחוצים: Visual Studio 2022 (או גרסה עדכנית) עבור פיתוח backend, Node.js וסביבת Vite עבור front-end, ודפדפנים עדכניים לבדיקה. התקן גם את חבילות ה-NuGet וה-NPM הצפויות (ASP.NET Core, EF Core, React וכו').
- Git/ניהול גרסאות: הקם ריפוזיטורי Git חדש עבור הפרויקט "Bazap2.0". הגדר מבנה סניפים אם נדרש (main/develop וכו').
- איסוף דרישות סופי: לעבור שוב על מסמך אפיון (נוכחי) עם בעלי העניין (מחסנאי, מפקד) כדי לוודא שלא פספסנו דבר, לפני התחלת הקוד.
- אפיון טכני מפורט: ליצור טבלאות ERD ותרשימי זרימה אם נדרש (ניתן גם לדלג אם המסמך מספיק ברור לצוות).
שלב 1: יצירת פרויקט וסביבת פיתוח
- Backend: בעזרת Visual Studio, צור סולושן בשם BazapSolution. בתוך הסולושן, צור פרויקט ASP.NET Core Web API בשם Bazap.Api. בחר ב-ASP.NET Core (גרסה 7 או 8) עם Template ריק (אנחנו נוסיף בעצמנו). ודא שהפרויקט בנוי על NET6/NET7/NET8 לפי ה-LTS הקיימת (NET 8 LTS נכון ל-2024/5). הרץ את הפרויקט לוודא שהוא מקונפג ורץ (תקבל API דיפולטי אולי עם מזג אוויר – אפשר למחוק בקרת דמו).
- Frontend: התקן באמצעות Node את create-vite@latest. צאץ את פרויקט Vite: בספריית הסולושן צור תיקייה Bazap.Client והרץ npm create vite@latest עם שם הפרויקט, בחר framework: React, variant: TypeScript. זה ייצור שלד של אפליקציית React. ודא שניתן להריץ npm install ואז npm run dev ולראות את אפליקציית ההאלו וורלד.
- Integrating: למרות שה-Frontend וה-Backend נפרדים, נסה להריץ את שניהם במקביל (Web API כנראה ירוץ על https://localhost:5001, ו-React על https://localhost:5173). אפשר כבר כאן לטפל ב-CORS: בקובץ Startup/Program של ה-API, הוסף מדיניות CORS שמתירה ל-Origin של 5173 לפנות (AllowAnyOrigin ב-development).
- הכן גם פרויקט בדיקות (Unit Tests) אם רוצים TDD, אבל אפשר גם להוסיף בהמשך.
שלב 2: הגדרת המודל ומסד הנתונים (EF Core)
- הוסף לפרויקט Bazap.Api את חבילת NuGet של EntityFrameworkCore SQLite (לדוגמה: Microsoft.EntityFrameworkCore.Sqlite) וגם Microsoft.EntityFrameworkCore.Tools עבור Migrations.
- צור תיקייה Models או Entities ב-Backend, וצור מחלקות C# עבור היישויות: Item, Receipt, ReceiptLine, User (לפי ההגדרות בסעיף 8 למטה). ודא שהגדרת יחסי גומלין: למשל ב-ReceiptLine יש prop ל-Item ו-Receipt ו-Keys זרים.
- צור את הקונטקסט (BazapContext : DbContext) עם DbSet לכל Entity. הגדר ב-OnModelCreating את המפתחות ויחסים מורכבים אם צריך (למשל Composite key אם בחרנו, Cascade delete מ-Receipt->ReceiptLines, No cascade מ-Item->ReceiptLines).
- בקובץ appsettings.json של ה-API, קבע connection string עבור SQLite, למשל: "ConnectionStrings": { "BazapDatabase": "Data Source=bazap.db;" }.
- ב-Program.cs, הוסף את הקונטקסט לשירותים: builder.Services.AddDbContext<BazapContext>(options => options.UseSqlite(builder.Configuration.GetConnectionString("BazapDatabase")));.
- מיגרציה ראשונית: הרץ פקודת EF (דרך Package Manager Console או CLI) Add-Migration InitialCreate ואז Update-Database. וודא שנוצר קובץ bazap.db בפרויקט (אולי צריך לציין Path). אם המיגרציה נכשלה, תקן מודל. אם הצליחה, אפשר גם לפתוח את DB עם DB Browser לוודא שיש טבלאות נכונות.
- Seed Data בסיסי: אפשר כבר עכשיו, לאחר המודל, להגדיר Seed התחלתי: ניתן להשתמש ב-OnModelCreating (HasData) כדי להזין נתונים, או לחילופין לכתוב סקריפט קטן שמכניס עם הקונטקסט (בזמן Startup). ניתן לדחות seed לשלב 7 או 11 לפי הצורך; בשלב 2 מספיק לוודא שהכל עובד.
שלב 3: מימוש בסיסי של API (Controllers & Endpoints)
- התחל עם יישות אחת פשוטה: למשל Items. צור תיקייה Controllers ב-API, והוסף ItemsController. השתמש ב-Template Web API Controller עם פעולות CRUD. ודא שמסלול הבסיס [Route("api/[controller]")].
- מימוש פעולות ב-ItemsController: - GET /items – מחזיר את כל הפריטים (Use context.Items.Include?) בשלב זה אין relations מורכבות.
- GET /items/{id} – פריט בודד (כולל מלאי). החזר 404 אם לא קיים.
- POST /items – מקבל Item DTO (או הישר entity) ומוסיף DB. בצע בדיקה שאין כפילות (לדוגמה אם code unique, בדוק). החזר 201 עם item id.
- PUT /items/{id} – עדכון. בדוק קיום, עדכן שדות (פרט ל-ID שלא משתנה). עבור שינוי Quantity, שקול אולי Logic: לשמור delta? אבל פשט: נניח שמכניסים ערך חדש ומחליפים.
- DELETE /items/{id} – בדוק האם ניתן (האם יש ReceiptLines עם itemId זה). אם כן, החזר 400 עם הודעה "cannot delete". אם אין, מחק והחזר 204.
- בדוק את ה-Items API עם כלי כגון Postman או VS swagger (הרץ את ה-API וגש ל/swagger). ודא שכל פעולה עובדת.
- הוסף Controllers עבור Receipt ו-Auth: - ReceiptsController: - GET /receipts – שליפת רשימת קבלות. מומלץ לכלול גם את השורות (Include ReceiptLines ואז Include Item בתוך כל line כדי שיהיה שם פריט). לחלופין אפשר להחזיר DTO עם מבנה נוח (Receipt עם List of lines).
- GET /receipts/{id} – שליפה פרטנית עם פירוט מלא.
- POST /receipts – קבלת ReceiptDTO עם ReceiverName, אולי UserId (ניקח מה-auth token בפועל), ורשימת lines (ItemId+Quantity). המימוש: - צור אובייקט Receipt, חבר לו ReceiptLines מתוך ה-DTO. - לפני שמירה: עבור כל ReceiptLine, בדוק שיש מספיק מלאי מה-Item (Item.QuantityInStock >= req.Quantity). אם לא, אפשר להחליט: או שמאפשרים (המלאי יהיה שלילי, פחות טוב), או שחוסמים (Return 400 "אין מספיק במלאי"). לבחירתנו. - הפחת את הכמות מהמלאי: עבור כל ReceiptLine, עשה item.QuantityInStock -= quantity. - שמור את ה-Receipt (הקונטקסט ישמור גם את ה-lines בגלל relationship). - החזר 201 Created עם מיקום /receipts/{newId}. - אפשר לאפשר delete /receipts/{id} אם רוצים (לביטול), שימצא את הרשומה, יוסיף בחזרה למלאי את הכמויות, יסמן כבטל (אולי שדה IsCancelled true במקום למחוק לגמרי). אבל בגרסה בסיסית אפשר להשמיט delete כדי לא לבלבל.
- אופציות לסינון: ניתן להוסיף GET /receipts?fromDate=&toDate= וכו', או להוסיף endpoints נפרדים. אפשר לדחות ליותר מאוחר.
- AuthController: - POST /auth/login – מקבל JSON עם Username, Password. - מחפש במסד הנתונים את ה-User עם username הנתון. - אם לא קיים או סיסמה לא מתאימה (Hash verify), החזר 401 Unauthorized. - אם מתאים, צור JWT token (דורש להגדיר ב-Startup הוספת Authentication JWT, עם signing key וכו'. אפשר לממש זאת). - החזר token ללקוח. - אופציונלי: POST /auth/logout – לא תמיד נהוג ב-JWT (כי Logout בצד לקוח). אפשר לוותר.
- (אם יש Manage Users) – יצור endpoints /users אבל לא נדרש כעת.
- UsersController (אופציונלי): אם רוצים, אפשר לאפשר admin להוסיף משתמש דרך API, אבל בשלב ראשון אולי ניצור משתמשים דרך Seed ולא API. - Test the API: שוב, השתמש ב-Postman/Swagger: - תריץ POST /items לכמה פריטים, ואז GET /items לבדוק. - תריץ POST /receipts עם פריטים לראות שזה מקטין המלאי. - תריץ login עם משתמש מ-seed לראות שמקבלים token. - נסה קריאות מוגנות (ייתכן סימון [Authorize] על controllers) בלי ועם טוקן. (צריך להגדיר JWT Bearer authentication ב-Program). - OAuth & Policies: הוסף [Authorize] מעל ItemsController, ReceiptsController (כי לא רוצים לאפשר ללא login). השאר AuthController ללא Authorize (כדי שיוכלו לקבל token). - בקובץ Program.cs הגדר: builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme).AddJwtBearer(...configs...) עם מפתח סימון. - הוסף app.UseAuthentication(); app.UseAuthorization();. - בבדיקה: נסה GET /items בלי טוקן – צריך 401. הכן טוקן באמצעות login, הוסף Authorization Header, נסה שוב – צריך לעבוד.
שלב 4: פיתוח צד לקוח – ממשק React
- מבנה פרויקט: פתח את Bazap.Client (ייתכן בנפרד עם VSCode). שם אתחיל לבנות את מבנה האפליקציה. אחליט אם להשתמש ב-React Router עבור ריבוי דפים (כן, נצטרך לפחות route ל/Login ואחד ל/App). התקן react-router-dom.
- קומפוננטת App: נגדיר את ה-Routes: - "/" או "/login" יצביע ל-LoginPage component. - "/receiving" -> ReceivingPage (קבלת ציוד). - "/items" -> ItemsPage (ניהול פריטים). - "/history" -> HistoryPage. - נוסיף גם route ל"" שמנתב ל-login או לדף 404 (לא חשוב כעת). - ניהול Authentication state: - נחליט אם להשתמש ב-Context או פשוט ב-localStorage. - אפשר ליצור Context AuthContext שמחזיק את המידע (user, token, וכו'), וספק (Provider) שעוטף את האפליקציה. - בקומפוננטת App בעת העלאה, נבדוק אם יש token תקין ב-localStorage -> נגדיר כ-"loggedIn". - ניצור רכיב <PrivateRoute> או נשתמש ב-feature של router v6 (נעשה check manual): למשל, אם user לא מחובר ונסה לגשת לנתיב מוגן, ננווט ל"/login". - עמוד התחברות (LoginPage): - טופס עם useState לשדות username, password, ו-handleSubmit שעושה preventDefault ואז קורא ל-API: POST /auth/login דרך fetch/axios. - אם הצליח, שומר את token (ב-auth context state + localStorage) ומנווט ל"/receiving". - אם נכשל, מציג שגיאה למשתמש ("שם משתמש או סיסמה לא נכונים"). - עיצוב: טופס מרכזי, כפתור. - עמוד קבלת ציוד (ReceivingPage): - כאן עיקר הלוגיקה. רכיבים פנימיים אפשר ליצור: למשל רכיב לפריט שנבחר (או פשוט הכל ב-Page). - State שנדרש: receiverName, selectedItemId, quantity, list of items in current receipt (array of {itemId, itemName, quantity}). - בנוסף, state של items master list (כל הפריטים מהמלאי) כדי למלא את dropdown. - On mount, נקרא ל-API GET /items כדי לקבל רשימת פריטים ומלאי. נשמור ב-state. - Dropdown: options from items state (value = itemId, text = name אולי עם code). - "Add" button handler: - Validate selectedItem & quantity >0. - Check if item already in list (if yes, optional: increment quantity on that entry; simpler: prevent duplicate and alert). - If ok, push to list state (with item name from items state to display). - Reset selected item field. - Render items table: iterate over list state. Show name, quantity. Add a remove button in each row that filters it out from list on click. - "Save Receipt" button handler: - Validate that receiverName not empty and list not empty. - Construct payload: { receiverName, lines: [ { itemId, quantity}, ... ] }. - Call API POST /receipts with token. - If success (201), show success message (could use a toast or just set a state "success: true" then conditionally render message). Also maybe capture returned new receipt id if needed (not necessarily needed to show). - Clear the form (receiverName = "", list = []). Optionally, refresh items list from server (to update stock numbers if we show them). In minimal, update the items state by subtracting from relevant items or do GET /items again to sync stock. Probably easier to do GET /items again. - If error (like 400 not enough stock), show error message ("לא מספיק במלאי", etc). - Possibly after saving, consider redirect to history or remain. Probably remain in form for next use. - UI nice-to-have: show available stock next to item name when selected? (e.g., after choosing item, show "זמין: X"). Could do by finding item in items state on selection and display quantity. - Also, maybe allow typeahead search in dropdown: could use a library or simple filter. But initial approach it's okay if it's just normal select with many options (not great if hundreds of items, but if dozens it's fine). If needed, implement an input text that filters the list below for selection. - עמוד ניהול פריטים (ItemsPage): - On mount, GET /items to get list. - Render a table of items with columns (Name, Code, Quantity, maybe Active) and actions. - Provide a button "Add Item" that toggles showing an add form (or navigate to /items/new route). For simplicity, maybe a modal for add: use a piece of state like showAddForm. - Add form fields: name, code, quantity. Handlers for changes. - On submit add: call API POST /items. If success, close form, refresh items list (call GET /items again or append local state if easier). - On edit: We can either inline editable fields in table or also have a modal when clicking edit icon. Simpler: modal/pop-up similar to add, but filled with selected item data. Possibly reuse the form component for add/edit. - On save edit: call API PUT /items/id. If success, refresh list (or update state for that item). - On delete: when clicking delete icon, confirm via window.confirm (simple), then call DELETE /items/id. If success (204), remove from state list. If fails (like 400 cannot delete), show alert message with reason. - UI: possibly highlight if item is inactive (maybe grey row or with text 'inactive'). But initial version might not fully implement active flag toggling from UI due to complexity; could skip inactive concept or include a simple toggle in edit form. - Also allow searching/filter items if list is long (optional). - עמוד היסטוריה (HistoryPage): - On mount, GET /receipts (or maybe an initial limited set). Could fetch all for simplicity if not huge. Or implement pagination via API (skip for now, we can handle client side). - Save receipts in state. Also keep an original array for resets after filtering. - Filtering controls state: fromDate, toDate, searchTerm, filterItem. Build UI accordingly (maybe use <input type=date> for date, text for search, select for item filter). - Provide filter button to apply filters: do the filtering in client (could do in server but to simplify initial, do client). Use JS to filter receipts state that meet conditions (date within range if given, includes term if given in either receiverName or any item name in the lines, if filterItem selected, check if that itemId present in lines). - Provide reset filter to show all again (basically set receipts state back to original or remove filters states). - Render table: columns for ID, date, receiver, summary. - For summary: maybe combine items in a string or show count like "X items". Possibly better to list names partly: For example if <=2 items then list them with quantity, if more then "and N more". But not required. We can simply display e.g. number of lines: "2 פריטים". - Provide a view details action: could be an expand row (less accessible, easier might be: clicking the row triggers modal with details). - Modal details: show receipt ID, date, receiver, user (if included), then table of lines (Item name, quantity). If there's a cancel option and user is admin, show "Cancel Receipt" button. - Cancel Receipt logic (if implemented): clicking will call maybe DELETE /receipts/id or a special endpoint /receipts/{id}/cancel. If success, update receipts state: mark that one as cancelled (could add a property in the object, or remove it if we prefer not showing cancelled by default). Possibly also fetch items to update stock or simply add stock back in state. For initial, can skip implementation. - If implemented, ensure only admin sees that button: perhaps the auth context has role info that we can use to conditionally show it. - Provide pagination if needed: if receipts > 50, either do manual pages or use some library. Initially, maybe just show all, trust that usage won't blow up. - UI: maybe color code cancelled receipts (if we do them) or add an "(מבוטל)" label. - תפריט וניווט משותף: - Create a component Navbar with links (a <nav> bar at top). Contains links: "קבלת ציוד", "ניהול פריטים", "היסטוריה", and "התנתקות". - Place Navbar in App above the <Outlet/> (so it shows on each protected page). Possibly hide it on login page (so in the Router config, wrap the protected routes in a layout that includes Navbar, exclude login route). - The logout link should onClick: clear token (auth context / localStorage), and navigate to "/login". Also possibly tell server to invalidate token if that was possible, but with JWT not easily; rely on expiry. - The Navbar can also show the username (auth context likely will store username from login, could decode from token or have gotten from login response maybe). - Styling: Use Bootstrap or Material UI to speed up styling: - If Bootstrap, install via npm and import CSS in main.tsx. Use classes like .container, .btn, .table for quick styling. - If Material UI, install packages and wrap App in ThemeProvider, etc, use their components (more heavy). - Could even do plain CSS, but libraries save time for layout. - For our case, maybe use simple Bootstrap for grids and forms. Alternatively, use the component library in MUI if comfortable. - Testing UI manually:* - Start the API and the React dev server. - Try logging in with wrong and right credentials. - After login, try adding an item, then issuing a receipt, etc. - Check if UI reflects changes (like stock decrement). - Try refresh page (should remain logged in if token stored – ensure App reads localStorage token on init and auto logs in). If not handling it, maybe do it. - Check navigation flows (go to history, back, etc). - Fix any obvious bugs. - At this point, we have a mostly working end-to-end skeleton.
שלב 5: בדיקות ותיקונים
- בדיקות יחידה (Backend): כתוב בדיקות עבור למשל: - פונקציית יצירת קבלה (אם מימשת למשל Service method separate from controller, אפשר לבדוק שהתוצאה מפחיתה מלאי נכון). - בדוק שאי אפשר להוציא יותר מלאי ממה שיש (simulate call). - בדוק שמחיקת פריט עם היסטוריה נחסמת. - בדוק אימות סיסמה Hash. - השתמש ב-InMemory DB או SQLite במצב זכרון בשביל בדיקות. - בדיקות אינטגרציה (Backend): אולי הפעלת ממש API עם WebApplicationFactory (ספרייה של ASP.NET core testing) וקיום קריאות HTTP לתוכו. זה יותר מאתגר אבל אפשר לכסות למשל תרחיש מלא: - הוסף משתמש, בצע login, בצע הוספת פריט, בצע הוצאת קבלה, אמת שהמלאי ירד. - תלוי בזמן, אולי לא חובה כעת. - בדיקות ידניות (Frontend): ערוך "Test script" ידני בו עוברים תרחישים: - תרחיש 1: הוספת פריט חדש -> יצירת קבלה עם הפריט -> בדיקת הופעה בהיסטוריה -> בדיקת עדכון מלאי. - תרחיש 2: ניסיון מחיקת פריט בשימוש -> ודא שמופיעה שגיאה ולא נמחק. - תרחיש 3: login כניסיון עם סיסמה שגויה -> שגיאה, ואז עם נכונה -> הצלחה. - תרחיש 4: two different roles if possible (simulate by making a normal user, ensure cannot see admin functions). - תיקון באגים: כל תקלה שהתגלתה – תקן בקוד, ובצע שוב את הבדיקות הרלוונטיות. - בדיקת עומס בסיסית: הכנס 50 פריטים, צור 100 קבלות (אפשר בסקריפט או בלולאה) – בדוק שההיסטוריה עדיין נטענת סביר והממשק מגיב. - UI פוליש: ודא שכל הטקסטים מיושרים וקריאים, תרגם כל מה שצריך לעברית. - אישור לקוח: להדגים למשתמש אמיתי (מחסנאי) את ה-flow על סביבת בדיקה ולראות שאין פערים נוספים.
שלב 6: פריסה (Deployment) והדרכה
(ייתכן מעבר לתכנית הפיתוח, אך נכלול להשלמת התמונה)
- הגדרת סביבת Production: לשקול יצירת Build פרודקשן: - Build ה-React (npm run build) כדי להוציא קבצי static. - לארח אותם או ב-Netlify, או להעתיק לתיקיית wwwroot ב-ASP.NET Core (אפשר להגיש React App מה-API אם רוצים solution אחד). - Compile ה-API ל-release. - קביעת host: אם ירוץ על מחשב בודד, אפשר להריץ כ-Console app קבוע או כשירות Windows. - וידוא הגדרות (connection string production path, JWT secret מוגדר). - בדיקות קבלה (UAT) עם המשתמשים בסביבה מדמה מציאות. - כתיבת מדריך למשתמש: להכין תיעוד למשתמשי הקצה (בעברית, קצר) כיצד להתחבר, להוסיף פריט, להוציא ציוד, לחפש היסטוריה וכו'. - Training: לבצע מפגש הדרכה קצר עם מחסנאי והצוות, לתרגל פעולה במערכת. - מעבר מבצעי: לקבוע יום החלפה שבו מתחילים להשתמש רק במערכת במקום ברישום ידני. לוודא שהמלאי ההתחלתי מוזן נכון.
חלוקה לגרסאות ביניים:
ייתכן שיהיו תתי-שלבים / גירסאות שניתן למסור באופן מדורג: - גרסה 0.1: רק התחברות + מסך קבלת ציוד (בלי עדכון מלאי אמיתי, רק רישום בסיסי). - גרסה 0.2: הוספת ניהול פריטים מלא. - גרסה 0.3: היסטוריה ותצוגות. - גרסה 0.9: כל הפונקציות + בדיקות + תיקונים. - גרסה 1.0: פריסה רשמית.
הדרוג מאפשר לבדוק כל חלק בנפרד: למשל, קודם לוודא שה-API והמודל תקין עם Postman, אז להמשיך לפרונטנד, וכך הלאה. לאורך הדרך נשתמש ב-Codex/AI כדי לייצר חלקי קוד על בסיס הפרומפטים (ראו נספח) מה שיזרז שלבים אך מצריך בדיקה ידנית בכל שלב.
7. החלטות טכנולוגיות מומלצות (סביבת Visual Studio)
בהתאם לדרישות הפרויקט ולאופי צוות הפיתוח, נבחרו הטכנולוגיות הבאות לפיתוח Bazap 2.0:
•	React עם Vite ו-TypeScript (Frontend): React נבחר כבסיס צד הלקוח בשל יכולתו לבנות ממשקים דינמיים ומודרניים, והקהילה הרחבה סביבו. שימוש ב-TypeScript יוסיף בדיקות סוג סטטיות, המונעות שגיאות נפוצות וייעלו את שיתוף הקוד עם ה-Backend (דרך הגדרת מבני נתונים דומים). החלטנו להשתמש ב-Vite כמנוע בנייה ופיתוח במקום Create React App מיושן, משום ש-Vite מהיר משמעותית ב-load ופשטות, ותומך היטב ב-TypeScript ו-Hot Reload למפתחים. הפיתוח יתבצע כנראה ב-VS Code (או WebStorm) המועדף לפיתוח Frontend, אך ניתן גם בעזרת Visual Studio אם מוגדר נכון (ל-Visual Studio יש אינטגרציה כלשהי עם פרויקטי npm, אך הרבה מפתחים יעדיפו כלי נפרד).
•	ASP.NET Core Web API (Backend): הצד שרת יפותח ב-ASP.NET Core 7/8, כחלק מ-solution ב-Visual Studio. טכנולוגיה זו נבחרה בשל הבשלות והיציבות שלה, הביצועים הגבוהים, וההתאמה שלה לעבודה עם מסדי נתונים דרך EF Core. בנוסף, לצוות הפיתוח יש ניסיון בסביבה זו (וכלים כמו Codex/Copilot מתמחים היטב בהשלמת קוד C#). Web API של ASP.NET Core מאפשר בניית RESTful endpoints בקלות, עם יכולות בילט-אין לאבטחה (JWT auth) ולוגיקות Middleware נדרשות. כמו כן, ניתן להרחיבו בעתיד לחיבור למערכות אחרות (למשל שילוב API עם מערכות צה"ליות, אם יהיה צורך).
•	Entity Framework Core + SQLite (ORM ומסד נתונים): בחרנו ב-Entity Framework Core כ-ORM כדי לקצר זמני פיתוח של שכבת הנתונים. EF Core מאפשר להגדיר את ה-Entities כמודלים C# ולהיות גמישים בשינויי סכימה דרך Migrations. הוא גם מתחבר טבעית למסד SQLite. למה SQLite?
•	SQLite הוא מסד נתונים מוטמע (embedded) בקובץ יחיד, אינו דורש התקנת שרת או תחזוקה מורכבת, וזה יתרון גדול בסביבה צבאית שבה ייתכן שאין DBA זמין או הרשאה להקים שרת SQL מלא.
•	SQLite מספק ביצועים טובים בנפחי מידע קטנים-בינוניים ומשתמש ב-DB file מקומי - מתאים לתרחיש שבו יש עמדת מחשב מחסן אחת או שתיים.
•	בהנחה שמספר המשתמשים אינו רב וכמות התנועות אינה עצומה, SQLite יספיק. במידה ובעתיד יוחלט על הרחבה (למשל שכל הבסיס ינהל יחד או חיבור מרחוק), המעבר ל-SQL Server יהיה פשוט יחסית: EF Core תומך בהחלפת Provider בקלות, והקוד ברובו יישאר זהה.
•	עוד שיקול: EF Core + SQLite מקלים מאוד על הקמת מסד בדיקות – אפשר אפילו להריץ SQLite בזיכרון בזמן unit tests.
•	הוחלט להשתמש ב-Code First approach, שבו הסכימה נוצרת מתוך קוד ה-C# (דבר ש-Codex יוכל לעזור בו גם).
•	Visual Studio 2022 (IDE): הפיתוח בעיקרו יבוצע ב-VS 2022 עבור ה-Backend. Visual Studio מוכר לנו ומכיל כלים מובנים לעבודה עם ASP.NET Core, ניפוי שגיאות (debugging), וניהול NuGet. כמו כן, ניתן להתקין את תוסף GitHub Copilot או להשתמש ב-Codex דרך ה-Visual Studio IntelliCode בעת כתיבת קוד. ל-Frontend, VS Code ישמש בעריכת React, אך גם ניתן לשלב build steps של npm דרך VS אם רוצים Debugging משולב.
•	שיקול: Visual Studio מאפשר גם פרויקט מסוג ASP.NET Core + React Template. אבל לרוב template זה משתמש ב-CRA ישן. במקום, העדפנו ליצור שני פרויקטים נפרדים ולנהל אותם יחד בסולושן או בנפרד.
•	יתרון VS הוא שאפשר להגדיר הפעלת multi-startup (API + CRA dev server יחד), אבל סביר שנריץ npm start ידנית.
•	שיקולי ספריות ותוספות:
•	ניהול State ב-React: הפרויקט קטן יחסית, נסתמך על useState/Context API. אין צורך ב-Redux או MobX עבור היקף זה, כדי לא לסבך.
•	UI Framework: כדי לחסוך זמן בעיצוב, נשקול שימוש ב-Bootstrap (למשל React-Bootstrap) או Material-UI (MUI) כדי לקבל קומפוננטות מוכנות לטפסים, טבלאות, כפתורים רספונסיביים וכו'. Bootstrap קל לשימוש (פשוט לכלול CSS ולהשתמש במחלקות), Material-UI מציע מראה מודרני אך עקומת לימוד. נוטה לבחירת React-Bootstrap או Ant Design (אם יש היכרות) בשל הפשטות.
•	אימות טפסים: אפשר ידנית עם תנאים (כפי שנתאר ל-Codex) או להיעזר בספרייה כמו Formik + Yup. ייתכן שמיותר לכאן, אז נישאר עם ולידציה ידנית.
•	Axios: לא חובה (fetch API יכול להספיק), אבל אפשר להשתמש ב-Axios לספק wrapper נח יותר לבקשות HTTP. כנראה נשתמש ב-Axios כי Copilot מכיר את הדפוסים שלו.
•	JWT decode: אם נרצה להוציא מידע מהטוקן (כמו role), אפשר להשתמש בספרייה jwt-decode. או פשוט לעשות endpoint "מי אני" שיחזיר פרטי משתמש.
•	Moment/Luxon: לעבודה עם תאריכים (המרה ותצוגה) - כנראה נשתמש ב-Intl מובנה או Date.prototype, אפשר ללא ספריות כבדות.
•	Logging: בצד שרת, ASP.NET Core כולל Logging Provider – נשתמש בו לרשום אירועים חשובים (לא חובה בשלב ראשון, אבל לפחות כניסה/שגיאות). בצד לקוח, אולי ננצל console.log לפיתוח, ואין צורך במשהו מורכב.
•	אבטחה וטכנולוגיה: JWT Bearer auth נבחר כמנגנון אימות כי הוא סטנדרטי. מאגר המשתמשים יהיה פשוט (טבלת Users). לחלופין יכולנו לשלב ASP.NET Identity Framework, אבל זה overkill למקרה עם 2-5 משתמשים. במקום, ניצור בעצמנו User table עם hash.
•	סיבת דחיית אלטרנטיבות:
•	ניתן היה להשתמש ב-Framework אחר ל-Frontend (Angular או Vue). React נבחר כי הוא גמיש, והצוות כנראה מכיר, וגם Vite-React נותן Quickstart.
•	לשפת Backend אחרת: אפשר היה Python/Flask או Node/Express, אבל הצוות מנוסה ב-C#, וכלי ה-AI (Codex) כנראה יתמודדו היטב עם .NET.
•	לגבי DB: אפשר היה MySQL/Postgres. כפי שנאמר, SQLite מספיק.
•	ORM: ניתן לכתוב SQL ידנית עם Dapper או ADO.NET, אך זה יאריך זמן, ו-EF Core כיום יעיל מספיק עבור צרכינו.
•	Hosting: ניתן להריץ על Linux container, אבל כנראה זה ירוץ על Windows environment של צה"ל. ASP.NET Core תואם לחלונות, ואפילו אפשר host באותו IIS אם רוצים (או כ-Service self-host).
•	מבחינת Deployment עתידי, אולי ישקלו Dockerize את זה – אבל בסביבה צבאית, ייתכן ועצם ההרצה על מחשב מקומי עדיפה ונגישה לצוות.
סיכום הטכנולוגיות: React+TS יתנו ממשק אינטראקטיבי ונוח למשתמש, ASP.NET Core+EF Core+SQLite מספקים גב יציב לאחסון ועיבוד נתונים, והכל בכלים חינמיים וקלי משקל יחסית. Visual Studio (יחד עם Codex) יאיץ מאוד את הכתיבה בשפות אלו. הבחירות האלו מאוזנות בין חדשנות (React Hooks, Vite) לבין בשלות (ASP.NET Core מטור-ארוך). הן גם מתאימות למשימה בהיקף קטן (אין microservices מיותרים, אין מורכבות Deployment – אפשר להסתפק באפליקציה יחידה).
8. הגדרת מודל הנתונים (Entities)
המודל הנתוני של המערכת "Bazap 2.0" מבוסס על מספר ישויות ליבה, המייצגות את המרכיבים המרכזיים בניהול ציוד במחסן: טבלת פריטים, טבלת קבלות (הוצאות ציוד), טבלת שורות קבלה (פריטים במסגרת כל קבלה), וכן טבלת משתמשים (לניהול ההרשאות). להלן פירוט היישויות, כולל השדות העיקריים, סוגי הנתונים וקשרי הגומלין ביניהן:
•	Item (פריט): מייצג סוג ציוד במלאי.
•	ItemID (מפתח ראשי, מסוג מספר שלם): מזהה ייחודי של הפריט.
•	Name (מחרוזת): שם הפריט, תיאורו הקצר. למשל: "מכשיר קשר מוטורולה". חייב להיות לא ריק.
•	Code (מחרוזת, ייחודי): קוד קטלוגי או מק"ט של הפריט. יכול להיות ספרות/אותיות שמזהות את הפריט בצורה מקוצרת. לדוגמה: "RFL-01" למכשיר קשר מדגם מסוים. זהו שדה אופציונלי, אך אם הוא מוזן הוא צריך להיות ייחודי במערכת (לא שני פריטים עם אותו Code).
•	QuantityInStock (מספר שלם): הכמות הנוכחית הזמינה במלאי מאותו פריט. ערך זה יתעדכן אוטומטית בכל הוצאת ציוד (קבלה) או עדכון ידני. יכול להיות 0 ומעלה. נתחיל מערך התחלתי (שנקבע כשמוסיפים פריט, או 0 אם לא צוין). אין ערכי כמות שליליים – המערכת לא אמורה לאפשר ירידה מתחת ל-0.
•	IsActive (בוליאני): דגל לסימון האם הפריט פעיל וזמין לחלוקה. ברירת מחדל True. אם מסומן False, המשמעות היא שהפריט לא זמין יותר (יצא משימוש או אזל לחלוטין), ואז המערכת יכולה לבחור לא להציגו ברשימות לבחירה. נתון זה מיועד יותר לניהול מערכת.
•	Relationships: לפריט יש קשר "אחד לרבים" עם ReceiptLine – כלומר, פריט יכול להופיע במספר שורות קבלה לאורך הזמן. בטבלת ReceiptLine תהיה עמודה ItemID כ-foreign key לטבלת Item. מחיקת פריט תוגבל אם יש שורות קבלה משויכות (ON DELETE RESTRICT). אך מחיקת ReceiptLine כן יכולה לקרות עם מחיקת Receipt (ON DELETE CASCADE) – ראו בהמשך.
•	Receipt (קבלה): מייצג אירוע מסירת ציוד (כלומר חייל שקיבל ציוד בזמן מסוים). זוהי ישות "ראש מסמך" שמאגדת מספר פריטים שניתנו באותו אירוע.
•	ReceiptID (מפתח ראשי, מספר שלם): מזהה ייחודי לכל קבלה. רץ באופן עוקב (auto-increment).
•	Date (Timestamp/DateTime): תאריך ושעת יצירת הקבלה. נקבע אוטומטית בעת שמירת הקבלה. נשמר בשדה DateTime במסד הנתונים (עם TimeZone או UTC – כנראה מקומי, אבל אפשר לשמור UTC).
•	ReceiverName (מחרוזת): שם מקבל הציוד. יכול לכלול שם מלא של החייל, או מזהה (למשל מספר אישי, תלוי מה נוח להזנה). המערכת לא שומרת טבלת חיילים, אז זה שדה טקסט חופשי. רצוי לאפשר טקסט עד 50-100 תווים (שם מלא).
•	UserID (מספר שלם, Foreign Key אל User): המזהה של המשתמש (מחסנאי) שרשם את הקבלה. זאת כדי לדעת מי ביצע את ההוצאה. מקשר לטבלת המשתמשים. (ייתכן ונחליט ש-userID לא חובה, אך עדיף כן).
•	IsCancelled (בוליאני, אופציונלי): שדה שמסמן אם הקבלה בוטלה. כברירת מחדל False (פעילה). אם קבלה בוטלה (מחיקה לוגית), נסמן True ובכך נדע לא לשכלל אותה במלאי/דוחות. (אפשר גם לא לממש בשלב ראשון, אך משאירים מרחב).
•	Relationships:
o	ל-Receipt יש קשר "אחד לרבים" עם ReceiptLine – קבלה אחת מכילה מספר שורות של פריטים. ReceiptLine תכיל Foreign Key ReceiptID. נגדיר Cascade Delete: כלומר אם נמחק Receipt, כל השורות המשויכות ימחקו אוטומטית. (לרוב לא נמחק בפועל אלא אולי ביטול לוגי, אבל טוב שהקשר מוגדר).
o	קשר "אחד לרבים" עם User – משתמש אחד (מחסנאי) יכול להיות יוצר של קבלות רבות. אם נמחק משתמש (לא סביר שנמחק, אולי נסמן כלא פעיל), נחליט האם למחוק גם קבלותיו? כנראה שלא – אז עדיף ON DELETE SET NULL או למנוע מחיקת User אם יש קבלות. נשמור שיקול זה.
o	אין קשר ישיר בין Receipt לפריט – הקשר הוא דרך ReceiptLine. אם רוצים אפשר לשמור Summaries (כמו total items count) אבל אפשר לחשב בעת הצורך.
•	ReceiptLine (שורת קבלה): מייצג את הצימוד בין פריט לכמות במסגרת קבלה מסוימת. במושגים אחרים, זוהי טבלת פירוט הפריטים בכל מסמך.
•	ReceiptLineID (מפתח ראשי, מספר שלם): מזהה שורה (אפשר גם Composite Key ReceiptID+ItemID, אבל לרוב עדיף מפתח יחיד מזהה).
•	ReceiptID (FK, מספר שלם): מזהה הקבלה אליה שייכת שורה זו.
•	ItemID (FK, מספר שלם): מזהה הפריט שסופק בשורה זו.
•	Quantity (מספר שלם): הכמות מהפריט שסופקה במסגרת הקבלה הזו. מספר חיובי (לפחות 1).
•	יתכנו שדות נוספים: למשל ItemNameSnapshot (אם רוצים לשמור את שם הפריט כפי שהיה אז – לא הכרחי אם כל שינוי שם נועד להתעדכן, אבל לפעמים עושים denormalization כדי שהיסטוריה לא תשתנה אם משנים שמות. נניח שלא נדרש).
•	Relationships:
o	ReceiptLine מקושר ל-Receipt (הרבה-ל-אחד). כפי שאמרנו, מחיקת Receipt גוררת מחיקת ReceiptLines שלו (Cascade).
o	ReceiptLine מקושר ל-Item (הרבה-ל-אחד). לא נגדיר Cascade פה (כי אז מחיקת Item תמחק גם את שורות ההיסטוריה, לא רצוי). נגדיר Restrict או No Action, כדי למנוע מחיקת Item בשימוש.
o	מבחינת Unique Index: אולי נגדיר Index ייחודי על ReceiptID+ItemID, כדי לא לאפשר כפילות של אותו Item פעמיים באותה קבלה (אם רוצים לאכוף ברמת DB בנוסף לקוד). זה אפשרי ורצוי.
o	ReceiptLine אינו צריך גישה ישירה בפני עצמה, אלא תמיד דרך Receipt לרוב.
•	User (משתמש): מייצג אדם בעל הרשאה לשימוש במערכת (מחסנאי או מנהל).
•	UserID (מפתח ראשי, מספר שלם).
•	Username (מחרוזת): שם משתמש ייחודי להתחברות (למשל "admin" או "supplyGuy").
•	PasswordHash (מחרוזת או Byte[]): סיסמה מוצפנת. אפשר לשמור Hex string של hash, או bytes. כנראה מחרוזת תספיק, עם למשל SHA256 או bcrypt.
•	Role (מחרוזת או Enum): תפקיד המשתמש, למשל "Admin" או "User". נוכל להגדיר Enum Role { Admin, User } בקוד.
•	IsActive (בוליאני): כדי לתמוך בחסימת גישה של משתמש (אם עזב תפקידו).
•	Relationships: כמו שצוין, User יכול להיות קשור לרבות Receipts שהוא יצר. לא נמחק משתמש אם יש לו היסטוריה, רק נשבית.
סכימת קשרים:
- Item : ReceiptLine = 1 : רבים.
- Receipt : ReceiptLine = 1 : רבים.
- User : Receipt = 1 : רבים.
ניתן לשרטט ERD מקוצר:

User (UserID PK) ---< Receipt (ReceiptID PK, UserID FK, ReceiverName, Date, ...) ---< ReceiptLine (ReceiptLineID PK, ReceiptID FK, ItemID FK, Quantity) >--- Item (ItemID PK, ...). 
כל "<" מייצג רבים מול 1. ReceiptLine מחבר בין Receipt ל-Item.
מפתחות ו Indexes:
- Primary keys כמפורט. - Index ייחודי על Item.Code (כדי למנוע כפילות קוד). - Index לא ייחודי על Item.Name אולי (לחיפושים אם יעשו). - Index על Receipt.Date (למיון/סינון מהיר לפי תאריכים). - Index על ReceiptLine.ItemID (לשליפות לפי פריט). - Index על User.Username (כי נבדוק זאת בהתחברות, ייחודי).
הערות נוספות:
- נתון ReceiverName הוא לא מנורמל (לא מקשר לטבלה אחרת). בהנחה שאין טבלת חיילים, זה הפתרון. אם בעתיד יבחרו, אפשר להוסיף טבלה Soldiers עם SoldierID, Name, וכו', ולקשר Receipt ל-SoldierID. כרגע, לא נדרש. - לגבי שדה PasswordHash: נניח שנשתמש ב-Hashing חיצוני (למשל Bcrypt) אז ייתכן שדיי לשמור מחרוזת ה-Hash כולל salt. - טבלת Audit (שינויים): לא נכלל כאן אך אפשר לשמור Log פעולות (כמו שינוי כמות ידני). כרגע נסתמך ש-userStories דורשים אחריות, אבל audit נוסף אפשרי עם EntityHistory. - טבלת קטגוריות (Category): אפשר לשייך פריטים לקטגוריה (למשל "תקשורת", "מחשוב"). הדרישה לא ציינה, אז נדלג. אם יהיה רצון, מוסיפים טבלת Category ו-Item.CategoryID. - יחידות מידה: אם יש פריטים שנספרים ביחידות שונות (למשל מטר כבל, או חבילות), לא צוין כלום. כנראה כולם כמספר שלם יחידות. - Multi-warehouse: לא רלוונטי עכשיו (multiple bases). - Relations enforcement: בקוד EF Core נגדיר Navigation Properties: - Item: ICollection<ReceiptLine> ReceiptLines. - Receipt: ICollection<ReceiptLine> Lines, User reference. - ReceiptLine: navigation to Item, to Receipt. - User: maybe ICollection<Receipt> Receipts.
בתכנון זה כיסינו את ישויות הליבה. המודל יחסית פשוט, מה שמקל על התחזוקה והפיתוח באמצעות EF Core.
9. קונבנציות API ודוגמאות Endpoints
ה-API של המערכת יפעל לפי עקרונות RESTful וישתמש בפרוטוקול HTTP במבנה סטנדרטי. כל המשאבים יוצגו בריבוי (Plural nouns), וניתן יהיה לבצע עליהם פעולות CRUD באמצעות Verbs מתאימים (GET, POST, PUT, DELETE). הנתונים יוחלפו בפורמט JSON. כמו כן, מאחר שהמערכת דורשת הזדהות, רוב הקריאות ידרשו כותרת Authorization עם טוקן (לאחר התחברות). נפרט את ה-End Points העיקריים ואת מבנה הבקשות/תשובות:
קונבנציות כלליות
•	URL בסיסי: ה-API יהיה זמין תחת כתובת בסיס (נניח http://<server>/api/). כל הנתיבים המפורטים בהמשך הם יחסיים ל/api/.
•	מבנה JSON: היישות המוחזרת תהיה באותו מבנה של המודל (DTO זהה לשם היישות, אלא אם צוין אחרת).
•	סטטוס קוד HTTP:
•	בקשת GET תקינה תחזיר 200 (OK) עם גוף הנתונים.
•	POST ליצירה תחזיר 201 (Created) עם Header "Location" pointing to the new resource (URI), וגוף התוכן יכול להכיל את הישות החדשה עם המזהה.
•	PUT/DELETE מוצלחים יחזירו 204 (No Content) אם אין תוכן, או 200 אם מחזירים את האובייקט המעודכן.
•	קריאות לא מורשות יחזירו 401 (Unauthorized), קריאות ללא הרשאה מתאימה (למשל משתמש רגיל לפעולת מנהל) יחזירו 403 (Forbidden).
•	נתון לא נמצא יחזיר 404 (Not Found).
•	ולידציה נכשלה (כגון קוד פריט כפול או שדות חסרים) תחזיר 400 (Bad Request) עם פרטי השגיאה.
•	אבטחה (Headers):
•	קריאות מוגנות דורשות Header: Authorization: Bearer <JWT_token>. השרת יבדוק את תקפות הטוקן בכל קריאה.
•	Cross-Origin: אם ה-Frontend על דומיין/פורט אחר, יוגדר CORS בשרת שיתיר Origins ספציפיים (כגון localhost:5173).
•	שמות שדות: יוחזרו בפורמט CamelCase ב-JSON (ברירת מחדל של Serializers ב-.NET Core), למשל quantityInStock, receiverName.
להלן רשימת Endpoints:
9.1 משאבי פריטים (Items)
•	GET /items – שליפת רשימת כל הפריטים.
Response: 200 OK. גוף: מערך JSON של אובייקטים, כל אחד מייצג פריט.
למשל תשובה:
 	[
  { "itemID": 1, "name": "מכשיר קשר RF-7800", "code": "RFL-01", "quantityInStock": 8, "isActive": true },
  { "itemID": 2, "name": "סוללה 12V", "code": "BTL-01", "quantityInStock": 18, "isActive": true },
  ...
]
 	רק משתמשים מחוברים (תפקיד User/Admin) יכולים לבצע. אם לא מחובר -> 401.
•	GET /items/{id} – שליפת פריט ספציפי לפי מזהה.
Response: אם נמצא: 200 OK, גוף JSON של הפריט. אם לא נמצא: 404.
דוגמה לתשובה מוצלחת:
 	{ "itemID": 1, "name": "מכשיר קשר RF-7800", "code": "RFL-01", "quantityInStock": 8, "isActive": true }
•	POST /items – הוספת פריט חדש.
Request: גוף JSON עם פרטי הפריט (ללא ID, שייווצר ע"י המערכת). למשל:
 	{ "name": "קסדת קשר", "code": "HDR-02", "quantityInStock": 5 }
 	(אפשר לכלול isActive אבל לא חובה, נניח ברירת מחדל true).
Response:
•	במצב תקין: 201 Created. Header "Location: /api/items/{newId}". גוף: ניתן להחזיר את האובייקט שנוצר עם ה-ID. למשל:
 	{ "itemID": 7, "name": "קסדת קשר", "code": "HDR-02", "quantityInStock": 5, "isActive": true }
•	שגיאות אפשריות: אם name ריק או code כפול -> 400 עם הודעה מתאימה.
•	הרשאות: פעולה זו מותרת רק למנהל (Admin). אם משתמש רגיל ינסה, יחזור 403 Forbidden.
•	PUT /items/{id} – עדכון פריט קיים.
Request: גוף JSON עם השדות לעדכון (אפשר לשלוח את כל האובייקט). למשל, לביצוע עדכון שם וכמות:
 	{ "itemID": 2, "name": "סוללה 12V", "code": "BTL-01", "quantityInStock": 30, "isActive": true }
 	(ה-ID ב-URL מגדיר את המשאב המתעדכן, ID בגוף לא הכרחי).
Response:
•	הצלחה: 200 OK (או 204) עם האובייקט המעודכן כ-JSON.
•	400 Bad Request אם הפריט לא קיים (אפשר גם 404). לרוב נעשה: אם id לא נמצא -> 404; אם נמצא אבל גוף לא תקין -> 400.
•	אם מנסים לשנות Code לערך שכבר בשימוש בפריט אחר -> 400 עם error "Code must be unique".
•	הרשאה: רק Admin או משתמש שהוחלט שמותר לו. סביר שנגביל ל-Admin.
•	DELETE /items/{id} – מחיקת פריט.
Response:
•	204 No Content אם נמחק (אין גוף).
•	אם הפריט לא נמצא -> 404.
•	אם הפריט קשור לקבלות קיימות -> 400 Bad Request או 409 Conflict, וגוף:
 	{ "error": "Cannot delete item, it has associated receipts." }
 	(החלטנו לא למחוק אם בשימוש; ההודעה תודיע למשתמש אולי לסמן כלא פעיל).
•	הרשאה: Admin בלבד.
9.2 משאבי קבלות (Receipts)
•	GET /receipts – שליפת רשימת כל הקבלות (או אולי אחרונות).
Response: 200 OK. גוף: מערך של קבלות. כדי להקל, כנראה יוחזרו קבלות עם שורות מקוננות או תקציר?
שתי גישות:
•	להחזיר קבלות כולל תוכן מלא של השורות בכל קבלה (אובייקט קבלה יכיל למשל lines: [ {...}, {...} ]). זה נוח כי קריאה אחת מספקת הכל, אבל מעביר יותר מידע, אולי בסדר.
•	להחזיר רק רמת Receipt ללא פירוט, ובפירוט להשתמש בGET יחיד. אפשר לבחור באפשרות הראשונה לטובת פשטות (במיוחד שהכמות לא גדולה).
פורמט מוצע:
 	[
  {
    "receiptID": 15,
    "date": "2026-01-20T13:45:30Z",
    "receiverName": "רן כהן",
    "userID": 1,
    "lines": [
      { "receiptLineID": 30, "itemID": 1, "quantity": 1, "item": { "name": "מכשיר קשר RF-7800", "code": "RFL-01" } },
      { "receiptLineID": 31, "itemID": 3, "quantity": 2, "item": { "name": "סוללה 12V", "code": "BTL-01" } }
    ]
  },
  { ... },
  ...
]
 	כאן לכל שורה גם מקונן אובייקט פריט עם שם/קוד (לנוחות תצוגה, אפשר גם להביא רק itemID ואז הלקוח ישתמש ברשימת items אם יש). זה לשיקול המפתח – אפשר לחסוך נתונים ולהחזיר רק IDs. אבל אפשר גם לכלול, זה נפוץ ב-REST להביא מקונן.
•	אם הרשימה גדולה, אפשר להטמיע פרמטרים: /receipts?from=2026-01-01&to=2026-01-31 או ?itemId=5 וכו'. אפשר לממש אם יש זמן. אם לא, הלקוח יכול לסנן מקומי.
•	הרשאה: כנראה כל משתמש מחובר יכול לצפות (מחסנאי ומעלה). אם רוצים, אפשר לשקול שמחסנאי פשוט יראה גם, כי אין נזק בצפייה.
•	401 אם לא מחובר.
•	GET /receipts/{id} – שליפת קבלה מסוימת בפירוט מלא.
Response: 200 OK אם נמצא, 404 אם לא. גוף JSON:
 	{
  "receiptID": 15,
  "date": "2026-01-20T13:45:30Z",
  "receiverName": "רן כהן",
  "user": { "userID": 1, "username": "admin" },
  "lines": [
    { "receiptLineID": 30, "item": { "itemID": 1, "name": "מכשיר קשר RF-7800", "code": "RFL-01" }, "quantity": 1 },
    { "receiptLineID": 31, "item": { "itemID": 3, "name": "סוללה 12V", "code": "BTL-01" }, "quantity": 2 }
  ]
}
 	זה דומה לפורמט הקודם אך למשל כולל userinfo מקונן.
•	הרשאה: כנ"ל, כל מחובר.
•	POST /receipts – יצירת קבלה חדשה (תיעוד הוצאת ציוד).
Request: JSON המתאר את הקבלה. לדוגמה:
 	{
  "receiverName": "רן כהן",
  "lines": [
    { "itemID": 1, "quantity": 1 },
    { "itemID": 3, "quantity": 2 }
  ]
}
 	(את ה-userID או date לא נספק – השרת יקבע אותם מההקשר). Response:
•	הצלחה: 201 Created. Location header /api/receipts/15. ייתכן גוף עם פרטי הקבלה החדשה (כולל ID ושדות מחושבים). למשל:
 	{
  "receiptID": 15,
  "date": "2026-01-20T13:45:30Z",
  "receiverName": "רן כהן",
  "userID": 1,
  "lines": [
    { "receiptLineID": 30, "itemID": 1, "quantity": 1 },
    { "receiptLineID": 31, "itemID": 3, "quantity": 2 }
  ]
}
 	(כאן אפשר לכלול גם שם הפריט אם רוצים בנוחות, אבל מכיוון שכבר כנראה הלקוח יודע מה שלח, לא חייב. גם אפשר להחזיר full details).
•	שגיאות (400 Bad Request) אפשריות:
o	אם receiverName חסר או ריק – הודעת שגיאה "ReceiverName is required".
o	אם lines ריק או חסר – "Must include at least one item line".
o	אם itemID שאחד ה-lines לא קיים במסד – אפשר 400 "Item with ID X not found". (או 404, אבל 404 לרוב מתייחס למשאב הראשי, כאן עדיף 400 עם פרט).
o	אם quantity <= 0 – 400 "Quantity must be positive".
o	אם אין מלאי מספיק ואנחנו מחליטים לחסום – 400 "Not enough stock for item X (requested 5, available 3)".
•	בעת הצלחה, השרת מבצע: מוריד מהמלאי, שומר שורות, וכו'.
•	הרשאה: רק משתמשים מחוברים. (מחסנאי רגיל יכול לבצע). אם ממש רצו, יכלו לדרוש שרק משתמש תפקיד מסוים יכול, אבל למעשה מחסנאי זה התפקיד הרלוונטי בכל מקרה.
•	DELETE /receipts/{id} – (אופציונלי) ביטול/מחיקת קבלה. הערה: ייתכן ולא נממש בתחילה. אם כן: Response:
•	204 אם בוצע (אז המלאי יוחזר ע"י השרת).
•	404 אם הקבלה לא קיימת.
•	אם לא מרשים למחוק קבלות (בגלל audit) אז endpoint זה יכול להיות לא זמין (יחזיר 405 Method Not Allowed).
•	הרשאה: רק מנהל אולי.
•	PUT /receipts/{id} – (כנראה לא ניישם) עריכת קבלה קיימת. לרוב לא נהוג לערוך היסטוריית קבלות אחרי העובדה, חוץ מביטול. אפשר לוותר.
•	נקודות קצה סינון: (אופציונלי)
•	GET /receipts?itemId=5 – להחזיר קבלות המכילות את הפריט הזה (יצטרך join פנימי, אפשרי).
•	GET /receipts?from=2026-01-01&to=2026-01-31 – סינון לפי תאריכים.
•	GET /receipts?receiverName=רן – חיפוש לפי שם.
•	דברים כאלו אפשריים, אך אפשר גם לבצע בצד לקוח כפי שנאמר. אם הזמן לחוץ, נשמיט.
•	Pagination: ?page=2&pageSize=50.
9.3 משאבי משתמשים והתחברות (Auth & Users)
•	POST /auth/login – אימות משתמש וקבלת JWT.
Request: גוף JSON:
 	{ "username": "bazapAdmin", "password": "P@ssw0rd123" }
 	Response:
•	200 OK אם הצליח. הגוף:
 	{ "token": "<JWT_TOKEN_STRING>", "user": { "userID": 1, "username": "bazapAdmin", "role": "Admin" } }
 	הטוקן הינו מחרוזת JWT. בנוסף, אפשר להחזיר קצת מפרטי המשתמש בשביל שהלקוח ידע (למשל role).
•	401 Unauthorized אם נכשל (לא לתת יותר מדי פרטים, רק "Invalid credentials").
•	המערכת תיצור JWT עם claims: sub=username או userid, role, exp (תוקף). חתום עם מפתח שרת (SymmetricKey). תוקף אפשר להגדיר – נניח שעה או שעתיים, או 1 יום.
•	לאחר קבלת הטוקן, הלקוח ישמור וישלח אותו כ-Bearer.
•	הערה: התקשורת בד"כ צריכה להיות ב-HTTPS כדי שהסיסמה והטוקן לא ייחשפו. בסביבה פנימית, אפשר גם HTTP אם זו רשת סגורה, אך לאבטחה מיטבית לפחות הסיסמה... בכל אופן, נניח שזה בטוח מספיק.
•	POST /auth/logout – (לא תמיד צריך)
•	אם משתמשים ב-JWT Stateless, אין מנגנון צד שרת אמיתי (אפשר למחוק token ברשימה שחורה אבל לא חייב).
•	אפשר פשוט שבצד לקוח ימחק.
•	אז כנראה לא נממש endpoint logout.
•	GET /auth/me – (אופציונלי)
•	Endpoint כדי לקבל את פרטי המשתמש הנוכחי לפי הטוקן, במקום לכלול אותם בלוגין.
•	אם נממש, הוא יחזיר user info כמו ב-login.
•	לא חובה.
•	ניהול משתמשים (אופציונלי):
•	GET /users (Admin only) – רשימת משתמשים.
•	POST /users – יצירת משתמש חדש (admin יוכל להוסיף מחסנאי נוסף). הגוף: {username, password, role}. התגובה: 201 user obj (ללא סיסמה).
•	PUT /users/{id} – שינוי (למשל תפקיד או איפוס סיסמה).
•	DELETE /users/{id} – מחיקה (אולי לא לאפשר אם יש פעילות).
•	לא נדרש כעת, אבל כזה ניתן להוסיף בעתיד.
9.4 דוגמת תרחיש API מלא
תרחיש: יצירת קבלה חדשה ובדיקה שהיא מופיעה בהיסטוריה: 1. לקוח (אפליקציית React) מבצע login: - שליחה: POST /api/auth/login עם user+pass. - קבלה: 200, token="abc.xyz.123". 2. הלקוח טוען את רשימת הפריטים: - שליחה: GET /api/items (עם Authorization Bearer token). - קבלה: [ {item1}, {item2}, ... ] (למשל 5 פריטים). 3. המשתמש ממלא טופס ומבקש לשמור קבלה: - שליחה: POST /api/receipts עם:
{
  "receiverName": "יוסי לוי",
  "lines": [
    { "itemID": 2, "quantity": 1 },
    { "itemID": 5, "quantity": 3 }
  ]
}
- בקשה זו כוללת Header Authorization: Bearer <token>. - השרת בודק את ה-token (תקף?), מוצא userId ממנו. - השרת מאמת: itemID 2 ו-5 קיימים? יש stock? - השרת מפחית: נניח item 2 היה 10 -> יהפוך 9, item 5 היה 5 -> יהפוך 2. - השרת שומר Receipt newID=16, עם ReceiptLines שנוצרו. - תגובת השרת: 201 Created, Location: /api/receipts/16, Body:
{
  "receiptID": 16,
  "date": "2026-01-21T10:15:00Z",
  "receiverName": "יוסי לוי",
  "userID": 1,
  "lines": [
    { "receiptLineID": 40, "itemID": 2, "quantity": 1 },
    { "receiptLineID": 41, "itemID": 5, "quantity": 3 }
  ]
}
4. כעת הלקוח יכול: - או לסמוך על התשובה שהכל הצליח ולהראות הודעה למשתמש. - וגם כדאי לעדכן את ה-state של items: להפחית את stock item2 ו-5. - וכן אולי להוסיף את הרשומה להיסטוריה מקומית (או למשוך טרי). 5. אם הלקוח עובר למסך היסטוריה: - שליחה: GET /api/receipts (Authorization). - השרת מחזיר JSON array כולל הקבלה החדשה. - הלקוח מציג אותה.
הערה על שגיאות: נניח שבשלב 3, item 5 רק 2 היו במלאי אך ביקשו 3. - בהחלטה שניישם מניעת, השרת היה מחזיר 400:
{ "error": "Not enough stock for itemID 5 (requested 3, available 2)" }
הלקוח היה אז מראה למשתמש "לא מספיק במלאי עבור פריט X". - אם הוחלט לאפשר שלילי, אז הקבלה הייתה עוברת והstock יוצא שלילי, אבל עדיף שלא.
תמיכה במידע נוסף: - ייתכן שנרצה API לבדיקת stock: אבל GET /items כבר נותן. - אולי API לסטטיסטיקות? לא כרגע. - Heath-check: /api/health למשל, לא קריטי.
סיכום: ה-API תוכנן להיות פשוט, אינטואיטיבי, ועוקב כללי REST. כך גם כלי פיתוח סטנדרטיים ואפילו Codex יבינו אותו בקלות. השמות והמבנים תואמים לאובייקטי המודל, מה שמקל על serialization אוטומטי ב-ASP.NET Core (System.Text.Json יטפל).
10. בדיקות נדרשות ותנאי הצלחה
הצלחת הפרויקט תלויה בביצוע בדיקות איכות קפדניות שמכסות את כלל רכיבי המערכת: צד שרת (Backend), צד לקוח (Frontend/UI), שילוב מלא (End-to-End), ובדיקות לא תפקודיות. להלן פירוט סוגי הבדיקות הנדרשים ותנאי הקבלה שמגדירים מתי המערכת מוכנה לפריסה:
בדיקות צד שרת (Backend QA)
•	בדיקות יחידה (Unit Tests):
•	לבדוק לוגיקות עסקיות מרכזיות בפונקציות ה-API. למשל:
o	פונקציה להפחתת מלאי בעת יצירת קבלה: הזן נתוני קבלה (mock context עם item בכמות ידועה), הפעל, וודא שהכמות במלאי ירדה נכון. גם בדוק מקרי קצה: בדיוק שווה לכמות -> נשאר 0, מעל הכמות -> נגמר שלילי (אם מתירים, או שמונעים).
o	פונקציית אימות סיסמה: given סיסמה נכונה ושגויה, verify שה-hash משווה נכון/לא נכון.
o	ולידטורים: למשל, פונקציה שבודקת ValidateNewItem(item) מחזירה false אם name ריק או code תפוס.
o	בדיקת מחיקת פריט: ודא ש-DeleteItem מונעת מחיקה אם יש קבלות (מדמה context עם ReceiptLine).
•	נשתמש במסגרת xUnit/NUnit. ניצור doubles (אובייקטי context in-memory) או Services מבודדים.
•	תנאי הצלחה: כל בדיקות היחידה עוברות (ירוק) ואין régression בעת שינויים.
•	בדיקות אינטגרציה (Integration Tests):
•	בדיקות API end-to-end ללא UI: להרים את שרת ה-Web API בתצורת test (יכול להיות ע"י WebApplicationFactory של ASP.NET) ולשלוח בקשות HTTP אמיתיות אליו, לבדוק תגובות.
o	תרחיש: בצע POST /items, אחר כך GET /items לוודא שהפריט נוסף.
o	תרחיש: הוסף פריט, בצע POST /receipts עם הפריט, קבל 201, בצע GET /items לראות שהכמות ירדה.
o	תרחיש: נסה פעולה לא מורשית (ללא טוקן) וודא מקבלים 401.
o	תרחיש: צור משתמש רגיל, עשה login, נסה DELETE /items – מצופה 403.
•	בדיקות Data Access: ניתן גם לבחון את EF context:
o	להכניס נתונים, לשמור, ואז לקרוא ולוודא הקשרים (Receipt -> lines -> item) פועלים, וכו'.
o	בדוק ש-Cascade Delete Receipt מוחק Lines.
•	תנאי הצלחה: מקרי השימוש המרכזיים דרך API פועלים כמצופה. כל שילוב בין קריאות מוביל למצב נתונים תקין (אין שחיתות בנתונים: מלאי אף פעם לא שלילי, לא קיימות קבלות יתומות ללא lines או lines ללא קבלה וכדומה).
•	בדיקות ביצועים (Performance) – Backend:
•	בדיקה שה-API מגיב במהירות סבירה תחת עומס צפוי:
o	עומס צפוי אינו רב (יחידה קטנה), אך נניח נריץ 1000 בקשות GET /items עוקבות, הן אמורות לענות תוך כמה עשרות מילישניות כל אחת.
o	הכנסת 100 קבלות ברצף – השרת צריך לעמוד בכך בלי שגיאות, ובסוף הנתונים נכונים.
•	בדיקת זליגות: באמצעות כלי Profiler לבדוק שאין memory leaks (EF משחרר context וכו').
•	תנאי הצלחה: זמני תגובה ממוצעים < 0.5 שניות לפעולה רגילה. המערכת יכולה להתמודד עם לפחות 5 משתמשים בו זמנית בלי קריסה (אפילו שזה מעבר לנדרש, אבל נבדוק concurrency בסיסי עם JMeter או פשוט ריצות מקבילות).
•	בדיקות אבטחה (Security Tests):
•	ניסיון לגשת למשאבים ללא JWT – להבטיח 401.
•	ניסיון להשתמש ב-JWT שפג תוקפו – 401 (אם נבחן expiry).
•	ניסיונות תוכן זדוני: למשל SQL injection לא רלוונטי פה כי EF parametrized, אבל אולי XSS:
o	אם מזינים שם חייל "<script>alert(1)</script>", בדוק מה קורה ב-UI (צריך להופיע כטקסט, React כבר עושה escape, אז סביר בסדר).
•	סיסמאות: בדוק שלא מוחזרות אף פעם בממשק (אפילו ב-GET /users admin, אם יעשו, צריך להחסיר או להחזיר null).
•	תנאי הצלחה: המערכת אינה חושפת מידע ללא auth, נתונים מוזנים לא מתפרשים כקוד בדפדפן, אין דרך לעקוף הרשאות (לדוגמה, משתמש רגיל לא מצליח למחוק פריט אפילו אם ינסה API ישיר).
בדיקות צד לקוח (Frontend & UI)
•	בדיקות ממשק משתמש (UI/UX):
•	בדיקות ידניות: מישהו מצוות הבדיקות יעבור על התרחישים:
a.	תרחיש בסיסי: התחבר כמנהל -> הוסף פריט -> צא -> התחבר כמשתמש -> ראה שהפריט קיים.
b.	הוצא קבלה לחייל -> בדוק שהמלאי התעדכן (למשל אם UI מציג מלאי איפשהו או דרך ניהול פריטים). בדוק שהקבלה נראית בהיסטוריה.
c.	נסה להוסיף קבלה ללא שם מקבל -> ודא שהכפתור שמירה כבוי או שמופיעה שגיאה "יש למלא שם מקבל".
d.	נסה להוסיף קבלה ללא פריטים (לא ללחוץ הוסף אף פריט) -> כפתור שמירה אפור ולא מגיב או מציג שגיאה.
e.	נסה להכניס בטופס כמות 0 -> מצופה שהשדה עצמו לא יקבל (min=1) או שתופיע שגיאה.
f.	במסך ניהול פריטים: נסה להוסיף פריט בלי שם -> כפתור שמירה מושבת או שגיאה. נסה קוד כפול -> אמורה להופיע שגיאת backend, בדוק שהיא מוצגת למשתמש.
g.	ערוך פריט -> ודא שהשינוי נראה גם במסך קבלת ציוד (למשל שנו שם פריט, גשו לטופס קבלה, הרשימה צריכה להכיל את השם החדש).
h.	מחק פריט שאין לו היסטוריה -> הפריט נעלם מהרשימה.
i.	מחק פריט עם היסטוריה (אפשר להכין אחד ע"י יצירת קבלה) -> אמורה להופיע הודעת שגיאה, והרשומה נותרת (או היא לא ברשימה? אם מסמנים לא פעיל, ודא שמוצגת כאינה פעילה).
j.	היסטוריה:
	צור מספר קבלות, כנס למסך היסטוריה -> וודא שהרשימה מלאה ונכונה.
	נסה חיפוש: הקלד שם חייל קיים -> הרשימה מסתננת כמו שצריך. חפש שם פריט -> אם מימשנו סינון, ודא שעובד.
	סינון תאריך: שים טווח שלא כולל כלום -> קבל "לא נמצאו".
	בדוק שעבור קבלה שבוטלה (אם יש) מסומנת בבירור.
k.	בדיקת ניווט:
	התנתק: לאחר לחיצה על "התנתק", וודא שנזרק למסך login ושאי אפשר לחזור אחורה לוגית (אם לוחצים back, אולי רואים דף אבל ללא נתונים? תלוי מימוש).
	רענן דף באמצע: למשל, אתה במסך היסטוריה ויש טוקן בלוקאלסטורג', רענן – ודא שהאפליקציה מזהה שאתה מחובר וטוענת נתונים (לא מעיפה ל-login פתאום).
	גש ל-URL של /items בלי להתחבר -> האפליקציה כנראה מנותבת ל/login (simulate by open new incognito at /items).
l.	UI כללי:
	ודא שהכל בעברית, ללא טקסט לועזי מיותר (למעט אולי placeholders).
	בדוק על רזולוציות שונות: מחשב (1920px), מסך קטן (laptop 1366px) ואולי טאבלט/נייד (אם responsive). התפריט והטבלאות צריכות להסתדר (ייתכן overflow scroll).
	בדוק שהכפתורים/שדות נגישים (tab order, labels) – לפחות מינימלית.
	בדוק נוחות: למשל, אחרי שמירת קבלה, הטופס מתאפס -> הדגש צריך לחזור לשדה "מקבל" כדי שאפשר להתחיל ישר חדשה, האם זה קורה? אם לא, אולי כדאי (UX).
•	בדיקות Cross-browser: נסה ב-Chrome, Firefox. אולי Edge. צריך לוודא שהשפה RTL מוצגת נכון, שכל הפונטים נטענים. כנראה בסדר כי React/Bootstrap תקניים.
•	בדיקות אוטומציה UI (Optional): אפשר לשקול tests עם Selenium or Puppeteer:
o	למשל, להריץ סקריפט שפותח דפדפן, נכנס לlogin (ממלא שדות, לוחץ), דורס UI (מוסיף פריט וכו'), ומוודא אלמנטים מסוימים קיימים.
o	זה דורש השקעה, אפשר רק אם זמן. כנראה נסתפק בידני.
•	בדיקות תאימות ותקלות UI:
•	הזנת נתונים חריגים:
o	שמות מאוד ארוכים (100 תווים) – לוודא שלא שוברים את העיצוב בטבלה (אולי יחתכו, זה בסדר).
o	תווים בעברית/אנגלית/מספרים – לוודא שכולם מתקבלים (UTF-8, כן).
o	Emoji? כנראה לא צריך, אבל המערכת תומכת כי Unicode.
•	סימון שדות חובה: ודא ששדות חובה מסומנים אולי בכוכבית או שיש הסבר. אם לא, ודא שיש שגיאה בהיעדרם.
•	עומס נתונים: אם 100 פריטים במלאי, רשימת הבחירה ארוכה – עדיין עובדת (אולי שקול search box).
•	אם 100 קבלות, עמוד היסטוריה – האם נגלל? יש פג'ינציה? אם לא, רשימה ארוכה עדיין נגישה בגלילה.
•	תנאי הצלחה UI: חוויה תקינה – המשתמשים קיבלו הדרכה קצרה ומצליחים לבצע את תרחישי העבודה שלהם בלי תקלות או בלבול רב. במפגש קבלה, המחסנאי אמור לומר שזה משפר לו משמעותית. ממשקי שגיאה צריכים להיות מובנים (לא הודעות גנריות או באנגלית).
תנאי הצלחת המערכת (User Acceptance Criteria)
לאחר שכל הבדיקות הנ"ל עברו, מגדירים את קריטריוני הקבלה העיקריים מצד הלקוח (יחידת התקשוב):
•	פונקציונליות מלאה בהתאם לאפיון: כל הסעיפים 1-9 במסמך זה מיושמים או הוסכמו כשינויים. בפרט, המשתמש יכול:
•	להוסיף פריטים חדשים, לעדכן אותם, ולצפות במלאי הנוכחי.
•	לבצע רישום מהיר של קבלת ציוד לחייל, כולל ריבוי פריטים, עם מניעת טעויות הזנה.
•	לצפות בכל קבלות העבר עם יכולת חיפוש/סינון בסיסית.
•	להתחבר בצורה מאובטחת ולראות שרק הוא יכול לבצע פעולותיו.
•	(אם מנהל) לבצע פעולות ניהול נוספות כמו מחיקת פריט או ביטול קבלה, בהתאם למדיניות.
•	דיוק הנתונים: המערכת שומרת על עקביות פנימית:
•	ספירת המלאי נכונה בכל רגע בהשוואה לפעולות שנעשו. (נבדוק: אחרי סדרת פעולות, האם QuantityInStock של כל פריט = initial + manual adds - sum(issued)? צריך להתאים).
•	היסטוריית הקבלות משקפת במדויק את מה שבוצע, ללא כפילויות או חסרים.
•	אין "רעילות" של נתונים: למשל, שדות טקסט מציגים בדיוק את שהוזן (מלבד escapes), שדות זמן נכונים (לא הופעת GMT במקום מקומי בלי ידיעה – אולי צריך להציג קבלה בזמן מקומי ע"פ TimeZone).
•	שביעות רצון המשתמש הסופי:
•	המחסנאי מדווח שהמערכת מהירה יותר מהקיים: לדוגמה, רישום קבלה שנמשך בעבר 2-3 דקות מתקצר לכ-30 שניות או פחות. (זו הערכה, ניתן למדוד: קח 5 חיילים, תן ציוד עם המערכת – סיים תוך זמן סביר וללא טעויות).
•	הפחתת טעויות: אחרי תקופת ניסיון, הם רואים שאין טעויות הקלדה כי השדות קבועים; הכפילות נעלמה – אין יותר צורך לתקן רשומות בדיעבד.
•	המפקדים מרוצים שיכולים לקבל דוח מיידי – למשל, לבקש "תראה לי מה חולק בחודש האחרון" והמחסנאי יכול לסנן בהיסטוריה או לייצא ולשלוח.
•	ביצועים וקיבולת:
•	המערכת אמורה לפעול באופן חלק על מחשב הייעודי (נניח PC של המחסן). אם היא SPA בדפדפן, שתטען במהירות (תוך <5 שניות מהקלדת כתובת, אם כבר מופעל שרת).
•	כל פעולה בתוך המערכת (שמירת טופס, טעינת רשימה) מתבצעת כמעט מיד. למשל, טעינת רשימת הפריטים (< 1 sec, אלא אם מאות פריטים, אז אולי 1-2 sec), שמירת קבלה (< 1 sec, כי כתיבה מקומית).
•	המערכת יכולה לתמוך ב-נפח הנתונים הצפוי: נניח כ-100 סוגי פריטים ו-1000 קבלות בשנה. בדקנו עם 1000 קבלות – היסטוריה עדיין עובדת. If needed, we consider adding pagination if approach limit.
•	נגישות תחזוקה:
•	צוות הפיתוח (או המתחזק העתידי) צריך למצוא את הקוד קריא ומודולרי, עם תיעוד (פנימי בקוד או חיצוני).
•	בדיקות: suite הבדיקות האוטומטיות עובר.
•	ה-README/מסמך פריסה מוכן כדי שהם ידעו איך להתקין/להפעיל.
•	אם עולות דרישות חדשות (למשל "תוסיפו שדה X"), המערכת בנויה בצורה שמאפשרת זאת בלי שכתוב ענק.
•	תאימות לתקנים: אם יש תקני צה"ל (כמו אי שימוש בענן), זה מתקיים. SQLite ושאר הכלים – On-prem.
•	אולי לוודא שהאפליקציה עובדת גם ללא אינטרנט (מצב אופליין: אם השרת והלקוח על מחשב ללא אינטרנט, רק רשת מקומית, זה אמור לעבוד).
רק כאשר כל הפרמטרים לעיל מתקיימים ומאושרים על ידי נציגי יחידת התקשוב (הלקוח), נוכל לומר שהפרויקט הצליח וניתן להטמעה מבצעית.
כמובן, תהליך המסירה ילווה בתקופת הרצה, במהלכה יתגלו אולי עוד פערים קטנים ויתוקנו. אך ההגדרה ל"הצלחה" היא שהמערכת משמשת בפועל את המחסנאי בתרחישי היום-יום ומביאה את היתרונות שרצינו (מהירות ודיוק), ללא צורך לחזור לתהליך הישן.
11. Seed Data לדוגמה (נתוני בדיקה והדגמה)
בכדי לוודא את תקינות המערכת ולסייע בהדגמה מהירה למשתמשים, נכון להכין נתוני דוגמה התחלתייים (Seed). נתונים אלו ייטענו למסד הנתונים (SQLite) בעת ההפעלה הראשונה של המערכת, ויאפשרו לסביבת הפיתוח/בדיקות לעלות עם מידע מיידי. נציג כאן סט נתונים לדוגמה: רשימת פריטים, משתמשים, ואולי גם קבלות לדוגמה, המשקפים את סביבת גדוד 388.
משתמשים (Users) – Seed: - משתמש מנהל (Admin): - Username: admin - Password: Admin!123 (בפועל יישמר כ-hash, למשל של "Admin!123"). - Role: Admin
- תיאור: משתמש זה ישמש לניהול ראשוני, בעל הרשאות מלאות. - משתמש מחסנאי (רגיל): - Username: supply1 - Password: Supply!123 - Role: User
- תיאור: מחסנאי מן השורה המבצע את מרבית הפעולות היומיומיות.
(הסיסמאות הנ"ל הן לדוגמה. יש ליידע להחליפן עם העלייה לאוויר ולבחור סיסמאות חזקות).
פריטי מלאי (Items) – Seed: נניח שברשות המחסן מספר סוגי ציוד תקשורתי/מחשובי. נגדיר כמה: 1. מכשיר קשר Motorolla RF-7800 –
- Code: RFL-01
- QuantityInStock: 10 יח'.
- תיאור: מכשיר קשר ראשי של הגדוד.
2. בטרייה 12V למכשיר קשר –
- Code: BTL-01
- QuantityInStock: 20 יח'.
- תיאור: סוללות גיבוי למכשירי קשר.
3. קסדת קשר (דיבורית ראש) –
- Code: HDR-01
- QuantityInStock: 5 יח'.
- תיאור: אוזניות+מיקרופון לקשר.
4. מחשב נייד "Toughbook" –
- Code: LPT-01
- QuantityInStock: 3 יח'.
- תיאור: מחשבים מוקשחים המשמשים את הקשר"ג.
5. נתב תקשורת "Cisco 2600" –
- Code: RTR-01
- QuantityInStock: 2 יח'.
- תיאור: ראוטר נייד לפריסת רשת מחשבים.
6. כבל רשת CAT6 (5 מטר) –
- Code: CBL-01
- QuantityInStock: 50 יח'.
- תיאור: כבלי רשת לחיבור עמדות.
7. מתאם חשמל לגנרטור –
- Code: PWR-01
- QuantityInStock: 4 יח'.
- תיאור: כבל מתאם לחשמל שדה (להטענת ציוד תקשוב).
(הרשימה מגוונת: כולל ציוד קשר (1-3), מחשוב (4), תקשורת נתונים (5-6), ופריט הספק (7).)
קבלות לדוגמה (Receipts) – Seed: כדי להדגים היסטוריה, נזין כמה רשומות: 1. קבלה מס' 1 –
- Date: 2026-01-10 08:15:00
- ReceiverName: "סמל איתן רוזן"
- User: admin (נניח שבוצע ע"י admin)
- Lines: - Item: מכשיר קשר RF-7800 – Quantity: 1
- Item: בטרייה 12V – Quantity: 2
- פרשנות: חייל בשם איתן לקח מכשיר קשר עם 2 בטריות ספייר. 2. קבלה מס' 2 –
- Date: 2026-01-10 09:00:00
- ReceiverName: "טוראי דנה לוי"
- User: admin
- Lines: - Item: מחשב נייד Toughbook – Quantity: 1
- Item: כבל רשת 5m – Quantity: 2
- פרשנות: דנה קיבלה מחשב נייד ו-2 כבלי רשת. 3. קבלה מס' 3 –
- Date: 2026-01-11 16:30:00
- ReceiverName: "רס\"ן אבי כוכבי"
- User: admin
- Lines: - Item: ראוטר Cisco – Quantity: 1
- Item: כבל רשת 5m – Quantity: 4
- Item: מתאם חשמל לגנרטור – Quantity: 1
- פרשנות: הקצין הטכני אבי לקח ערכת תקשורת: ראוטר, כמה כבלים, ומתאם חשמל.
(עם 3 קבלות אלו נראה תנועה בהיסטוריה. שימו לב: אם Seed, ישפיע גם על המלאי – צריך להפחית מהמלאי ההתחלתי. למשל, אם במכשירי קשר היו 10, אחרי קבלה 1 נשארו 9. אם מעדיפים, seed של Receipts יכול לבוא במקום הפחתות מראש, אבל עדיף להזין גם הפחתה. בפועל, ב-Seed אפשר או להכניס את Receipt ולגרום ל-EF לעדכן QuantityInStock ידנית – EF לא עושה אוטומטית; אפשר לעדכן בערכי ה-Item seed עצמם בהתאם. או פשוט להגדיר בכמות הראשונית ערך שכבר מגלם את ההוצאות הללו. אבל כדי להימנע מחוסר עקביות, אולי עדיף לא לכלול receipts ב-seed בפועל, כי זה מסובך. יכול להיות שניצור רק בתרחישי בדיקה).
במצב פיתוח, נוכל כן להכניס אותם ידנית אחרי הפעלת המערכת כדי לראות היסטוריה.
כיצד ליישם Seed במסד: - בשימוש EF Core, אפשר לנצל ModelBuilder.HasData() במתודת OnModelCreating להזנת Users ו-Items. Receipts ו-ReceiptLines מורכב יותר כי יש תלות ב-IDs (EF יכול גם עם HasData, אבל אז צריך לציין PKs ידנית ולדאוג לסדר הוספה נכונה – אפשרי). - לחלופין, אפשר לכתוב סקריפט ייעודי בהרצת התוכנה: למשל, בבדיקת ההפעלה הראשונה (אם DB ריק) – אז בתכנית השרת להריץ משהו כמו:
if (!context.Users.Any()) {
   context.Users.Add(new User { Username="admin", PasswordHash=..., Role="Admin" });
   context.Users.Add(new User { Username="supply1", PasswordHash=..., Role="User" });
   ...
   context.Items.AddRange(new List<Item> { ... }); 
   context.SaveChanges();
}
ואת ה-Passwords Hash אפשר ליצור בתהליך (למשל hash של "Admin!123"). - כך או כך, לאחר יצירת DB, בעת ריצה ייטענו הערכים.
שימוש ב-Seed data: - בסביבת פיתוח/בדיקות: מאפשר למפתחים ולבודקים להפעיל מיד את המערכת ולנסות התחבר כ-admin/supply1, לראות רשימת פריטים מוכנה (7 סוגים), לנסות להוציא קבלה בלי שצריך להזין דברים. - בהדגמה ללקוח: ניתן להריץ את המערכת עם נתוני הדגמה אלו כדי להראות פיצ'רים. לאחר מכן, לפני Production, אפשר להחליף את הנתונים לנתוני אמת (למשל להזין את המלאי האמיתי של הגדוד). - בסביבת Production: אולי לא נשתמש בכל ה-seed (למשל user admin נשאר, אבל items כנראה ירצו להזין בהתאם למלאי בפועל). נוכל לספק סקריפט טעינה של items אקטואלי (CSV אולי) או לתת להם להזין ידנית.
טבלת דוגמה – פריטים Seed:
ItemID	Name	Code	QuantityInStock
1	מכשיר קשר Motorolla RF-7800	RFL-01	10
2	בטרייה 12V למכשיר קשר	BTL-01	20
3	קסדת קשר (דיבורית ראש)	HDR-01	5
4	מחשב נייד "Toughbook"	LPT-01	3
5	נתב תקשורת "Cisco 2600"	RTR-01	2
6	כבל רשת CAT6 (5 מטר)	CBL-01	50
7	מתאם חשמל לגנרטור	PWR-01	4
טבלת דוגמה – משתמשים Seed:
UserID	Username	Password	Role
1	admin	Admin!123 (hash)	Admin
2	supply1	Supply!123 (hash)	User
(הסיסמה תישמר כ-hash, למשל עבור "Admin!123" כנראה ערך hash Bcrypt כמו $2a$...). יש לקחת בחשבון שלא לחשוף את הערך הגולמי בשום מקום במערכת.
טבלת דוגמה – Receipt (אם משולבים seed):
ReceiptID	Date	ReceiverName	UserID
1	2026-01-10 08:15:00	סמל איתן רוזן	1 (admin)
2	2026-01-10 09:00:00	טוראי דנה לוי	1 (admin)
3	2026-01-11 16:30:00	רס"ן אבי כוכבי	1 (admin)
טבלת דוגמה – ReceiptLine:
ReceiptLineID	ReceiptID	ItemID	Quantity
1	1	1	1
2	1	2	2
3	2	4	1
4	2	6	2
5	3	5	1
6	3	6	4
7	3	7	1
(IDs רצים, ב-seed אמיתי EF היה כנראה רוצה לתת אותם, כאן שמנו ידנית).
בעזרת ה-Seed data, אפשר לאתחל את המערכת במצב שמדמה יום אמת: מלאי בסיסי קיים, כמה פעולות כבר קרו. בבדיקות, אפשר גם אפס את ה-DB ולהתחיל ריק.
שימוש ב-Codex ליצירת Seed: אפשר לבקש מ-Codex לכתוב קוד הכנסת הנתונים, אבל זה מספיק קצר שיתכן ונכתוב ידנית.
לסיכום סעיף זה, נתוני ה-Seed נועדו ליעל את הבדיקות ולהבטיח ש"כבר מהקופסה" יש תוכן להתרשמות, במקום להתחיל מסקראץ' על מסד ריק. הם אינם תחליף לקליטת הנתונים האמיתיים עם כניסת המערכת לפעולה, אולם מהווים נקודת פתיחה טובה.
12. נספח: פרומפטים מוכנים ל-Codex (סיוע אוטומטי בפיתוח)
להלן רשימה של הנחיות (Prompts) שניתן לספק לכלי AI כדוגמת OpenAI Codex או GitHub Copilot על מנת לבצע אוטומציה של חלקי פיתוח מרכזיים בפרויקט. הרעיון הוא שהמפתחים יוכלו להשתמש בפרומפטים הללו בתוך סביבת Visual Studio/VS Code כדי ליצור במהירות קבצי קוד, תצורות, ועוד, לפי התכנון המפורט שמופיע במסמך. הפרומפטים כתובים באנגלית טכנית (שכן Codex מבין לרוב טוב יותר הנחיות כאלה), וניתן להריצם שלב-אחר-שלב.
שימוש בפרומפטים: יש להזין את הטקסט של הפרומפט לכלי ה-AI בתור תגובה/השלמה. מומלץ לעשות זאת קטעים-קטעים ולא את הכל בבת אחת, כדי לפקח על הפלט ולוודא שהוא תואם לציפיות. אחרי כל השלמה, יש לסקור, לתקן ידנית אם צריך, ואז להמשיך עם הפרומפט הבא.
להלן הפרומפטים בשלבי הפיתוח השונים:
1.	יצירת פרויקט Backend – Bazap.Api (ASP.NET Core Web API):

 	Create a new ASP.NET Core Web API project named "Bazap.Api". Use .NET 7 (C#). Enable controllers (use Minimal APIs off). Ensure support for EntityFramework Core. No authentication configured yet.
 	הערה: פרומפט זה מנחה ליצור פרויקט, לרוב Copilot יכול רק להציע קוד בתוך קובץ, אז זה יותר הוראה למפתח. בפועל, ניתן פשוט להשתמש ב-VS Template. במידה ונרצה, אפשר שה-AI ייצר לנו classes. נעבור לפרומפטים ספציפיים.*
2.	הגדרת מודל הנתונים (Entities + DbContext):
3.	צור את מחלקת Item:

 	Define a C# class `Item` with properties: 
  - int ItemID (primary key)
  - string Name (required)
  - string Code (optional, unique)
  - int QuantityInStock
  - bool IsActive
Use C# conventions (properties with { get; set; }). 
4.	צור את מחלקת Receipt:

 	Define a C# class `Receipt` with properties: 
  - int ReceiptID (primary key)
  - DateTime Date 
  - string ReceiverName 
  - int UserID 
  - bool IsCancelled 
  - Navigation property: User (the user who created receipt)
  - Navigation property: ICollection<ReceiptLine> Lines 
Use Data Annotations or fluent config later for keys.
Set default for Date to DateTime.Now in constructor.
5.	צור את מחלקת ReceiptLine:

 	Define a C# class `ReceiptLine` with properties:
  - int ReceiptLineID (primary key)
  - int ReceiptID (foreign key)
  - int ItemID (foreign key)
  - int Quantity 
  - Navigation property: Receipt 
  - Navigation property: Item 
Also consider [Key] attribute or config in DbContext later. 
6.	צור את מחלקת User:

 	Define a C# class `User` with properties:
  - int UserID (primary key)
  - string Username 
  - string PasswordHash 
  - string Role 
  - bool IsActive 
  - Navigation: ICollection<Receipt> Receipts 
7.	לבסוף, צור את ה-DbContext:

 	Define a class `BazapContext` inheriting from DbContext. 
Include DbSet<Item> Items, DbSet<Receipt> Receipts, DbSet<ReceiptLine> ReceiptLines, DbSet<User> Users.
In OnModelCreating:
  - configure primary keys for each entity (if not by convention).
  - configure unique index on Item.Code.
  - configure relationships:
      * Receipt to ReceiptLine: one-to-many (Receipt has many ReceiptLines, ReceiptLine has one Receipt). Use HasMany/WithOne. Cascade delete on Receipt->ReceiptLines.
      * Item to ReceiptLine: one-to-many (Item has many ReceiptLines). Use HasMany/WithOne. Restrict delete on Item if ReceiptLines exist.
      * User to Receipt: one-to-many (User has many Receipts). 
  - optionally seed initial data for Users and Items (we'll add later).
8.	Codex אמור לייצר את מחלקות בהתאם. יש לעבור עליהן, לוודא שאין שגיאות. ייתכן שנוסיף DataAnnotations (Key, Required, MaxLength). זה אפשרי:

 	[Required] on Item.Name, [MaxLength(100)] maybe. Use [Required] on User.Username and PasswordHash.
Use [Index(IsUnique=true)] on Item.Code.
9.	הגדרת חיבור SQLite והגירת מסד:
 	In appsettings.json, add a connection string "BazapDatabase" pointing to "Data Source=bazap.db".
In Program.cs, configure services to use SQLite:
  builder.Services.AddDbContext<BazapContext>(options => options.UseSqlite(Configuration.GetConnectionString("BazapDatabase")));
Enable EF Core migrations.
 	כאן Codex עשוי לא לדעת context, אז אולי עדיף לבצע ידנית את הוספת ה-NuGet (או פרומפט: "Add NuGet package Microsoft.EntityFrameworkCore.Sqlite latest").
לאחר הגדרה, נריץ Add-Migration Initial מחוץ לקונטקסט Codex (בסביבת dev). זה לא via Codex אלא EF Tools.
1.	יצירת בקרים (Controllers):
2.	ItemsController:

 	Create a controller class `ItemsController` (in Controllers folder) for Item management.
Use `[Route("api/[controller]")]` and `[ApiController]` attributes.
Inject BazapContext via constructor.
Implement endpoints:
  - GET: returns all items (200 OK). Use `ToListAsync()`.
  - GET("{id}"): returns single item by id. If not found, return NotFound().
  - POST: create new item. Accept JSON body -> Item item. On success, SaveChanges, return CreatedAtAction(nameof(GetItem), new {id=item.ItemID}, item).
    * Before Save, check uniqueness of Code (if Code != null and any existing with same code).
  - PUT("{id}"): update item. If id not match item.ItemID from body, return BadRequest. If item not found in DB, return NotFound. Otherwise update fields and SaveChanges (204 NoContent).
  - DELETE("{id}"): remove item. If not found -> NotFound. If item has any related ReceiptLines (check context.ReceiptLines.Any(r=>r.ItemID==id)), return BadRequest "cannot delete". Else remove and SaveChanges (204).
Add [Authorize(Roles="Admin")] on POST, PUT, DELETE (only admin can change items).
Allow [Authorize] (any user) on GET.
3.	ReceiptsController:
 	Create `ReceiptsController` for managing receipts.
Endpoints:
  - GET: returns list of receipts. Include ReceiptLines and Items (use .Include(r=>r.Lines).ThenInclude(l=>l.Item)). Return 200 OK with list.
  - GET("{id}"): returns a single receipt with lines included. If not found -> NotFound.
  - POST: creates a new receipt. Accept DTO or Receipt model including lines.
    * The incoming JSON will have ReceiverName and Lines (list of {ItemID, Quantity}).
    * Use [FromBody] Receipt dto if defined. Alternatively, create a ReceiptDTO class to bind.
    * In handling: 
        - set receipt.Date = DateTime.Now (or let default in constructor).
        - set receipt.UserID from the JWT (use User.FindFirst(ClaimTypes.NameIdentifier) or similar which holds userId).
        - for each line in receipt.Lines: validate Item exists and stock is enough (Item.QuantityInStock >= line.Quantity). If not, return BadRequest($"Not enough stock for item {item.Name}").
        - If all good: for each line, subtract from Item.QuantityInStock.
        - Add receipt (with lines) to context. SaveChanges.
        - Return CreatedAtAction(nameof(GetReceipt), new {id=receipt.ReceiptID}, receipt).
  - DELETE("{id}"): (optional) cancel a receipt. 
    * If found: set IsCancelled=true, add back quantities to items, SaveChanges, return NoContent.
    * If not found: NotFound.
  - (No PUT for receipts).
Use [Authorize] attribute on all (any logged in user can create/view).
Perhaps [Authorize(Roles="Admin")] on DELETE if implemented.
4.	AuthController (Authentication):
 	Create `AuthController` for login.
[AllowAnonymous] for this controller.
Define a model class LoginDTO { string Username; string Password; } for binding.
POST /auth/login:
  - Find user by Username (case-insensitive ideally).
  - If not found or password doesn't match (compare hashed password): return Unauthorized().
  - If ok: generate JWT token. Use JwtSecurityToken from System.IdentityModel.Tokens.Jwt.
    * Token contains userID and role claims.
    * Sign with symmetric key "super_secret_key_12345" (for development).
    * Expiration e.g. 1 hour.
  - Return Ok with { token = <token>, user = new { userID, username, role } }.
 	בנוסף, setup JWT ב-Program:
 	In Program.cs, configure JWT Authentication:
  builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
      .AddJwtBearer(options => {
          options.TokenValidationParameters = new TokenValidationParameters {
              ValidateIssuer = false,
              ValidateAudience = false,
              ValidateIssuerSigningKey = true,
              IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes("super_secret_key_12345")),
              ClockSkew = TimeSpan.Zero
          };
      });
  builder.Services.AddAuthorization(options => {
      options.AddPolicy("Admin", policy => policy.RequireRole("Admin"));
  });
Add app.UseAuthentication(); app.UseAuthorization(); in request pipeline.
 	נכניס את המפתח הסימטרי הנ"ל כאילוסטרציה; ב-prod יש לשים בקובץ הגדרות. Codex אולי יעשה inline.
5.	UsersController (optional): אם רוצים Codex:
 	Create `UsersController` with [Authorize(Roles="Admin")].
GET: returns list of users (maybe excluding password hash).
POST: create new user (hash password, etc).
 	אבל אפשר לוותר כרגע.
6.	חשוב: Codex עלול לא לדעת את Claim for userId. אולי נגדיר ב-token claim name:
 	In token generation, add Claim(ClaimTypes.NameIdentifier, user.UserID.ToString()) and Claim(ClaimTypes.Role, user.Role).
Then in controller, to get userId: 
  var userId = int.Parse(User.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier).Value);
7.	יצירת Frontend – פרויקט React עם Vite:
8.	אפשר ליצור את פרויקט React מהCLI, אבל אפשר לשאול Codex ליצירת מבנה קבצים:
 	Create a new React app using Vite and TypeScript.
 	(This likely won't directly create but assume it's done.)
9.	Setup basic structure:
 	In the React app, create:
  - a LoginPage component with a form (username, password). 
  - a ReceivingPage component for equipment receiving form.
  - an ItemsPage component to list and add/edit items.
  - a HistoryPage component to list receipts history.
  - Use React Router for navigation between these pages.
  - Implement an AuthProvider context to store auth token and current user info.
  - Protect routes: if not logged in, redirect to login.
10.	פרומפטים יותר ספציפיים:
o	Router setup in App.tsx:
 	In App.tsx, use BrowserRouter. 
Create routes:
  "/" or "/login" -> <LoginPage/>
  "/receiving" -> <ReceivingPage/>
  "/items" -> <ItemsPage/>
  "/history" -> <HistoryPage/>
If user not logged in, redirect to "/login".
Show a navigation bar with links to Receiving, Items, History, and Logout, when user is logged in.
o	AuthContext.tsx:
 	Create AuthContext with:
  state: { user: UserInfo|null, token: string|null }
  and functions: login(username,pw), logout()
On login success, save token to localStorage and set user state.
On logout, clear localStorage and reset state.
Provide this context to app.
o	LoginPage.tsx:
 	Implement LoginPage:
  - State: username, password, error (if login fails).
  - On form submit: call fetch POST /api/auth/login with {username, password}.
  - If success: get token and user from response, call authContext.login() to set.
  - If error (401): set error state "שם משתמש או סיסמה שגויים".
Use a simple form UI with labels and inputs.
o	ReceivingPage.tsx:
 	Implement ReceivingPage:
  - State: receiverName (string), selectedItemId, quantity, itemsList (array), lines (array of {itemId, itemName, quantity} for current receipt), successMessage, errorMessage.
  - On mount, fetch GET /api/items (with Authorization header) to populate itemsList.
  - Provide a dropdown select for item (options from itemsList) and number input for quantity.
  - "Add item" button: adds the {itemId, itemName, quantity} to lines state. If item already in lines, optionally increase quantity or prevent duplicates.
  - Display a table of lines added with item name and quantity, plus a remove button per line.
  - "Submit Receipt" button: 
      * validate receiverName not empty and lines not empty.
      * send POST /api/receipts with { receiverName, lines: [{itemID, quantity},...] }.
      * If success: show successMessage ("קבלה נשמרה בהצלחה"), clear receiverName and lines (for new entry).
      * If error: if 400 with error details, show errorMessage.
      * Also update the itemsList quantities locally (or refetch items) to reflect new stock.
  - Maybe disable submit button if form invalid.
o	ItemsPage.tsx:
 	Implement ItemsPage:
  - State: items (array), showAddForm (bool), newItem form fields (name, code, quantity), editItem fields (if editing), errorMessage.
  - On mount, fetch GET /api/items to populate items list.
  - Display items in a table (Name, Code, Quantity, Active).
  - "Add Item" button toggles showAddForm. 
  - Add form: fields for name, code, quantity. On submit, call POST /api/items. If success, add the returned item to items state and hide form. If error (e.g. duplicate code), show errorMessage.
  - For each item row, provide "Edit" and "Delete" actions.
  - Edit: could be inline form or modal. Simpler: when clicking "Edit", store that item in state (editingItem), show fields to edit. On submit PUT /api/items/{id}. Update state on success. 
  - Delete: on click, confirm, then call DELETE /api/items/{id}. On success remove from state. If error (cannot delete because has receipts), show error alert.
  - Ensure only Admin role can see Add/Edit/Delete (if user.role != 'Admin', maybe hide these buttons).
o	HistoryPage.tsx:
 	Implement HistoryPage:
  - State: receipts (array), filter criteria (search text, date range, item filter), filteredReceipts (array).
  - On mount, fetch GET /api/receipts to get receipts (with lines and items included).
  - Display receipts in a table: columns (Date, Receiver, Items Summary).
    * Items Summary can be like a string "X items" or list first few item names.
  - Provide input controls to filter: 
    * search text (filter by receiverName or item names),
    * from-date and to-date pickers,
    * item dropdown to filter receipts containing specific item.
  - Filtering can be done in client side: when criteria change, update filteredReceipts.
  - For each receipt, allow click to view details:
    * Could be a modal showing all line items and their quantities, and who created, etc.
  - Optionally, if Admin: in detail modal, show "Cancel Receipt" button.
      - on cancel: call DELETE /api/receipts/{id}, on success remove or mark as canceled in state.
  - Distinguish canceled receipts in UI (e.g., with a strikethrough or label).
o	Navbar and Logout:
 	Create a Navbar component with links to the pages:
  - "קבלת ציוד"
  - "ניהול פריטים"
  - "היסטוריה"
  - "התנתקות"
Use NavLink for active highlighting.
On logout link click: call authContext.logout() and redirect to login.
Only render Navbar if authContext.user is not null (logged in).
o	HTTP requests:
 	Use axios for HTTP requests:
  - Set axios.defaults.baseURL to the API base (e.g., http://localhost:5000/api).
  - Set axios interceptors to include Authorization header with the token from authContext for every request.
  - Handle 401 responses globally (if token expired, maybe logout).
 	(Alternatively manually attach headers in each call).
o	Form and feedback:
 	Use controlled components for form inputs.
Display error messages near fields or as alert banners.
Display success messages after certain actions (like receipt saved).
Ensure proper LTR/RTL as needed (maybe add dir="rtl" on HTML or body for full Hebrew UI).
11.	Codex can generate boilerplate for these, though some logic may need refining. Possibly generate one by one to not confuse it.
12.	בדיקות (Tests) בעזרת Codex:
13.	ניתן להעזר ב-Codex לכתוב בדיקות Unit, למשל:
 	Write an xUnit test for ItemsController.Delete to ensure it returns BadRequest when item has related ReceiptLines.
 	Or:
 	Write a test method that creates an in-memory BazapContext with one Item and one ReceiptLine referencing it. Then calls ItemsController.Delete(itemId) and asserts that BadRequest is returned.
14.	גם אפשר:
 	Generate a NUnit test for AuthController.Login: valid user vs invalid password scenarios.
15.	Seed Data insertion via code:
 	In BazapContext.OnModelCreating, use HasData to seed:
  - an Admin user (ID=1, Username="admin", PasswordHash of "Admin!123", Role="Admin", IsActive=true).
  - a regular user (ID=2, Username="supply1", PasswordHash of "Supply!123", Role="User", IsActive=true).
  - items as defined: e.g., new Item { ItemID=1, Name="מכשיר קשר Motorolla RF-7800", Code="RFL-01", QuantityInStock=10, IsActive=true }, etc for the 7 items.
Note: store PasswordHash as a bcrypt or SHA256 hash string.
16.	אם Codex לא מנחש את ה-hash, אפשר לייצר offline או להשתמש בגישה קלה: (לצורך seed, אולי אפשר לשמור plaintext ואז ב-Login hash? אבל עדיף לא. אולי נשים Sha256(password) as hex).
17.	If needed:
 	Compute SHA256 hash of "Admin!123" and use as PasswordHash in seed.
 	והוא עשוי לתת.
18.	Codex יצטרך using Microsoft.EntityFrameworkCore;
19.	שיפור קוד אוטומטי:
20.	אחרי יצירת הבסיס, אפשר לבקש refactor:
 	Refactor ItemsController: extract duplicate code for checking item existence into a private method.
21.	או:
 	Ensure all controllers use async/await properly with context (e.g., use SaveChangesAsync, ToListAsync).
22.	או:
 	Add logging to ReceiptsController.Post to log when a receipt is created successfully or when an error occurs.
23.	Docker (אם נדרש, אולי לא):
24.	אם רוצים:
 	Provide a Dockerfile for the Bazap.Api (ASP.NET Core) to build and run the API, and a Dockerfile for the React frontend with nginx or node serve.
 	(But likely not needed within this unit).
25.	בדיקות ידניות (הנחיות לא AI אבל למפתחים):
o	Codex can generate test data or steps but mostly we do that ourselves.
לסיכום הנספח: הרשימה מסייעת למפתחים להשתמש בכלי AI לזרוז כתיבת קוד בהתאם לתכנון המפורט. חשוב תמיד לבחון את הפלט של Codex, לבצע התאמות (למשל שמות בעברית אולי נצטרך לתרגם), ולהשוות לדרישות. Codex אמנם יכול לחסוך זמן, אך הוא עלול להמציא דברים לא נכונים אם הפרומפט לא ברור. עם ההנחיות המדויקות לעיל, צוות הפיתוח יוכל לרתום את הכוח של AI להפקת חלק גדול מהקוד, תוך שמירה על בקרת איכות אנושית.
כך, Bazap 2.0 יעבור מפס הייצור באופן מהיר ומדויק, בהתאם לדרישות שסוכמו במסמך זה.
________________________________________
[1] Warehouse Receiving Process: Best Practices & Steps to Improve Efficiency
https://www.finaleinventory.com/warehouse-management-system-software/warehouse-receiving-process
מעבדת הבחינה ומחסן קבלת הציוד – הסבר מפורט
רקע ומטרת המערכת
מטרת המערכת היא לייעל את הטיפול בציוד שחוזר מיחידות ולהבטיח תהליך מסודר של קבלה, בדיקה ותיעוד. יחידות מגיעות למחסן הקבלה כדי להחזיר ציוד תקול ולקבל ציוד חלופי. במערכת המשולבת, המחסן ומעבדת הבחינה עובדים יד ביד: המחסן מקבל ורושם את הפריטים המוחזרים, ומעבדת הבחינה הסמוכה מבצעת בדיקה ראשונית על הציוד. תהליך זה נועד לוודא שכל פריט שחוזר מטופל כהלכה – בין אם באמצעות השבתתו (הוצאתו מכלל שימוש) או העברתו להמשך תיקון – ובכך לתרום לזמינות ציוד תקין לכלל היחידות.
תהליך העבודה במחסן קבלת הציוד
מחסן קבלת הציוד הוא התחנה הראשונה בתהליך. כאשר נציג יחידה מגיע עם ציוד להחזרה (למשל מכשירים תקולים או כבלים פגומים) ולעיתים גם לקבלת תחליפים, מתבצעות הפעולות הבאות:
1.	רישום הפריטים – איש הצוות במחסן ("המקבל") קולטן את הציוד המוחזר במערכת הממוחשבת. נרשמים פרטי הפריט: סוג, מספר סידורי/מקט (אם רלוונטי), סיבת ההחזרה (תקלה, בלאי, שדרוג וכד'), ופרטי היחידה שממנה הגיע.
2.	תיעוד והפקת אסמכתא – היחידה מקבלת אישור על ההחזרה. אם נדרש ציוד חלופי, המחסן מספק מידי פריט חלופי (בכפוף לזמינות במלאי) כדי שהיחידה לא תישאר ללא ציוד. תהליך זה מתועד כך שניתן יהיה לעקוב אילו פריטים הוחזרו והוחלפו.
3.	העברת הציוד למעבדת הבחינה – לאחר קליטת הציוד ותיעודו, הפריטים המוחזרים מועברים פיזית מהמחסן אל מעבדת הבחינה הסמוכה, הממוקמת ליד מפרץ הקבלה (אזור הפריקה והטעינה של הציוד). המעבר המהיר חשוב כדי שהבדיקה תתבצע בסמוך למועד ההחזרה.
בשלב זה מסתיים תפקידה של יחידת המחסן עבור הפריטים המוחזרים, והמשך התהליך מתרחש במעבדת הבחינה. עם זאת, המחסן נשאר מעודכן בסטטוס הפריטים דרך המערכת (למשל, אם פריט מושבת או עבר לתיקון) למעקב ולדיווח בעתיד.
תהליך העבודה במעבדת הבחינה
מעבדת הבחינה אחראית על בדיקה ראשונית של הציוד שהוחזר, במטרה לקבוע את מצב הפריט ולהחליט על המשך הטיפול בו. השלבים במעבדה הם:
1.	קליטת הפריט במעבדה – טכנאי המעבדה מקבל את הפריט עם הנתונים שרשם המחסן (סוג, תקלה מדווחת וכד'). הפריט מזוהה במערכת כך שכל הפעולות שיתבצעו עליו יהיו מקושרות לרישום ההחזרה.
2.	בדיקה ויזואלית ראשונית – הטכנאי מבצע בדיקה חזותית מהירה ויסודית: מחפש נזק פיזי גלוי (שברים, חלקים חסרים, צריבות, קורוזיה), בודק שלמות כבלים ומחברים, ומעריך האם הפריט נראה תקין או לא. פעמים רבות בדיקה ויזואלית יכולה לחשוף מיד תקלות קשות (למשל רכיב שרוף בלוח אלקטרוני, חוט קרוע וכו').
3.	בדיקת תפקוד בסיסית – במידת האפשר, המעבדה תבצע בדיקה תפקודית מהירה: הפעלת הציוד או חיבורו לעמדת בדיקה בסיסית כדי לראות האם הוא נדלק, פועל, או מפיק תגובה כלשהי. שלב זה קצר ונועד לקבל אינדיקציה ראשונית אם הפריט חסום לחלוטין (״מת״) או שיש סימני חיים.
4.	קבלת החלטה – השבתה או המשך טיפול – בהתבסס על הממצאים (ויזואליים ותפקודיים), מחליטים במעבדה על אחד משני מסלולים:
o	השבתת הציוד: אם התגלה שהפריט אינו כשיר לשימוש – למשל, נזק כבד שאינו ניתן לתיקון מיידי, בלאי מתקדם, או שהוא תקול לחלוטין – הטכנאי יסמן במערכת שהציוד מושבת. המשמעות היא שהפריט מוצא מכלל שימוש ולא יחזור יותר ליחידות המבצעיות. אנו מציינים במערכת את סיבת ההשבתה: בין אם עקב כשל בבדיקה הויזואלית (נזק חיצוני/פנימי חמור) או החלטה לשלוח את הפריט לגריטה (פירוק לחלקים/מיחזור). כאשר פריט מושבת, לרוב אין טעם להשקיע בו משאבי תיקון נוספים.
o	המשך תהליך במעבדות תיקון: אם בבדיקה התגלה שהפריט אינו במצב השבתה (כלומר, ייתכן שהוא בר־תיקון או שהתקלה אינה ברורה בשלב זה), הפריט יועבר למעבדות המשך לצורך אבחון מעמיק ותיקון. המעבדה הראשונית תעדכן במערכת שהפריט ממשיך לטיפול, ותציין לאיזו מעבדה/סדנה הוא נשלח (לדוגמה: מעבדת אלקטרוניקה, מכונאות, אופטיקה וכו' בהתאם לסוג הציוד). במקרה כזה הפריט עדיין רשום במערכת כ"בתהליך תיקון" ולא כמושבת.
5.	תיעוד ודיווח – בכל אחת משתי ההחלטות לעיל, מעבדת הבחינה מזינה למערכת נתונים: מצב סופי לאחר הבדיקה הראשונית (מושבת/להמשך תיקון), סיבה (תקול בבדיקה ראשונית, נשלח לתיקון מתקדם וכד'), ושם הטכנאי או הבוחן שביצע את ההערכה. נתונים אלו נגישים לגורמים הרלוונטיים (מחסן הקבלה, מנהלי אחזקה) לצורכי בקרה ומעקב.
בסיום שלב זה, תפקידה של מעבדת הבחינה הראשונית מסתיים עבור אותו פריט. אם הפריט הוגדר כמושבת, הוא יועבר לאזור ייעודי (כגון מכל לאחסון גרוטאות או שטח השבתה) עד לטיפול סופי בו (גריטה פיזית, מיחזור וכד'). אם הפריט נשלח לתיקון, האחריות עליו עוברת למעבדה המקצועית המתאימה, ששם יטופל עד שיוחזר לתקינות מלאה (ואז יוחזר למלאי שממנו מסופקים פריטים ליחידות).
המשך הטיפול במעבדות המתמחות
כאשר פריט מועבר למעבדה מתמחה להמשך טיפול, מתחיל שלב תיקון מעמיק: מומחי חומרה או טכנאים ייעודיים בוחנים לעומק את התקלה, מחליפים רכיבים תקולים, מבצעים כיולים ובדיקות מעבדה מקיפות יותר. שלב זה למעשה מעבר לאחריות הגורם המתקן (לדוגמה, מרכז תחזוקה ארצי, סדנת חיל החימוש או גורם טכני רלוונטי). מבחינת המערכת שלנו, הפריט מסומן כ"בטיפול" ועדכון על מצבו מתקבל כאשר תהליך התיקון מסתיים.
חשוב להדגיש: עבור היחידה שהחזירה את הפריט, התהליך הסתיים כבר בשלב מחסן הקבלה (עם קבלת ציוד חלופי אם נדרש). תהליך ההמשך במעבדות הוא פנימי, במטרה להחזיר את הפריט המוחזר לכשירות ולהשיבו למלאי הכללי. כאשר המעבדה המתמחה מסיימת את תיקון הפריט, היא תעדכן זאת במערכת. אז הפריט יכול לחזור למדפים כמלאי זמין, או לחלופין, אם יתגלה במהלך התיקון שהוא לא ניתן לתיקון, ייתכן שיושבת בשלב זה (ויסומן בהתאם במערכת).
הדפסת פתקי השבתה ותיוג הציוד
אחד האלמנטים החשובים בתהליך הוא תיוג פיזי של ציוד שהוחזר, במיוחד כזה שהוחלט להשביתו. בעבר, כאשר התהליך היה ידני, צוות המעבדה היה כותב פתקי השבתה ידניים ומדביק אותם על כל פריט או כבל תקול. פתק ההשבתה כלל מידע כמו: תאריך הבדיקה, שם הבוחן, סיבת ההשבתה (לדוגמה "תקול – לניפוק גרוטאה" או "מושבת – ממתין לגריטה"), ולעיתים גם מספר סימוכי למעקב.
כעת, עם הטמעת המערכת, אנו משפרים את התהליך באמצעות מדפסת מדבקות יעודית:
•	ברגע שטכנאי במעבדת הבחינה מסמן במערכת שהפריט מושבת, המערכת מפיקה מדבקת השבתה מודפסת. המדבקה מודפסת באופן מיידי במדפסת המדבקות המחוברת.
•	המדבקה המודפסת מכילה את כל הפרטים הרלוונטיים באופן ברור: קוד/מספר הפריט במערכת, תיאור הפריט, תאריך ההשבתה, סיבת ההשבתה (מתוך רשימת סיבות מוגדרות), ושם הבוחן או המחלקה. ניתן לכלול גם ברקוד או QR לקישור לרישום הדיגיטלי של הפריט במערכת.
•	הדבקת התווית על הפריט: צוות המעבדה מדביק את מדבקת ההשבתה על הפריט עצמו – אם זה מכשיר, המדבקה תודבק במקום בולט; אם כבל או רכיב קטן, ניתן להצמיד את המדבקה או לתלות תג צמוד. פעולה זו מבטיחה שכל מי שיטפל או יראה את הפריט במורד הזרם (למשל במחסן לגרוטאות או במרכז מיחזור) ידע מיד שהפריט מושבת ואינו לשימוש.
•	שיטה זו חוסכת זמן ומונעת טעויות קריאה בהשוואה לפתקים הכתובים ביד. האחידות בגודל ובתוכן המדבקה מבטיחה זיהוי מהיר של ציוד מושבת, ותורמת לבטיחות (שלא יחזור בטעות לשימוש) וליעילות בתהליך הסילוק או התיקון.
יצוין כי תיוג ציוד תקול הוא נוהל מקובל בתחזוקה: במערכות צבאיות ואזרחיות כאחד נהוג לסמן באופן פיזי ציוד פגום כדי למנוע שימוש בשוגג. המערכת החדשה ממכן נוהל זה, משפרת אותו ומפיקה תיעוד זהה גם בממד הדיגיטלי וגם על גבי הפריט עצמו.
קהל היעד והגורמים המעורבים במערכת
המערכת מיועדת לשימוש ולתועלת של מספר גורמים מרכזיים בארגון:
•	צוות מחסן קבלת הציוד – משתמש במערכת לרישום מהיר ומדויק של כל פריט מוחזר, להפקת תיעוד עבור היחידות, ולמעקב אחר מה שעלה בגורל הפריט (מושבת או נשלח לתיקון). המערכת מסייעת להם גם בניהול המלאי החלופי ובהתרעה אם פריט מסוים חוזר לעיתים קרובות (אולי דגם בעייתי).
•	טכנאי ואנשי מעבדת הבחינה – עבורם המערכת היא כלי עבודה יום-יומי: היא מציגה את רשימת הפריטים שממתינים לבדיקה, מאפשרת להזין ממצאי בדיקה ותוצאות (השבתה/המשך טיפול) בצורה מתועדת, ומדפיסה מדבקות בהתאם. המערכת חוסכת להם עבודת ניירת ידנית ומבטיחה שכולם פועלים לפי אותם קריטריונים והגדרות סיבה.
•	מעבדות תיקון מתמחות – אף שהמעבדות המתקנות הן "הצרכן" הבא בשרשרת, הן נהנות ממידע מקדים שמוזן במערכת. כאשר פריט מגיע אליהם, הם כבר יודעים מה נמצא בבדיקה הראשונית ומה דווח כסימפטום התקלה. המערכת יכולה לשמש לתקשורת בין מעבדת הבחינה למעבדה המתקנת (למשל הערות מיוחדות, היסטוריית הפריט).
•	היחידות השולחות ציוד – באופן עקיף, גם היחידות בשטח נהנות מהמערכת. ראשית, הן מקבלות שירות מהיר ומוסדר במחסן הקבלה (פחות זמן המתנה, תהליך חלק לקבלת חליפי). שנית, בטווח הארוך, המערכת דואגת שציוד תקול יטופל כהלכה ויוחזר למלאי רק כשהוא תקין, מה שמבטיח שאיכות הציוד המסופק ליחידות משתפרת. בנוסף, אם יש דפוס תקלות חוזרות, המערכת מתעדת זאת וניתן להפיק לקחים (אולי צורך בהכשרה, שימוש לא נכון בציוד, וכו').
•	מנהלי אחזקה ולוגיסטיקה – המערכת מספקת להם תמונה מלאה על זרימת הציוד: כמה פריטים חוזרים מושבתים, אילו עוברים תיקון, זמני מחזור, ועוד. נתונים אלה מסייעים לקבל החלטות ברמה ארגונית (כמו האם להזמין ציוד חדש במקום מה שמושבת, להעריך אמינות של דגמים, וכיו"ב).
בקיצור, המערכת מחברת בין כל הגורמים בשרשרת התחזוקה – מהיחידה בשטח, דרך מחסן הקבלה והמעבדה, ועד מנהלי המלאי והתיקון – כך שלכולם יש מידע עדכני על מצב הציוד.
סיכום
המערכת של מחסן קבלת הציוד ומעבדת הבחינה נועדה ליצור תהליך אחיד, מהיר ושקוף לטיפול בציוד שחוזר מיחידות. בזכות המערכת, כל פריט מוחזר נרשם ומטופל ללא התמהמהות: אם הוא מושבת – הדבר מתועד מיד הן במערכת והן על גבי הפריט באמצעות מדבקה, ואם הוא בר-תיקון – הוא מופנה במהירות לגורם המקצועי המתאים. המערכת שומרת את כל הנתונים לצורכי מעקב ובקרה, כך שניתן לדעת בכל רגע נתון מה הסטטוס של כל פריט מוחזר.
בסופו של דבר, היתרונות העיקריים של המערכת הם: שיפור היעילות (פחות עבודה ידנית וכפילויות), שקיפות (נראות מלאה של מצב כל פריט לכל הגורמים הרלוונטיים), ומניעת טעויות (ציוד תקול לא יחזור בטעות לשימוש, ותהליכי התיקון לא יתעכבו בגלל חוסר מידע). בצורה זו, המערכת משרתת הן את צרכי היחידות בשטח והן את צורכי מערך האחזקה והלוגיסטיקה כולו, ומבטיחה שציוד יקבל את הטיפול המתאים ביותר עד לסגירת המעגל – בין אם בשימוש חוזר ובין אם בהוצאה מכלל שימוש.
בצפ 2 – קודקס מוצר
מערכת סגורה לקליטת ציוד, בחינת ציוד והפקת פתקי השבתה (מדבקות)
1) המשמעות של המערכת – למה היא קיימת
בצפ 2 היא מערכת פנימית (סגורה) שמחליפה את השיטה הידנית של:
•	רישום מק״טים על דף / הקלדה איטית אחד-אחד,
•	מעקב לא ברור איפה כל פריט נמצא,
•	והפקת “פתקי השבתה” ידניים שמדביקים על כל כבל/מכשיר.
המטרה: להפוך את תהליך קליטת הציוד במחסן ואת תהליך בחינת הציוד במעבדת הבחינה לזורם, מהיר, עקבי ומתועד — כולל הדפסה מיידית של מדבקות השבתה כשצריך.
________________________________________
2) למי המערכת מיועדת (השחקנים)
א. צוות מחסן – “מקבל ציוד”
מי שעומד ברמפה/קבלת ציוד מול היחידה ומבצע קליטה בפועל:
•	פותח “אירוע קליטה”
•	מוסיף פריטים במהירות (הקלדה/בחירה)
•	מסיים קליטה ושולח את הסל לבדיקה במעבדה
ב. צוות מעבדת הבחינה (ליד מפרץ קבלת ציוד)
מי שמקבל את סל הפריטים שנקלטו ובודק:
•	האם הציוד מושבת (לפי בדיקה ויזואלית / גריטה)
•	או לא מושבת → מעביר למעבדות להמשך תהליך
•	ומדפיס פתקי השבתה (מדבקות) לכל פריט/כבל רלוונטי
ג. יחידה מוסרת / יחידה מקבלת
הצד שמביא ציוד למחסן ומצפה לתהליך ברור ותיעוד.
________________________________________
3) התהליך מקצה לקצה (Flow)
שלב 1: קליטה במחסן (ברמפה)
1.	יחידה מגיעה עם משאית לרמפה.
2.	מקבל הציוד פותח אירוע קליטה (מספר אירוע/תאריך/יחידה/הערות).
3.	מוסיף פריטים לסל הקליטה באחת הדרכים:
o	בחירה מהירה לפי “מכלול” (משפכת מכלולים → לבחור מ״ח 120 → לבחור מכשיר ספציפי)
o	חיפוש דינמי לפי מק״ט (מתחיל להקליד, מקבל השלמות והצעות)
o	גישה מהירה לפריטים נפוצים (פריטים שמגיעים הרבה)
4.	מסיים קליטה → הסטטוס הופך ל-“נקלט במחסן / ממתין לבחינה”.
שלב 2: בחינה במעבדת הבחינה
1.	הבוחן פותח את אירוע הקליטה ורואה את כל הפריטים שנקלטו.
2.	לכל פריט הוא מסמן תוצאה:
o	מושבת + סיבת השבתה (ויזואלי / גריטה) → מדפיס מדבקת השבתה
o	לא מושבת → מעביר ל-מעבדות להמשך תהליך (סטטוס: “הועבר”)
3.	“פה נעצרת העבודה שלנו” = אחרי העברה/השבתה, הפריט יוצא מתחום אחריות המעבדה (אלא אם הוגדר אחרת).
________________________________________
4) דרישות ליבה – מה אנחנו צריכים שהמערכת תעשה (בפועל)
4.1 מסך קליטה מהיר (הכי חשוב)
המערכת צריכה לאפשר למקבל ציוד לעבוד “עם ידיים בשטח”, בלי להיתקע.
יכולות חובה:
•	הוספת פריט לסל תוך שניות
•	מינימום הקלדות
•	חיפוש דינמי חזק לפי מק״ט/שם פריט/תיאור
•	“משפכת מכלולים” לבחירה מהירה לפי קטגוריות/מכלולים
________________________________________
4.2 חיפוש דינמי לפי מק״ט (Autocomplete) – מפרט התנהגות
זה הלב של הקליטה.
מה המשתמש עושה
מקבל הציוד מתחיל להקליד מק״ט חלקי, לדוגמה:
•	מק״ט מלא: 3109285354
•	הוא מקליד: 310928
•	והמערכת כבר מציעה השלמות/אופציות מתאימות.
מה המערכת חייבת לעשות
•	להציג רשימת הצעות בזמן אמת תוך כדי הקלדה
•	תמיכה ב:
o	התאמה לפי תחילית (Prefix) – הכי חשוב
o	התאמה לפי חלק מהמק״ט (אופציונלי אבל מועיל)
o	התאמה לפי שם/תיאור פריט (אם קיים במאגר)
•	כל הצעה תציג לפחות:
o	מק״ט
o	שם פריט / תיאור קצר
o	שיוך למכלול/קטגוריה (אם יש)
•	הוספה מהירה לסל
o	Enter = בוחר הצעה ראשונה ומוסיף לסל
o	חיצים למעלה/למטה לניווט
•	דירוג חכם להצעות
1.	התאמת תחילית מדויקת
2.	פריטים “נפוצים” (שמגיעים הרבה)
3.	פריטים שנוספו לאחרונה (לפי המשתמש/תחנה)
שדרוגים מומלצים (לא חובה אבל מאוד עוזר בשטח)
•	מצב “סורק ברקוד” טבעי: הסורק מתנהג כמו מקלדת → סריקה = מק״ט נכנס → Enter → פריט מתווסף
•	“אופציות מובילות” גם בלי הקלדה: 8–12 פריטים נפוצים תמיד למעלה
________________________________________
4.3 “משפכת מכלולים” – בחירה מהירה
מנגנון שמאפשר להגיע לפריט בלי לזכור מק״ט.
דוגמה מהשטח:
•	לבחור מכלול (מ״ח 120)
•	ואז לבחור מהר את המכשיר הספציפי
•	במיוחד טוב כש”אני מזהה את הפריט בעין” אבל לא יודע את המספר.
דרישות:
•	ניווט קטגוריות/מכלולים בלחיצות מעטות
•	תצוגת “פריטים בתוך מכלול”
•	אפשרות חיפוש בתוך מכלול (גם דינמי)
________________________________________
4.4 מודול בחינה והחלטה: מושבת / מועבר
במעבדת הבחינה, לכל פריט חייבת להיות פעולה ברורה:
מצבי פריט (סטטוסים מוצעים)
•	נקלט במחסן
•	ממתין לבחינה
•	בבחינה
•	מושבת
•	הועבר למעבדה להמשך תהליך
•	(אופציונלי) הוחזר ליחידה / נסגר
סימון “מושבת”
כשמסמנים מושבת:
•	חובה לבחור סיבה:
o	בדיקה ויזואלית
o	גריטה
•	רישום מי ביצע (שם/משתמש), תאריך/שעה
•	ואז פעולה מיידית: הדפס מדבקת השבתה
________________________________________
4.5 הדפסת פתקי השבתה (מדבקות) – כמו פעם, אבל אוטומטי
המערכת חייבת להחזיר את היכולת שהייתה ידנית:
“להדפיס בעזרת מדפסת מדבקות פתקי השבתה… ולהדביק על כל כבל או מכשיר בפרך בנוסף.”
מה מדפיסים
מדבקה לכל פריט/כבל שצריך סימון ברור בשטח.
תוכן מומלץ למדבקה
•	כותרת בולטת: מושבת
•	מק״ט
•	שם פריט (אם קיים)
•	סיבת השבתה (ויזואלי / גריטה)
•	תאריך
•	מזהה אירוע קליטה
•	שם הבוחן
•	(מומלץ) QR קטן שמוביל לרשומת הפריט במערכת (גם במערכת סגורה זה יכול לפתוח דף פנימי)
דרישת שטח חשובה
•	כפתור “הדפס שוב”
•	אפשרות “הדפס X עותקים”
•	עבודה חלקה עם מדפסת מדבקות (תרחיש: עמדת מחשב ליד קבלת ציוד/מעבדה)
________________________________________
5) מסכים/זרימות שימוש (מינימום מוצר עובד)
5.1 מסך “אירוע קליטה”
•	פתיחת אירוע חדש
•	שדה חיפוש דינמי למק״ט
•	כפתור “משפכת מכלולים”
•	רשימת פריטים שנוספו (הסל)
•	סיום קליטה → “שלח לבחינה”
5.2 מסך “בחינה”
•	פתיחת אירוע
•	רשימת פריטים
•	לכל פריט:
o	מושבת (סיבה + הדפסה)
o	מועבר להמשך תהליך
5.3 מסך “פריט”
•	כל ההיסטוריה של הפריט באירוע
•	סטטוס נוכחי
•	הדפסה מחדש למדבקה
________________________________________
6) דגשים של מערכת סגורה (ללא AWS/חוץ)
•	הכל רץ פנימית: תחנה/שרת פנימי/רשת פנימית בלבד
•	אין תלות בשירותים חיצוניים
•	כל המידע נשמר במאגר פנימי בלבד
•	הדפסות מתבצעות מקומית דרך תחנת העבודה/מדפסת המדבקות
________________________________________
7) הצעות חיזוק (אקסטרה שעוזר בשטח)
(רק הצעות לשיפור – לא “החלטות”)
•	“מועדפים” למקבל ציוד לפי תחנה/משתמש
•	“פריטים נפוצים” אוטומטי לפי סטטיסטיקה
•	מצב “קליטה מהירה” למסך מלא עם מקלדת-בלבד
•	מניעת טעויות: אם מק״ט לא קיים →提示 “לא נמצא, ליצור פריט זמני?” (אם מותר)
•	שדה כמות + הערות לכל פריט (כבלים/מצב אריזה/שברים)
________________________________________
אם אתה רוצה, אני יכול גם להוסיף ב-MD אפיון שדות (Data model) ממש קצר: מה נשמר באירוע, מה נשמר בפריט, ומה נשמר בפעולת השבתה/הדפסה — אבל כבר עכשיו זה מסמך קודקס שאפשר להדביק ישר לתוך ה-Codex שלכם ב-VS.
כל מה שאפשר להוסיף תוסיף שיעזור.
בצפ 2 – קודקס מוצר מלא
מערכת סגורה לקליטת ציוד, בחינת ציוד, השבתה והדפסת מדבקות
מטרה: להפוך את תהליך קליטת הציוד והבחינה לתהליך מהיר בשטח, מתועד, עם חיפוש דינמי (Autocomplete) לפי מק״ט, בחירה לפי מכלולים, ויכולת הדפסת מדבקות השבתה כמו שהיה ידנית — רק אוטומטי.
________________________________________
1) המשמעות של המערכת – למה היא קיימת
המערכת נועדה להחליף עבודה ידנית ולא עקבית (דפים/הקלדה איטית/טעויות/אין עקיבות), וליצור תהליך מסודר שבו ברור:
•	מה הגיע למחסן,
•	מה נבדק במעבדת הבחינה,
•	מה הושבת ולמה,
•	מה הועבר להמשך תהליך,
•	ואיפה כל פריט נמצא כרגע.
המערכת היא סגורה: רשת פנימית בלבד, ללא תלות בשירותים חיצוניים.
________________________________________
2) מי משתמש במערכת – תפקידי ליבה
2.1 מקבל ציוד (מחסן / רמפה)
אחראי לקליטה מהירה של פריטים שמגיעים מהיחידה:
•	פותח אירוע קליטה
•	מוסיף פריטים לסל (מכלולים / חיפוש דינמי / פריטים נפוצים / סריקה)
•	מסיים קליטה ומעביר לבחינה
2.2 בוחן ציוד (מעבדת הבחינה ליד מפרץ הקליטה)
אחראי לקבלת סל הפריטים ולבדיקה:
•	מסמן מושבת / מועבר
•	בוחר סיבת השבתה (ויזואלי / גריטה)
•	מדפיס מדבקות השבתה ומדביק בפועל על פריטים/כבלים
2.3 יחידה מוסרת / יחידה מקבלת
מוסרת ציוד למחסן (הגעה ברמפה). המערכת נותנת סדר ותיעוד לאירוע, אבל היחידה לא חייבת להשתמש בה ישירות.
________________________________________
3) תהליך עבודה (Flow) – כמו בשטח
3.1 קליטה ברמפה (מחסן)
1.	יחידה מגיעה לרמפה עם ציוד.
2.	מקבל ציוד פותח אירוע קליטה.
3.	מוסיף פריטים במהירות:
o	חיפוש דינמי לפי מק״ט
o	משפכת מכלולים לבחירה לפי מ״ח/קטגוריה
o	פריטים נפוצים/מועדפים
o	סריקת ברקוד (אם קיים)
4.	מסיים קליטה → סטטוס אירוע: ממתין לבחינה.
3.2 בחינה במעבדת הבחינה
1.	הבוחן פותח אירוע “ממתין לבחינה”.
2.	לכל פריט מחליט:
o	מושבת (ויזואלי / גריטה) → הדפסת מדבקה
o	לא מושבת → הועבר למעבדות להמשך תהליך
3.	לאחר ההחלטה:
o	אם “הועבר” → מבחינתכם העבודה נעצרת (סטטוס סוגר את האחריות שלכם על הפריט)
o	אם “מושבת” → נשמר תיעוד + מדבקה מודפסת + אפשר הדפסה חוזרת
________________________________________
4) עקרונות מוצר (מה חשוב בשטח)
•	מהירות קיצונית: הוספת פריט לסל תוך שניות.
•	מינימום הקלדה: השלמות אוטומטיות, Enter, חיצים, טאבים.
•	אפס בלבול: סטטוסים ברורים, פעולות קצרות, טעויות מוחזרות מיד.
•	תיעוד אמיתי: מי עשה מה ומתי (audit).
•	מדבקות = חובה: כמו בעבר, רק חכם יותר.
________________________________________
5) מודול “קליטה מהירה” – הדרישות הכי חשובות
5.1 חיפוש דינמי לפי מק״ט (Autocomplete) – מפרט מלא
התנהגות בסיסית
•	המשתמש מקליד חלק מהמק״ט (למשל 310928)
•	המערכת מציגה השלמות + אופציות תואמות
•	Enter מוסיף את האופציה הראשונה (או הנבחרת) לסל
מה נחשב “תואם”
סדר עדיפויות מומלץ לתוצאות:
1.	התאמה לפי תחילית מק״ט (prefix match)
2.	התאמה מלאה למק״ט
3.	התאמה לפי שם/תיאור פריט
4.	התאמה לפי חלק פנימי של מק״ט (אופציונלי, אם צריך)
איך מציגים כל תוצאה
כל שורה בהצעות תציג:
•	מק״ט (בולט)
•	שם פריט / תיאור קצר
•	שיוך למכלול / מ״ח
•	אינדיקציה אם זה “נפוץ” / “מועדף”
•	(אם רלוונטי) הערה כמו “דורש בדיקה מיוחדת” / “רגיש” (אופציונלי)
מקלדת בלבד (כי אתם בשטח)
•	↑ ↓ לניווט
•	Enter לבחור ולהוסיף
•	Esc לסגור הצעות
•	Tab להשלים מק״ט (אם אתם רוצים השלמה מלאה)
עמידות לשטח
•	גם אם המשתמש טעה ספרה → הצעות עדיין עוזרות
•	אם אין תוצאות → מציג “לא נמצא” + אפשר פעולה מוגדרת (ראה 5.3)
________________________________________
5.2 משפכת מכלולים – ניווט בלי לזכור מק״ט
למה זה קיים
כשמזהים פריט “בעין” ולא זוכרים מספר.
מבנה מומלץ
•	מסך: רשימת מכלולים (מ״ח)
•	כניסה למכלול → רשימת פריטים באותו מכלול
•	אפשר חיפוש בתוך המכלול
קיצורי דרך
•	“מכלולים אחרונים שנבחרו”
•	“מכלולים נפוצים בתחנה זו”
________________________________________
5.3 פריטים “נפוצים” + “אחרונים” + “מועדפים”
כדי להקטין הקלדה:
•	נפוצים: המערכת לומדת מה הכי נכנס הרבה (לפי תחנה/משתמש/כללי)
•	אחרונים: 20 פריטים אחרונים שנוספו
•	מועדפים: למשתמש יש כפתורי קיצור לפריטים שהוא מוסיף קבוע
________________________________________
5.4 תמיכה בסורק ברקוד (אם יש)
במערכות כאלה לרוב הסורק מזין טקסט כמו מקלדת + Enter.
המערכת צריכה:
•	לזהות זרם הקלדה מהיר
•	לקלוט מק״ט
•	להוסיף פריט מיד (ולא לפתוח תפריטים מיותרים)
________________________________________
6) מודול בחינה – החלטה מהירה + הדפסות
6.1 סטטוסים מומלצים לפריט
•	נקלט במחסן
•	ממתין לבחינה
•	בבחינה
•	מושבת
•	הועבר להמשך תהליך
•	(אופציונלי) נסגר / הוחזר / נגרט
6.2 פעולות בבחינה
לכל פריט יש שתי פעולות מרכזיות:
•	מושבת → חייב לבחור סיבה + הדפסת מדבקה
•	הועבר → מסמן כ”הועבר למעבדות” (ואצלכם נגמר)
6.3 סיבות השבתה (כפי שהגדרת)
•	בדיקה ויזואלית
•	גריטה
אפשר להרחיב בעתיד לרשימת סיבות, אבל כרגע להישאר פשוט ונקי.
________________________________________
7) הדפסת מדבקות השבתה – מפרט שטח
7.1 דרישות חובה
•	כפתור הדפס מדבקה בכל פריט מושבת
•	כפתור הדפס שוב
•	אפשרות מספר עותקים
•	הדפסה מהירה בלי מסכים נוספים מיותרים
7.2 תוכן מדבקה מומלץ
•	כותרת גדולה: מושבת
•	מק״ט
•	שם פריט (אם קיים)
•	סיבה: ויזואלי / גריטה
•	תאריך/שעה
•	מספר אירוע קליטה
•	שם הבוחן
•	(מומלץ) QR פנימי לדף הפריט במערכת
7.3 התאמה למדבקות בשטח
•	גודל מדבקה: שיהיה קריא גם על כבל
•	הדפסה שחור-לבן פשוטה
•	טקסט גדול, מינימום “קישוטים”
________________________________________
8) מסכי מינימום מערכת עובדת (MVP)
8.1 מסך “אירוע קליטה”
שדות מומלצים:
•	מספר אירוע (אוטומטי)
•	תאריך/שעה (אוטומטי)
•	יחידה מוסרת (בחירה/הקלדה)
•	שם מקבל ציוד (אוטומטי לפי משתמש)
•	הערות כלליות
•	סל פריטים (טבלה)
פעולות:
•	“הוסף פריט” (חיפוש דינמי / מכלולים / נפוצים)
•	“סיים קליטה ושלח לבחינה”
8.2 מסך “בחינה”
רשימת אירועים “ממתין לבחינה”.
כניסה לאירוע:
•	טבלת פריטים
•	לכל פריט כפתורים: מושבת / הועבר
•	כפתור הדפסה (למושבת)
8.3 מסך “פריט”
•	כל נתוני הפריט באירוע
•	סטטוס נוכחי
•	היסטוריית פעולות (מי, מתי, מה)
•	הדפסה מחדש למדבקה
________________________________________
9) מודל נתונים (Data Model) – קצר ומדויק לקודקס
9.1 ישויות (Entities)
Event (אירוע קליטה)
•	event_id
•	created_at
•	unit_name (יחידה מוסרת)
•	receiver_user_id (מקבל ציוד)
•	notes
•	status (open / waiting_for_inspection / closed)
EventItem (פריט באירוע)
•	event_item_id
•	event_id
•	makat (מק״ט)
•	item_name (אם יש קטלוג)
•	assembly_code / mh (מכלול/מ״ח)
•	quantity (ברירת מחדל 1)
•	status (received / in_inspection / disabled / transferred)
•	created_at
InspectionAction (פעולה בבחינה)
•	action_id
•	event_item_id
•	inspector_user_id
•	action_type (disable / transfer)
•	disable_reason (visual / scrap) אם action_type=disable
•	action_time
•	notes (אופציונלי)
LabelPrint (הדפסת מדבקה)
•	print_id
•	event_item_id
•	printed_by_user_id
•	printed_at
•	copies
•	printer_name (אם צריך)
•	label_template_version (לשליטה עתידית)
9.2 קטלוג פריטים (אם יש לכם מאגר)
CatalogItem
•	makat
•	item_name
•	mh / category
•	synonyms (לשיפור חיפוש)
•	is_active
________________________________________
10) כללי עבודה (Business Rules) – מונע טעויות
•	לא ניתן לסיים קליטה אם אין פריטים בסל.
•	פריט לא יכול להיות “מושבת” בלי סיבת השבתה.
•	פריט שהועבר לא יכול “לחזור” לבחינה בלי פעולה ניהולית (אופציונלי).
•	כל שינוי סטטוס נרשם בהיסטוריה (Audit).
________________________________________
11) UX דגשים לשטח (חשוב ממש)
•	כפתורים גדולים
•	קונטרסט ברור
•	“שורה פעילה” בטבלה כדי לעבוד עם מקלדת
•	הודעות קצרות: “נוסף לסל”, “לא נמצא”, “נשלח לבחינה”
•	פעולה אחת מרכזית בכל מסך, בלי להסיח
________________________________________
12) טעויות נפוצות והגנות
12.1 מק״ט לא נמצא
אפשרויות (תבחר מה מתאים):
•	מצב קשיח: “לא ניתן להוסיף אם לא קיים בקטלוג”
•	מצב גמיש: “הוסף פריט זמני” עם מק״ט שהוקלד + שם ידני (מסומן כחריג)
12.2 כפילויות בסל
•	אם מוסיפים אותו מק״ט פעמיים → לא ליצור שתי שורות, אלא להעלות כמות (quantity++)
(או שורה חדשה אם חשוב עקיבות לפי פיזיים—אבל ברירת מחדל עדיף כמות)
12.3 תיעוד מדויק של מי ביצע
•	כל משתמש נכנס עם משתמש מערכת
•	כל פעולה נשמרת עם user_id ושעה
________________________________________
13) הרשאות (מינימום)
•	מקבל ציוד: יצירת אירוע, הוספת פריטים, סיום קליטה
•	בוחן: פתיחת אירועים לבחינה, סימון מושבת/הועבר, הדפסה
•	מנהל (אם קיים): ניהול קטלוג, תיקון טעויות, דוחות בסיסיים
________________________________________
14) דוחות/מסכים שימושיים (במערכת סגורה עדיין צריך)
•	“אירועים היום”
•	“כמה פריטים הושבתו היום/השבוע”
•	“רשימת פריטים שהועברו”
•	“חיפוש אירוע לפי מספר/יחידה”
•	“חיפוש לפי מק״ט לראות היסטוריה באירועים” (אם זה מותר אצלכם)
________________________________________
15) צ’ק-ליסט פיתוח מינימלי (כדי שהמערכת תעבוד)
1.	יצירת אירוע קליטה
2.	הוספת פריטים:
o	חיפוש דינמי לפי מק״ט (Autocomplete)
o	משפכת מכלולים
o	נפוצים/אחרונים
3.	סיום קליטה → סטטוס ממתין לבחינה
4.	מסך בחינה:
o	מושבת (סיבה) + הדפסה
o	הועבר
5.	תיעוד Audit בסיסי
6.	הדפסה למדבקות + הדפסה חוזרת
________________________________________
16) ניסוח קצר “מה אנחנו צריכים שהמערכת תעשה” (למישהו חדש)
אנחנו במחסן ובמעבדת הבחינה צריכים מערכת סגורה שתאפשר:
•	לקלוט ציוד במהירות מהיחידה בעזרת חיפוש דינמי לפי מק״ט ובחירה לפי מכלולים,
•	להעביר את סל הציוד לבחינה,
•	בבחינה לסמן ציוד מושבת (ויזואלי/גריטה) או מועבר להמשך תהליך,
•	ולהדפיס מדבקות השבתה לכל פריט/כבל בצורה אוטומטית ומהירה.
________________________________________
אם תרצה “להקשיח” עוד יותר את הקודקס, אני יכול להוסיף עוד שני חלקים שממש עוזרים למפתחים:
•	זרימות משתמש מפורטות לפי מסך (User Stories)
•	פירוט טכני של החיפוש הדינמי (איך לסדר דירוג תוצאות, קאש, זמני תגובה, ומה קורה כשאין קטלוג)
כן הכל ועוד
להלן קודקס מורחב מאוד (Markdown) לפרויקט בצפ 2 — כולל כל מה שכדאי שיהיה כדי שמפתח/בודק/משתמש שטח יבין בדיוק מה המשמעות, מה צריך לבנות, ואיך זה אמור לעבוד בשטח.
שמתי הפרדה ברורה בין חובה (מה שהגדרת/דיברנו) לבין מומלץ (שדרוגים שעוזרים בשטח).
________________________________________
בצפ 2 – קודקס מוצר/אפיון מלא
מערכת סגורה לקליטת ציוד במחסן → בחינה במעבדת הבחינה → השבתה/העברה + הדפסת מדבקות השבתה
________________________________________
0) עקרון על
זמן = הכל.
בשטח (רמפה/מפרץ קבלה/מעבדה) אין סבלנות למסכים איטיים או קליקים מיותרים.
המערכת חייבת לתמוך ב־עבודה עם מקלדת/סורק, וזרימה מהירה: “רואה פריט → מוסיף → ממשיך”.
________________________________________
1) המשמעות של המערכת – מה היא פותרת ולמה
1.1 הבעיה היום (ידני)
•	מקבל ציוד רושם מק״טים על דף / מקליד אחד-אחד → איטי, טעויות, כפילויות
•	אין סטטוס ברור “איפה הפריט עכשיו”
•	במעבדת הבחינה השבתות מסומנות ידנית עם פתקים/מדבקות מאולתרים
•	קשה לחפש אחר כך: “מה קרה לפריט הזה?”, “מי השבית?”, “למה?”
1.2 מה בצפ 2 עושה בפועל (חובה)
•	אירוע קליטה מסודר (מי/מתי/איזו יחידה)
•	הוספת פריטים מהירה:
o	חיפוש דינמי לפי מק״ט (Autocomplete)
o	“משפכת מכלולים” (מ״ח → פריטים)
o	גישה מהירה לפריטים נפוצים
•	מעבדת הבחינה מקבלת את האירוע:
o	מסמנת פריט: מושבת (ויזואלי/גריטה) או הועבר להמשך תהליך
o	מדפיסה מדבקת השבתה לכל פריט/כבל שנדרש
•	תיעוד מלא: מי עשה מה ומתי (Audit)
1.3 מה “סגורה” אומר בפועל
•	רשת פנימית בלבד
•	אין שירותים חיצוניים
•	ההדפסה והסריקה מקומיות מהעמדה
•	בסיס נתונים פנימי (שרת פנימי / מחשב מרכזי / לפי מה שתחליטו)
________________________________________
2) שחקנים ותפקידים (מי עושה מה)
2.1 מקבל ציוד (מחסן / רמפה)
המטרה שלו: קליטה מהירה, בלי טעויות, בלי לחפש “איפה זה בתפריט”.
פעולות:
•	פתיחת אירוע קליטה
•	הוספת פריטים לסל (מקט/מכלול/נפוצים/סריקה)
•	סיום קליטה ושליחה לבחינה
2.2 בוחן ציוד (מעבדת הבחינה)
המטרה שלו: לקבל רשימה מוכנה, לסמן החלטה מהר, ולהדפיס מדבקות.
פעולות:
•	פתיחת אירועים שממתינים לבחינה
•	לכל פריט: מושבת/הועבר
•	אם מושבת: לבחור סיבה + להדפיס מדבקה (ואפשר הדפסה חוזרת)
2.3 מנהל/אחראי מערכת (רשות/אופציונלי)
•	ניהול קטלוג פריטים/מכלולים
•	תיקון חריגים
•	הרשאות ומשתמשים
•	דוחות בסיסיים
________________________________________
3) מילון מונחים (כדי שכולם ידברו אותו דבר)
•	מק״ט – מספר קטלוגי/מזהה פריט
•	מכלול / מ״ח – משפחה/קטגוריה (לדוגמה: “מ״ח 120”) שממנה בוחרים פריטים
•	אירוע קליטה – תיעוד של “משאית/הגעה” עם סל פריטים
•	סל – רשימת הפריטים שנוספו לאירוע
•	בחינה – שלב המעבדה שבו מחליטים מושבת/הועבר
•	מושבת – פריט שנפסל אצלכם (ויזואלי/גריטה)
•	גריטה – סיווג סופי להשמדה/פסילה (לפי ההגדרה שלכם)
•	הועבר להמשך תהליך – יצא מהשלב שלכם למעבדות/המשך שרשרת טיפול
________________________________________
4) התהליך מקצה לקצה (Flow מדויק)
4.1 קליטה במחסן (ברמפה)
1.	פתיחת אירוע קליטה
2.	הוספת פריטים לסל (מהר)
3.	סיום קליטה → האירוע ננעל ל־“עריכה בסיסית” (או ננעל לגמרי לפי החלטה)
4.	סטטוס: ממתין לבחינה
4.2 בחינה במעבדת הבחינה (ליד מפרץ קבלת הציוד)
1.	פתיחת אירוע “ממתין לבחינה”
2.	מעבר פריט־פריט:
•	“מושבת” + סיבה → הדפס מדבקה
•	“הועבר” → סטטוס מועבר
3.	סטטוס אירוע:
•	אם כל הפריטים טופלו → האירוע “נסגר” / “הושלם”
נקודת מפתח שחוזרת אצלכם: אחרי העברה למעבדות, העבודה אצלכם נעצרת.
________________________________________
5) דרישות ליבה (מה חייב להיות)
5.1 “קליטה מהירה” – חיפוש דינמי לפי מק״ט (הכי חשוב)
דרישות חובה (Behavior)
•	שדה חיפוש אחד מרכזי: “הקלד מק״ט…”
•	בזמן הקלדה מוצגים השלמות והצעות
•	אפשרות לבחור עם מקלדת בלבד
•	Enter מוסיף לסל מיד
הצעות (Results) – מה מציגים בכל שורה
•	מק״ט (גדול/בולט)
•	שם פריט (אם יש)
•	מכלול/מ״ח
•	סימון “נפוץ”/“מועדף” (אם קיים)
דירוג תוצאות (Ranking)
סדר עדיפות מומלץ:
1.	התאמה לתחילית מק״ט (prefix)
2.	התאמה מלאה למק״ט
3.	התאמה לשם/תיאור
4.	התאמה לחלק פנימי (אם תבחרו להפעיל)
מגבלות תצוגה מומלצות
•	8–12 תוצאות מקסימום (כדי לא להציף)
•	“עוד תוצאות…” רק אם צריך (אבל בשטח עדיף קצר)
“מצב סורק” (אם יש סורק)
•	סריקה מזינה מק״ט + Enter → המערכת מוסיפה לסל בלי שאלות
•	אם המק״ט לא נמצא → התראה קצרה וברורה
________________________________________
5.2 “משפכת מכלולים” – בחירה בלי לזכור מק״ט
•	בחירת מכלול (מ״ח 120 וכו’)
•	תת־רשימת פריטים במכלול
•	אפשר חיפוש בתוך המכלול
•	הוספה מהירה לסל
________________________________________
5.3 מודול בחינה
•	רשימת אירועים ממתינים
•	בתוך אירוע: רשימת פריטים
•	לכל פריט:
o	מושבת (חובה לבחור סיבה: ויזואלי/גריטה)
o	הועבר להמשך תהליך
________________________________________
5.4 הדפסת מדבקות השבתה (חובה)
•	כפתור הדפסה בעת “מושבת”
•	הדפסה חוזרת
•	בחירת מספר עותקים
•	המדבקה מיועדת להדבקה על כבל/מכשיר בפועל
________________________________________
6) מסכים ו־UI (מה המערכת מציגה בפועל)
6.1 מסך: רשימת אירועים
טאבים/פילטרים:
•	פתוחים/בטיוטה (אם מאפשרים)
•	ממתין לבחינה
•	בבחינה
•	הושלמו/נסגרו
חיפוש:
•	לפי מספר אירוע
•	לפי יחידה
•	לפי מק״ט (מומלץ מאוד)
________________________________________
6.2 מסך: אירוע קליטה (המסך של מקבל ציוד)
אזור עליון (פרטי האירוע)
•	מספר אירוע (אוטומטי)
•	תאריך/שעה (אוטומטי)
•	יחידה מוסרת (בחירה/הקלדה)
•	מקבל ציוד (מהמשתמש המחובר)
•	הערות כלליות (אופציונלי)
אזור מרכזי (שדה חיפוש מהיר)
•	שדה: “הקלד/סרוק מק״ט…”
•	כפתור: “משפכת מכלולים”
•	אזור: “נפוצים” (כפתורי קיצור)
אזור תחתון (טבלת סל)
עמודות:
•	מק״ט
•	שם פריט
•	מכלול/מ״ח
•	כמות
•	הערה לפריט (אופציונלי)
•	פעולות: + / - כמות, מחיקה
כפתורים:
•	“סיים קליטה ושלח לבחינה”
•	“שמור טיוטה” (אם תרצו מצב כזה)
________________________________________
6.3 מסך: בחינה (המסך של המעבדה)
•	פרטי אירוע (מי קלט, מתי, יחידה)
•	טבלת פריטים עם:
o	כפתור “מושבת”
o	כפתור “הועבר”
o	לאחר “מושבת”: בוחר סיבה → כפתור “הדפס מדבקה”
•	פס התקדמות: “טופלו X מתוך Y”
________________________________________
6.4 מסך: פריט (History)
•	כל הנתונים
•	סטטוס נוכחי
•	היסטוריית פעולות (מי, מתי, מה)
•	הדפסה חוזרת למדבקה
________________________________________
7) קיצורי מקלדת (כדי שזה יעבוד בשטח)
חובה מומלצת:
•	Enter: הוסף פריט (הצעה נבחרת)
•	↑ ↓: ניווט בהצעות
•	Esc: סגור הצעות / בטל פעולה
•	Ctrl+F: פוקוס לשדה החיפוש
•	Ctrl+L: פתיחת משפכת מכלולים
•	Ctrl+P: הדפס מדבקה (במסך בחינה, על פריט מושבת)
•	Tab: מעבר שדות מהיר
•	Alt+1/2/3: קפיצה לטאבים (קליטה/בחינה/דוחות) אם יש
________________________________________
8) כללי מערכת (Business Rules) – כדי למנוע טעויות
8.1 כללים באירוע
•	אי אפשר “לשלוח לבחינה” אם אין פריטים בסל
•	אחרי שליחה לבחינה:
o	או שננעל עריכה לגמרי
o	או שמתירים “תיקון מנהל בלבד”
8.2 כללים בפריט
•	“מושבת” מחייב סיבה (ויזואלי/גריטה)
•	“הועבר” נועל את הפריט לשלב שלכם (אלא אם מנהל מחזיר)
8.3 כפילויות
ברירת מחדל מומלצת:
•	אותו מק״ט נוסף שוב → מעלה כמות במקום שורה חדשה
(אם צריך עקיבות פר-יחידה פיזית בעתיד, מוסיפים “מספר סידורי” ואז כל אחד שורה נפרדת)
8.4 מק״ט לא נמצא
לבחירה (תבחרו מדיניות):
•	קשיח: לא מוסיפים אם לא נמצא בקטלוג
•	גמיש: “פריט זמני” (חריג) עם מק״ט + שם ידני
o	מסומן בולט כחריג
o	מנהל יכול לקבע אותו לקטלוג אחר כך
________________________________________
9) סטטוסים (State Machine) מומלץ
9.1 סטטוס אירוע
•	Draft/פתוח (אופציונלי)
•	WaitingForInspection (ממתין לבחינה)
•	InInspection (בבחינה)
•	Completed/Closed (הושלם)
9.2 סטטוס פריט
•	Added (נוסף לסל)
•	Received (נקלט)
•	Inspected (טופל בבחינה)
•	Disabled (מושבת)
•	Transferred (הועבר)
בפועל אפשר לפשט: “Added/Waiting” ואז ישר “Disabled/Transferred”.
________________________________________
10) מודל נתונים (Data Model) מפורט אך פשוט
10.1 Users
•	user_id
•	name
•	role (receiver / inspector / admin)
•	is_active
10.2 Event (אירוע)
•	event_id (מספר רץ)
•	created_at
•	unit_name
•	receiver_user_id
•	status
•	notes
10.3 EventItem (פריטים באירוע)
•	event_item_id
•	event_id
•	makat
•	item_name (אם יש)
•	mh / assembly
•	quantity
•	item_notes (אופציונלי)
•	status
10.4 Inspection (פעולות בחינה)
•	inspection_id
•	event_item_id
•	inspector_user_id
•	decision (disabled / transferred)
•	disable_reason (visual / scrap) אם disabled
•	decided_at
•	notes (אופציונלי)
10.5 LabelPrint (הדפסות)
•	print_id
•	event_item_id
•	printed_by_user_id
•	printed_at
•	copies
•	printer_profile (שם/פרופיל)
•	template_version
10.6 Catalog (קטלוג פריטים) – אם קיים
•	makat (PK)
•	item_name
•	mh/assembly
•	keywords/synonyms (אופציונלי לחיפוש)
•	is_active
________________________________________
11) מפרט מדבקה (Label Spec)
11.1 תוכן (כמו שצריך בשטח)
חובה:
•	“מושבת” בגדול
•	מק״ט
•	סיבה (ויזואלי/גריטה)
•	תאריך/שעה
•	מספר אירוע
•	שם הבוחן
מומלץ:
•	שם פריט
•	QR פנימי (ל־/item/{event_item_id} או מידע מקודד)
•	קוד קצר נוסף (למשל: EVT-12345)
11.2 פרופיל מדפסת
•	הגדרה אחת לכל עמדה: “מדפסת מדבקות ברירת מחדל”
•	אפשר לשמור כמה פרופילים (מעבדה/מחסן)
11.3 פעולות הדפסה
•	הדפס בעת השבתה (אוטומטית או כפתור)
•	הדפס שוב
•	X עותקים
________________________________________
12) User Stories + Acceptance Criteria (לצוות פיתוח ובדיקות)
12.1 מקבל ציוד – חיפוש דינמי
סיפור:
כמקבל ציוד, אני רוצה להתחיל להקליד מק״ט ולקבל השלמות, כדי להוסיף פריטים במהירות בלי טעויות.
קריטריונים:
•	הקלדה של 3–4 ספרות מציגה תוצאות
•	Enter מוסיף לסל
•	אם אין תוצאה → הודעה “לא נמצא” תוך שנייה
•	זמן תגובה להצעות מרגיש מיידי (ראה NFR בהמשך)
12.2 מקבל ציוד – מכלולים
כמקבל ציוד, אני רוצה לבחור פריט לפי מ״ח/מכלול כדי לא להזדקק למק״ט.
קריטריונים:
•	ניתן להגיע לפריט תוך 2–3 קליקים
•	יש חיפוש בתוך מכלול
•	הפריט נוסף לסל
12.3 בוחן – השבתה + מדבקה
כבודק במעבדה, אני רוצה לסמן פריט כמושבת ולבחור סיבה, כדי להפיק מדבקה מיידית ולהדביק בשטח.
קריטריונים:
•	אי אפשר לסמן מושבת בלי סיבה
•	אחרי שמסומן מושבת, ניתן להדפיס מדבקה בלחיצה אחת
•	יש “הדפס שוב”
12.4 בוחן – העברה
כבודק, אני רוצה לסמן פריט כ”הועבר להמשך תהליך” כדי לסיים את הטיפול שלי בפריט.
קריטריונים:
•	פריט שסומן “הועבר” מופיע עם סטטוס ברור
•	לא מוצג יותר “ממתין” באירוע
________________________________________
13) Non-Functional Requirements (דרישות איכות – כדי שזה לא יקרוס בשטח)
(אלו מומלצות אבל מאוד חשובות)
•	חיפוש דינמי: 95% מהשאילתות חוזרות תוך < 200ms ברשת פנימית
•	הוספת פריט לסל: פעולה אחת, בלי “טעינה” ארוכה
•	מערכת יציבה גם אם 2–3 עמדות עובדות במקביל
•	פעולות נשמרות מיידית (לא “נעלם לי מה שסימנתי”)
•	הדפסה: מרגע לחיצה עד יציאת מדבקה < 2 שניות (אידאלי)
________________________________________
14) תרחישים וחריגים (Checklist לבדיקות שטח)
14.1 קליטה
•	הוספת אותו מק״ט 10 פעמים (כמות)
•	סריקה רציפה של 20 פריטים
•	טעות ספרה במק״ט → האם עדיין מוצא הצעות?
•	מק״ט שלא קיים → הודעה / פריט זמני (לפי מדיניות)
14.2 בחינה
•	סימון מושבת בלי סיבה → חסימה
•	הדפסה חוזרת
•	שינוי החלטה (אם מותר) – רק מנהל?
•	אירוע עם 100 פריטים – האם עדיין נוח?
14.3 הדפסה
•	מדפסת לא מחוברת → הודעת שגיאה ברורה + אפשר לנסות שוב
•	הדפסה של 5 עותקים
________________________________________
15) לוג/Audit (תיעוד אמיתי)
חובה מינימלית:
•	מי יצר אירוע
•	מי הוסיף פריטים (ואם שיניתם כמות)
•	מי סימן מושבת/הועבר
•	מי הדפיס מדבקה ומתי
מומלץ:
•	log טכני לשגיאות מדפסת/חיפוש
________________________________________
16) הצעות “ועוד” לשיפור שממש עוזר בשטח (לא חובה)
16.1 “מצב קליטה סופר מהירה”
מסך מלא רק עם:
•	שדה מק״ט גדול
•	תוצאות
•	סל בצד
בלי שום דבר שמפריע.
16.2 “תור אירועים”
כשמעבדה עמוסה:
•	מראה כמה אירועים ממתינים
•	מי הבא בתור
16.3 “הדפסה אוטומטית”
במקום ללחוץ “הדפס”:
•	ברגע שסימנת “מושבת” + סיבה → מדפיס מיד
(רק אם זה מתאים לכם בשטח)
16.4 “תבנית מדבקה לפי סוג”
אם בעתיד יש סוגי מדבקות שונים (כבל/מכשיר), בוחרים תבנית.
________________________________________
17) פירוט טכני (בלי להכניס שירותים חיצוניים) – איך לממש חיפוש דינמי נכון
(זה לא קוד, זה עקרונות מימוש)
•	Debounce בהקלדה: לשלוח חיפוש רק אחרי 120–200ms שקט, כדי לא להציף
•	Prefix search יעיל:
o	אם יש קטלוג בבסיס נתונים: אינדקס על עמודת מק״ט
o	שאילתה שמחזירה TOP 10 לפי תחילית
•	Caching מקומי:
o	לשמור בזיכרון “תוצאות אחרונות” לפי prefixים
o	במיוחד למקטים נפוצים
•	ניקוי קלט:
o	להוריד רווחים/מקפים
o	לתמוך ב־leading zeros אם קיימים אצלכם
•	התנהגות סורק:
o	אם התקבל “מחרוזת ארוכה מהר” + Enter → להתייחס כסריקה ולהוסיף מיד
________________________________________
18) מה למסור למפתח בתכל’ס (סיכום משימה חד)
לבנות מערכת סגורה שבה:
1.	מקבל ציוד פותח אירוע קליטה
2.	מוסיף פריטים מהר עם חיפוש דינמי מק״ט + מכלולים + נפוצים
3.	שולח לבחינה
4.	מעבדה מסמנת לכל פריט מושבת (ויזואלי/גריטה) או מועבר
5.	על מושבת – מדפיסה מדבקת השבתה ומדביקה בשטח
6.	כל פעולה מתועדת
________________________________________
אם אתה רוצה “הכי עוד שיש”, אני יכול להוסיף גם:
•	טבלאות מסכים עם כל שדה/ולידציה/ברירת מחדל (כמו אפיון רשמי)
•	מפרט UX לפי “מסלול מקלדת בלבד” (איפה הפוקוס בכל רגע)
•	תבנית מדבקה לדוגמה (איך זה נראה בשורות, כולל QR payload מומלץ)
אפשרי ביותר אשמח לכל אלה ועוד.
Thought for 14s
# בצפ 2 – קודקס אפיון מלא (שטח → מחסן → מעבדת בחינה → מדבקות השבתה)
מערכת **סגורה** (רשת פנימית בלבד) לקליטת ציוד ברמפה, העברה לבחינת מעבדה, סימון **מושבת/הועבר**, והדפסת **מדבקות השבתה** (כמו פעם – רק אוטומטי).

---

## 0) עיקרון על (מה חשוב יותר מהכול)
**מהירות ודיוק בשטח.**  
המערכת נבנית סביב מצב עבודה שבו:
- ידיים עסוקות / עומס / רעש / לחץ זמן
- צריך לעבוד **מקלדת בלבד** או **סורק + Enter**
- כל פעולה חייבת להיות “קליק אחד או Enter אחד”.

---

## 1) המשמעות – מה אנחנו כחיילים צריכים שהיא תעשה
### 1.1 במחסן (רמפה)
- לפתוח **אירוע קליטה** ליחידה שהגיעה
- להוסיף פריטים לסל במהירות:
  - **חיפוש דינמי לפי מק״ט** (השלמות תוך כדי הקלדה)
  - **משפכת מכלולים (מ״ח/מכלול → פריטים)**
  - **נפוצים/אחרונים/מועדפים**
  - אופציה לסריקה (אם יש ברקוד)
- לסיים קליטה → האירוע עובר לסטטוס **ממתין לבחינה**

### 1.2 במעבדת הבחינה (ליד מפרץ הקבלה)
- לפתוח אירועים שממתינים לבחינה
- לכל פריט להחליט מהר:
  - **מושבת** + סיבה: **בדיקה ויזואלית** / **גריטה**
  - **הועבר להמשך תהליך** (למעבדות) – ומבחינתנו העבודה נעצרת
- כשמושבת: להדפיס **מדבקת השבתה** ולהדביק בפועל על פריט/כבל
- אפשרות **הדפס שוב** למדבקה

---

## 2) מילון מושגים
- **מק״ט**: מזהה פריט
- **מכלול / מ״ח**: משפחה/קטגוריה (למשל “מ״ח 120”)
- **אירוע קליטה**: “משאית/הגעה” עם סל פריטים
- **סל**: רשימת הפריטים באירוע
- **בחינה**: החלטה מושבת/הועבר
- **מושבת**: נפסל אצלכם (ויזואלי/גריטה)
- **הועבר**: יצא מהשלב שלכם להמשך תהליך

---

## 3) מסכים (Sitemap) – מינימום + מה מומלץ
### 3.1 חובה (MVP)
1. התחברות/זיהוי משתמש
2. רשימת אירועים
3. יצירת אירוע קליטה
4. מסך אירוע קליטה (סל + חיפוש דינמי + מכלולים)
5. מסך בחינה (אירוע + החלטות + הדפסה)
6. מסך פריט (היסטוריה + הדפסה חוזרת)

### 3.2 מומלץ מאוד
7. דוחות בסיסיים
8. ניהול קטלוג (מנהל בלבד)
9. הגדרות תחנה (מדפסת/פרופיל הדפסה)

---

# 4) אפיון מסכים – שדות, ולידציות, ברירות מחדל

## 4.1 מסך התחברות (אם יש)
> אם עובדים עם משתמשי מערכת פנימיים – מספיק “בחירת משתמש”/כרטיס עובד/סיסמה פשוטה.

| שדה | סוג | חובה | ברירת מחדל | ולידציה | הערות |
|---|---|---:|---|---|---|
| משתמש | בחירה/הקלדה | כן | — | חייב להיות פעיל | |
| סיסמה/אימות | טקסט | תלוי | — | לפי מדיניות יחידה | אפשר גם התחברות אוטומטית בתחנה |

---

## 4.2 מסך רשימת אירועים
### פילטרים
- היום / השבוע
- ממתין לבחינה
- בבחינה
- הושלם/נסגר

### חיפוש
- מספר אירוע
- יחידה
- מק״ט (מחפש בתוך פריטים באירועים)

**שדות תצוגה מומלצים בטבלה:**
| עמודה | הערות |
|---|---|
| מספר אירוע | קישור למסך אירוע |
| תאריך/שעה | |
| יחידה | |
| מקבל ציוד | |
| סטטוס | תגית צבע/סמל |
| כמות פריטים | X פריטים |
| התקדמות בחינה | X/Y טופלו (אם רלוונטי) |

---

## 4.3 מסך “יצירת אירוע קליטה”
| שדה | סוג | חובה | ברירת מחדל | ולידציה | הערות |
|---|---|---:|---|---|---|
| יחידה מוסרת | בחירה/הקלדה | כן | — | לא ריק | אפשר רשימה + חיפוש |
| הערות אירוע | טקסט | לא | ריק | מקס’ אורך | |
| מקבל ציוד | אוטומטי | כן | המשתמש המחובר | — | לא לעריכה רגילה |

**פעולות:**
- צור אירוע → מעבר למסך אירוע קליטה

---

## 4.4 מסך “אירוע קליטה” (הלב של המחסן)
### 4.4.1 אזור פרטי אירוע
| שדה | סוג | חובה | ברירת מחדל | ולידציה | הערות |
|---|---|---:|---|---|---|
| מספר אירוע | קריאה בלבד | כן | אוטומטי | ייחודי | |
| תאריך/שעה | קריאה בלבד | כן | עכשיו | — | |
| יחידה | בחירה/הקלדה | כן | מיצירה | לא ריק | שינוי רק לפני שליחה לבחינה (מומלץ) |
| מקבל ציוד | קריאה בלבד | כן | משתמש מחובר | — | |
| סטטוס | תגית | כן | פתוח | — | |

### 4.4.2 אזור הוספת פריט (חיפוש דינמי)
| רכיב | חובה | התנהגות |
|---|---:|---|
| שדה “הקלד/סרוק מק״ט” | כן | מציג הצעות תוך כדי הקלדה, Enter מוסיף |
| תוצאות/Dropdown | כן | 8–12 תוצאות, ניווט ↑↓ |
| כפתור “משפכת מכלולים” | כן | פתיחה מיידית למכלולים |
| אזור “נפוצים/אחרונים” | מומלץ | כפתורים גדולים להוספה בלחיצה |

### 4.4.3 טבלת סל (פריטים באירוע)
| עמודה | חובה | ולידציה/כלל |
|---|---:|---|
| מק״ט | כן | ספרות בלבד (אם כך אצלכם), או פורמט מק״ט תקני |
| שם פריט | מומלץ | מהקטלוג / “לא ידוע” אם חריג |
| מכלול/מ״ח | מומלץ | מהקטלוג |
| כמות | כן | >= 1 |
| הערת פריט | לא | מקס אורך |
| פעולות | כן | + / - / מחיקה |

**כלל כפילויות (מומלץ):** מק״ט שנוסף שוב → מגדיל כמות (ולא שורה חדשה).

### 4.4.4 פעולות תחתונות (קריטיות)
| פעולה | מי | תנאי | תוצאה |
|---|---|---|---|
| שמור טיוטה | מקבל | אופציונלי | נשמר ללא שליחה |
| סיים קליטה ושלח לבחינה | מקבל | יש לפחות פריט 1 | סטטוס אירוע → ממתין לבחינה |
| ביטול אירוע | מנהל/מקבל | אם ריק או לפי הרשאה | נסגר/מבוטל |

---

## 4.5 מסך “בחינה” (מעבדת הבחינה)
### 4.5.1 פרטי אירוע (קריאה בלבד)
| שדה | חובה |
|---|---:|
| מספר אירוע | כן |
| יחידה | כן |
| מי קלט ומתי | כן |
| כמות פריטים | כן |
| סטטוס | כן |

### 4.5.2 טבלת פריטים לבחינה
| עמודה | חובה | הערות |
|---|---:|---|
| מק״ט | כן | |
| שם פריט | מומלץ | |
| כמות | כן | אם כמות>1 – אפשר “סמן לכל הכמות” |
| סטטוס פריט | כן | ממתין/מושבת/הועבר |
| פעולות | כן | מושבת / הועבר |
| הדפסה | כן למושבת | הדפס / הדפס שוב |

### 4.5.3 חלון “מושבת” (חובה סיבה)
| שדה | סוג | חובה | ברירת מחדל | ולידציה |
|---|---|---:|---|---|
| סיבת השבתה | בחירה | כן | — | רק: ויזואלי / גריטה |
| הערה | טקסט | לא | ריק | מקס אורך |

**כלל:** אי אפשר לסגור “מושבת” בלי סיבה.

### 4.5.4 פעולות בחינה
| פעולה | תוצאה |
|---|---|
| מושבת | סטטוס פריט=מושבת + דורש הדפסה |
| הועבר | סטטוס פריט=הועבר (ומבחינתכם נגמר) |
| סגור אירוע | אם כל הפריטים טופלו | סטטוס אירוע=הושלם |

---

## 4.6 מסך “פריט” (History + הדפסה חוזרת)
| שדה | חובה | הערות |
|---|---:|---|
| מק״ט + שם | כן | |
| אירוע שייך | כן | מספר אירוע |
| סטטוס נוכחי | כן | |
| היסטוריית פעולות | כן | מי/מתי/מה |
| הדפסה חוזרת | כן אם מושבת | כפתור “הדפס שוב” |

---

# 5) UX “מקלדת בלבד” – סדר פוקוס וקיצורים

## 5.1 עקרונות פוקוס
- ברגע שנכנסים למסך קליטה: הפוקוס תמיד על **שדה מק״ט**
- אחרי הוספה לסל: הפוקוס חוזר אוטומטית לשדה מק״ט
- כל חלון/דיאלוג: Enter = אישור, Esc = ביטול

## 5.2 קיצורי מקלדת (סטנדרט)
> אם אתם לא רוצים הכול – לפחות את הקריטיים.

### גלובלי
- **Ctrl+F**: פוקוס לחיפוש (אם לא כבר)
- **Esc**: סגור חלון/תוצאות
- **Alt+1/2/3**: ניווט למסכים (אירועים/קליטה/בחינה) – אופציונלי

### מסך אירוע קליטה
- **Enter**: הוסף פריט (ההצעה הנבחרת)
- **↑↓**: ניווט הצעות
- **Ctrl+L**: פתיחת משפכת מכלולים
- **Ctrl+Backspace**: ניקוי שדה מק״ט
- **Ctrl+Enter**: סיים קליטה ושלח לבחינה (עם אישור קצר)

### מסך בחינה
- **D**: מושבת לפריט הנבחר (אופציונלי)
- **T**: הועבר לפריט הנבחר (אופציונלי)
- **Ctrl+P**: הדפס מדבקה לפריט מושבת (או “הדפס שוב”)

## 5.3 “מסלול עבודה” בפועל (מה שהחייל עושה)
### קליטה מהירה – 20 פריטים ברצף
1) פותח אירוע  
2) מקליד/סורק → Enter  
3) רואה “נוסף לסל” קטן  
4) ממשיך…  
5) Ctrl+Enter לסיום ושליחה לבחינה  

### בחינה מהירה
1) פותח אירוע ממתין  
2) על כל שורה: מושבת/הועבר  
3) במושבת: בוחר סיבה (1/2) → Enter → הדפס → הבא  
4) סוגר אירוע

---

# 6) מדבקת השבתה – תבנית, דוגמה, ו־QR

## 6.1 כללי תוכן למדבקה
חובה:
- “**מושבת**” גדול
- מק״ט
- סיבה: ויזואלי/גריטה
- תאריך/שעה
- מספר אירוע
- שם הבוחן

מומלץ:
- שם פריט
- QR פנימי (פותח את דף הפריט במערכת הסגורה / או מכיל מידע מקודד)

## 6.2 דוגמת תבנית מדבקה (טקסטואלית)
> מיועד שיראה טוב במדפסת מדבקות, שחור-לבן, ברור.

┌───────────────────────────┐
│ מושבת │
├───────────────────────────┤
│ מק״ט: 3109285354 │
│ פריט: מכלול 120 - ______ │
│ סיבה: בדיקה ויזואלית │
│ אירוע: EVT-001234 │
│ בוחן: ש.אליהו │
│ תאריך: 20/01/2026 14:35 │
│ QR: [■■■■■■■■■■] │
└───────────────────────────┘

## 6.3 QR – מה הוא מכיל
בחרו אחת מהשיטות:

### שיטה A (מומלץ אם יש גישה לעמוד פנימי)
- QR מכיל URL פנימי, לדוגמה:  
  `/item/EVENT_ITEM_ID`  
הסריקה פותחת את דף הפריט במערכת (בתוך רשת פנימית בלבד).

### שיטה B (אם אין דפדפן/אין ניתוב)
- QR מכיל מחרוזת נתונים מקוצרת, לדוגמה:  
  `EVT=1234|MK=3109285354|RS=VIS|TS=20260120T1435`

---

# 7) כללי מערכת (Business Rules) – כדי שזה יתנהג נכון

## 7.1 מעברים (State Rules)
- אירוע “פתוח” → “ממתין לבחינה” רק אם יש לפחות פריט אחד
- פריט “מושבת” חייב סיבה
- פריט “הועבר” לא חוזר אחורה ללא הרשאת מנהל (מומלץ)

## 7.2 הרשאות (מטריצה קצרה)
| פעולה | מקבל ציוד | בוחן | מנהל |
|---|---:|---:|---:|
| ליצור אירוע | ✅ | ❌ | ✅ |
| להוסיף פריטים | ✅ | ❌ | ✅ |
| לשלוח לבחינה | ✅ | ❌ | ✅ |
| לבצע בחינה | ❌ | ✅ | ✅ |
| לסמן מושבת/הועבר | ❌ | ✅ | ✅ |
| להדפיס מדבקה | ❌ | ✅ | ✅ |
| לערוך אחרי שליחה לבחינה | ❌/מוגבל | ❌ | ✅ |
| ניהול קטלוג | ❌ | ❌ | ✅ |

---

# 8) אפיון חיפוש דינמי – התנהגות מדויקת (בלי קוד)

## 8.1 מה המשתמש רואה
- מתחיל להקליד מק״ט → מיד מופיעות הצעות
- ההצעה הראשונה הכי רלוונטית
- Enter מוסיף אותה לסל

## 8.2 דירוג (Ranking) מומלץ
1) תחילית מק״ט (prefix)  
2) התאמה מלאה  
3) שם/תיאור  
4) חלק פנימי (אם מפעילים)

## 8.3 חוקים לשטח
- הצעות מקסימום 8–12
- אם אין תוצאות:
  - הודעה קצרה: “לא נמצא”
  - ואז לפי מדיניות: חסימה או “פריט זמני”

## 8.4 “פריט זמני” (אם אתם מאשרים חריגים)
- המערכת מציגה: “הוסף כחריג?”
- דורשת שם קצר
- מסומן בטבלה בצבע/תגית “חריג”
- מנהל יכול להפוך אותו לקטלוג קבוע בהמשך

---

# 9) הודעות מערכת (מומלץ להגדיר מראש)
> כדי שהמפתח לא ימציא הודעות לא אחידות.

## 9.1 הודעות הצלחה (Toast קצר)
- “נוסף לסל”
- “עודכן כמות”
- “נשלח לבחינה”
- “סומן מושבת”
- “סומן הועבר”
- “נשלח להדפסה”

## 9.2 הודעות שגיאה (ברורות)
- “מק״ט לא נמצא”
- “חובה לבחור סיבת השבתה”
- “לא ניתן לשלוח לבחינה – אין פריטים”
- “מדפסת לא זמינה – בדוק חיבור ונסה שוב”

---

# 10) נתונים (Data Dictionary) – כדי שכולם יבנו אותו דבר

## 10.1 Event (אירוע)
- event_id (רץ)
- created_at
- unit_name
- receiver_user
- status (open / waiting / in_inspection / closed)
- notes

## 10.2 EventItem (פריט באירוע)
- event_item_id
- event_id
- makat
- item_name (מהקטלוג או ידני לחריג)
- mh/assembly
- quantity
- item_notes
- status (added/disabled/transferred)

## 10.3 InspectionAction (פעולת בחינה)
- action_id
- event_item_id
- inspector_user
- decision (disabled/transferred)
- disable_reason (visual/scrap)
- decided_at
- notes

## 10.4 LabelPrint (הדפסות)
- print_id
- event_item_id
- printed_by
- printed_at
- copies
- printer_profile

---

# 11) בדיקות (QA) – סט תרחישים מוכנים
## 11.1 Smoke (חובה לפני שטח)
- יצירת אירוע → הוספת פריט → שליחה לבחינה → סימון מושבת → הדפסה
- סימון הועבר
- הדפסה חוזרת

## 11.2 תרחישי עומס (שטח אמיתי)
- הוספת 50 פריטים ברצף עם הקלדה
- סריקה רציפה (אם יש) של 30 פריטים
- אירוע עם 100 פריטים: בדיקה שהמסך לא נהיה כבד

## 11.3 חריגים
- מק״ט לא קיים
- ניסיון לשלוח אירוע ריק
- מושבת בלי סיבה
- מדפסת מנותקת

---

# 12) Definition of Done (כדי לדעת שסיימנו)
- מקבל ציוד יכול לקלוט אירוע מלא בלי עכבות (Autocomplete עובד)
- בחינה מאפשרת מושבת/הועבר עם ולידציות
- מדבקות יוצאות כמו שצריך + הדפסה חוזרת
- כל פעולה נשמרת עם משתמש+זמן
- הודעות ברורות, מסכים לא מבלבלים
- עובד ברשת פנימית בלבד

---

# 13) “עוד” מומלץ (שדרוגים שעוזרים ממש, אבל לא חובה)
- מצב “קליטה סופר מהירה” (מסך נקי רק מק״ט+סל)
- נפוצים לפי תחנה/משתמש
- אחרונים (20 אחרונים) ככפתורים
- “סמן לכל הכמות” בבחינה (אם quantity>1)
- תור אירועים “ממתינים לבחינה” עם סדר עדיפות

---

